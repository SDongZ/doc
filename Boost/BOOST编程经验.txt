【BOOST编译】
b2 toolset=msvc-10.0 --with-iostreams
b2.exe --show-libraries
b2.exe --with-<library>
---------------------------------------------------------------------------
http://stackoverflow.com/questions/4586768/how-to-iterate-a-boost-property-tree
boost property_tree 使用 迭代器，
BOOST_FOREACH is just a convenient way for iterating that can be done by iterator, begin() and end()
http://www.boost.org/doc/libs/1_54_0/libs/crc/crc.html
http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/reference/binary/binary_little.html
分析字符串，"\x01\x02"，并转成，对应的 高位序  与  底位序
http://stackoverflow.com/questions/105252/how-do-i-convert-between-big-endian-and-little-endian-values-in-c
---------------------------------------------------------------------------
---------------------------------------------------------------------------
json 文件里中的，字符串，转义符（escape character）问题？http://stackoverflow.com/questions/4113967/escaping-character-in-json-string
std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair<int,float> 或者 std：：pair<double,double>等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数
This class couples together a pair of values, which may be of different types (T1 and T2). The individual values can be accessed through its public members first and second.
---------------------------------------------------------------------------
http://cpp.ezbty.org//myfiles/boost/libs/smart_ptr/smart_ptr.htm
boost智能指针
scoped_ptr
<boost/scoped_ptr.hpp>
简单的单一对象的唯一所有权。不可拷贝。
scoped_array
<boost/scoped_array.hpp>
简单的数组的唯一所有权。不可拷贝。
shared_ptr
<boost/shared_ptr.hpp>
在多个指针间共享的对象所有权。
shared_array
<boost/shared_array.hpp>
在多个指针间共享的数组所有权。
weak_ptr
<boost/weak_ptr.hpp>
一个属于 shared_ptr 的对象的无所有权的观察者。
intrusive_ptr
<boost/intrusive_ptr.hpp>
带有一个侵入式引用计数的对象的共享所有权。

---------------------------------------------------------------------------
[http-request-response.png][http-request.png][http-response.png]
http 协议  客户端请求
GET / HTTP/1.1
Host:www.google.com
<request line>
<headers>
<blank line>
[<request-body>]
表单提交中get和post方式的区别归纳如下几点：

（1）get是从服务器上获取数据，post是向服务器传送数据。
（2）对于表单的提交方式，在服务器端只能用Request.QueryString来获取Get方式提交来的数据，用Post方式提交的数据只能用Request.Form来获取。
（3）一般来说，尽量避免使用Get方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。但是在分页程序中，用Get方式就比用Post好

http://www3.ntu.edu.sg/home/ehchua/programming/webprogramming/http_basics.html

---------------------------------------------------------------------------
http://stackoverflow.com/questions/3150942/c-delete-this
http://www.parashift.com/c++-faq-lite/delete-this.html
http://stackoverflow.com/questions/447379/what-is-the-use-of-delete-this
关于delete this 的思考：
delete this
1. 违背了“谁分配，谁释放”的原则。
( C++ 不充许 对象自己创建自己。必然是另一个对象创建了它。)
2. 使分配的指针，变成了“野指针”。（无法把指针置空）
As long as you're careful, it's OK for an object to commit suicide (delete this).
"delete this" is commonly used for ref counted objects（引用计数的对象）. For a ref counted object the decision of when to delete is usually placed on the object itself.
ATL COM objects are a prime example of this pattern.
int MyRefCountedObject::Release() {
 _refCount--;
 if ( 0 == _refCount ) {
   delete this;
   return 0;
 }
 return _refCount;
}
http://stackoverflow.com/questions/550189/is-it-safe-to-delete-this
delete this is a "code smell" (代码异味) that your code might not have a symmetric(均衡的) strategy(策略) for object ownership (who allocates and who deletes).
https://www.securecoding.cert.org/confluence/display/cplusplus/OOP05-CPP.+Avoid+deleting+this
Avoid deleting this

Deleting this leaves it as a "dangling" pointer, which leads to undefined behavior if it is accessed. Deleting this is only valid if you can guarantee that the this pointer is never dereferenced again. Furthermore, deleting this is only valid if you can guarantee the object was allocated using the {{new]} operator.
---------------------------------------------------------------------------
http://www.cnblogs.com/TianFang/archive/2013/02/04/2891538.html
http://blog.csdn.net/vagrxie/article/details/4225133
boost 字符串比较算法
<boost/algorithm/string.hpp>
忽略大小写比较字符串
tolower()
将字符转换成小写字符
toupper()
将字符转换成大写字符 
boost库在头文件<boost/algorithm/string.hpp>中提供了不少字符串处理函数，用以帮助我们实现基本的字符串处理功能，极大程度上缓解了字符串函数不够用的问题
#include <boost/algorithm/string.hpp>
// Or, for fewer header dependencies:
//#include <boost/algorithm/string/predicate.hpp>

std::string str1 = "hello, world!";
std::string str2 = "HELLO, WORLD!";

if (boost::iequals(str1, str2))  还可比较 宽字符串 与 多字节字符串，（转码不行。。。默认怎么转的？）
boost::iequals(pname, processInfo->szExeFile)
---------------------------------------------------------------------------
boost::flyweight

使用Boost.Flyweight的好处

http://www.cnblogs.com/zhangwusheng/archive/2011/09/23/2185957.html
http://blog.csdn.net/zirandeai/article/details/8288404
简单点说，就是当需要生成N个实例，而这N个实例中有部分域是冗余重复的，那么这个时候就可以使用flyweight模式了，就是享元模式
享元模式的思想就是把重复的数据只在一个桶中保存一份，当外部对象需要使用数据时，只要保存一个该数据在桶中的引用即可，而无需每个对象都持有该数据
vector< boost::flyweight<string> >  boost_v
boost_v.push_back( boost::flyweight<string>( tmp )  );
vector< string >  stl_v;
stl_v.push_back( (tmp)  );
使用flyweight后，每次保存的不是实际的对象，而只是handler，从而使得在存储冗余数据时，内存消耗大大减小
---------------------------------------------------------------------------
http://www.cppblog.com/youxia/archive/2010/10/17/130218.html
http://stlab.adobe.com/gil/presentation/index.htm
gil - Generic Image Library, from Lubomir Bourdev and Hailin Jin  通用图形库
---------------------------------------------------------------------------
#include <Windows.h>
#include <boost/asio.hpp>  
vc 命令行程序（不包含任何其它头文件的情况下），
出现下面的错误
boost_1_54_0\boost\asio\detail\socket_types.hpp(22): fatal error C1189: #error :  WinSock.h has already been included
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
在头文件前加上这个宏处理片段，就可以正常编译了。
http://stackoverflow.com/questions/9750344/boostasio-winsock-and-winsock-2-compatibility-issue
Try and change the order or includes. Start with boost/asio.hpp and put windows.h after it.
There's a similar issue with ACE, including ace/OS.h before anything else solves it.
---------------------------------------------------------------------------
inprocess  server 程序，使用，managed_window_shared_memory,  
boost::interprocess::open_only  打开，出下面的错误。 
(debug版本没有问题，debug是用户启动的，不是系统启动的服务。)  改成managed_shared_memory 就可以用了。
[查看录播机状态]创建共享内存异常 : 系统找不到指定的文件。
---------------------------------------------------------------------------
http://www.boost.org/community/review_schedule.html
BOOST预览库(注意其中的dropbox链接)
---------------------------------------------------------------------------
BOOST_FOREACH 原理？会调用 begin()吗？还是别的函数
http://www.boost.org/doc/libs/1_54_0/doc/html/foreach.html
So you can't use a range-based for-loop here. You have to use a real for-loop over the iterators
for(auto &attrIt = children.begin(); attrIt != children.end();)
---------------------------------------------------------------------------
https://svn.boost.org/trac/boost/ticket/4182
包含boost库出现 警告
warning C4005: “INT8_MIN”
This is nothing to do with us - the fact that two Microsoft headers conflict with each other is their issue not ours - sorry to be so blunt, but we should be able to use <stdint.h> without worrying what other headers may have been included.
#include <intsafe.h>
#include <stdint.h>
warning c4005宏重定义  boost
http://wanwan722.wordpress.com/category/boost/
lF是Visual Studio 2010和Windows SDK 7.0的定xn突}  下面是这个问题的链接
Including stdint after intsafe generates warnings  (This is fixed in VS 2012.)
http://connect.microsoft.com/VisualStudio/feedback/details/621653/including-stdint-after-intsafe-generates-warnings
解决方法：（在stdafx.h头文件，开头写入下面两行）
#define _INTSAFE_H_INCLUDED_
#include <stdint.h>
---------------------------------------------------------------------------

http://boost.cowic.de/rc/pdf/ 
http://meetingcpp.com/tl_files/blog/boost_1_55.png
c++ boost 库，联系图
Boost.Asio writes debugging output to the standard error stream.
---------------------------------------------------------------------------
【property-tree】
boost::property_tree::ptree设置树路径 的分隔符
http://stackoverflow.com/questions/1948745/boost-property-tree-with-filename-as-key
第一种解决方法：
pt.push_back( ptree::value_type("example.txt", ptree(10)) );
第二种解决方法： (这种方法没有重载函数)
pt.put('/', "example.txt", "10");
pt.get<string>('/', "example.txt");
http://www.boost.org/doc/libs/1_47_0/doc/html/boost_propertytree/accessing.html
typedef ptree::path_type path;
pt.get<float>(path("p.a.t.h/t.o/v.a.l.u.e", '/'));
pt.get(path("p.a.t.h/t.o/v.a.l.u.e", '/'), 0, NULL);
pt.get_optional<std::string>(path("p.a.t.h/t.o/v.a.l.u.e", '/'));


写XML出现很多空的换行符
So the solution was to add the trim_whitespace flag to the call to read_xml:
read_xml("file.xml", pt, boost::property_tree::xml_parser::trim_whitespace );
boost::property_tree::read_xml
( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
http://stackoverflow.com/questions/6572550/boostproperty-tree-xml-pretty-printing
        boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);
        boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );
        
        
WriteXMLData  wptree 含有有中文 时，
        boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);
        boost::property_tree::write_xml( xml_path, ptree, std::locale(), settings ); 会异常。
wptree问题
http://stackoverflow.com/questions/10568531/boost-property-tree-issue-when-converting-to-unicode
http://notes.xj-labs.net/?p=52
Boost 目前是支持 UTF8 的，但是不能用 直接用 Unicode。所以，如果要存储宽字符就有点麻烦需要用到 Boost 提供的 utf8_codecvt_facet 做转换
#include "boost/program_options/detail/utf8_codecvt_facet.hpp"
std::locale utf8Locale(
oldLocale,
           new boost::program_options::detail::utf8_codecvt_facet());
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);  格式化输出XML
boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );  
把UNICODE输出为UTF8
读的时候也出这个问题
http://stackoverflow.com/questions/10568531/boost-property-tree-issue-when-converting-to-unicode/16071043#16071043  (这里方法显然不行)
boost::property_tree::read_xml( wstring2string( xml_file ), xml, 0, utf8Locale );
注意后面两个字符串，是用于输出 文件 流格式化的。
ptree.put_child( node_name, file_node );  
已经存在 ，就覆盖，能不能抛异常，或者其它处理方式呢？

http://www.boost.org/doc/libs/1_43_0/doc/html/boost/property_tree/basic_ptree.html#id979449-bb  ptree文档
assoc_iterator find(const key_type & key) ;  应该输入什么？键值吗？可是还是找不到啊(只找其子节点的)
Find a child with the given key, or not_found() if there is none
始终不对, 不存在，也能找到
http://boost.2283326.n4.nabble.com/property-tree-find-no-match-for-operator-td3860490.html
 I know that ptree uses multi_index
Anyway :
- you have a get_optional() method.
- you can try replacing end() with not_found()
用find 未找到使用方法，暂时用get_child_optional 来判断。
        std::string path = "product." + wstring2string( pro );
        if( m_tree.get_child_optional( path ) ) {
                throw std::exception( "产品名称已经存在" );
        }
        m_tree.put( path, "" );

理解 key_type
ptree 的数据结构，可以理解为下面的形式
struct ptree
{
  data_type data;                         // data associated with the node
  list< pair<key_type, ptree> > children; // ordered list of named children
};
Both key_type and data_type are configurable, but will usually be std::string
optional< self_type & > get_child_optional(const path_type & path) ;
Get the child at the given path, or return boost::null.
boost property_tree 判断已经存在的节点
http://stackoverflow.com/questions/7568607/boost-property-tree-check-if-child-exists
if( node.count("possibliy_missing") == 0 )
{
  ...
}
ptree::const_assoc_iterator it = ptree.find("possibly_missing");
if( it == ptree.not_found() )
{
  ...
}


boost property tree delete child
http://stackoverflow.com/questions/11047950/boost-property-tree-remove-a-node
/** Erase the child pointed at by the iterator. This operation
        * invalidates the given iterator, as well as its equivalent
        * assoc_iterator.
        * @return A valid iterator pointing to the element after the erased.
        */
       iterator erase(iterator where);
ptree::const_assoc_iterator it = ptree.find("possibly_missing");



boost property_tree ptree write_xml 空节点问题
recordfileinfo.add_child( "Tags",  boost::property_tree::ptree( "" ) );
recordfileinfo.add( "Tags",  “”);
有区别吗？  两者一样都是： <Tags/>  空节点问题


关于ini文件的注释格式http://blog.163.com/wangzhenbo85@126/blog/static/101363282201011146306646/

[xxx]
a=a
;这里是a的注释
b=b
;这里是b的注释
c=c
d=d
注意： 这样写会把后面的分号及之后的内容都包含进去只能在行头加分号
---------------------------------------------------------------------------
boost optional
 optional库使用"容器"语义，包装了"可能产生无效值"的对象，实现了"未初始化"的概念.
http://blog.csdn.net/mmzsyx/article/details/8163259
"无意义"的值:
函数并不总能返回有效的返回值，很多时候函数可能返回"无意义"的值，
这不意味着函数执行失败，而是表明函数正确执行了，但结果却不是有用的值
optional很像一个仅能存放一个元素的容器，它实现了"未初始化"的概念：
如果元素未初始化，那么容器就是空的，否则，容器内就是有效的，已经初始化的值
optional的真实接口很复杂，因为它要能够包装任何的类型
---------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
http://stackoverflow.com/questions/9538114/utf-8-locale-in-visual-c-2010
这个会和boost的函数冲突造成
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
出现下面错误
error C2661: “std::locale::facet::operator new”: 没有重载函数接受 3 个参数
If you are looking for existing memory leaks, you can use DEBUG_NEW if you are in VS2010.
---------------------------------------------------------------------------
boost::is_any_of( "_." )  造成警告：
warning C4996: 'std::_Copy_impl'  这个警告只在DEBUG版里出，RELEASE版本里不出。
Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'
http://stackoverflow.com/questions/14141476/warning-with-boostsplit-when-compiling
忽略警告
-D_SCL_SECURE_NO_WARNINGS
---------------------------------------------------------------------------
---------------------------------------------------------------------------

md5 sha1 boost
http://en.wikipedia.org/wiki/Crypto%2B%2B
www.boost.org/doc/libs/1_46_0/boost/uuid/sha1.hpp
boost::uuids::detail::sha1 s
s.process_bytes(a.c_str(), a.size());
unsigned int digest[5];
s.get_digest(digest);
---------------------------------------------------------------------------
【VISCA.png】
asio pdf
http://meetingcpp.com/tl_files/mcpp/slides/12/Boost.Asio%20-%20Asynchronous%20IO.pdf
http://en.wikipedia.org/wiki/VISCA_Protocol
http://www.vaddio.com/images/downloads/tc_sony_z700_commandlist.pdf
使用BOOST::ASIO 读取COM串口数据，最后，总是多出一些数据
90 41 FF 90 51 FF

Serial ports are available on all POSIX platforms. For Windows, serial ports are only available at compile time when the I/O completion port backend is used (which is the default). A program may test for the macro BOOST_ASIO_HAS_SERIAL_PORTS to determine whether they are supported.

boost asio write_some 与 write有什么区别？
                boost::asio::io_service::work work( m_io_service );
                m_io_service.run();


【asio-tcp-iostream.png】
【boost asio 缓存集】
发送多个缓存
                boost::array<boost::asio::const_buffer, 2> bufs;
                bufs[0] = boost::asio::buffer(&id_, sizeof(id_));
                bufs[1] = boost::asio::buffer(this, sizeof(this));
                socket.send_to(bufs, remote);
接收时，就需要有几个缓存
                boost::array<boost::asio::mutable_buffer, 2> bufs = {
                        boost::asio::buffer(&id, sizeof(id)),
                        boost::asio::buffer(buffer)
                };
                size_t rcv_size = socket_.receive_from(bufs, remote_endpoint);
asio
typedef std::pair<void*, std::size_t> mutable_buffer;
typedef std::pair<const void*, std::size_t> const_buffer;
asio 中的 I/O 对象  基于流的对象
socket,
ip::tcp::socket, ssl::stream<>, posix::stream_descriptor, windows::stream_handle



获取本地IP地址   BOOST ASIO如何做？  （所有地址列表）
gethostbyname ip address
http://beej.us/guide/bgnet/output/html/multipage/gethostbynameman.html
http://msdn.microsoft.com/en-us/library/windows/desktop/ms738552(v=vs.85).aspx
typedef struct hostent {
 char FAR      *h_name;
 char FAR  FAR **h_aliases;
 short         h_addrtype;
 short         h_length;

 char FAR  FAR **h_addr_list;  
A NULL-terminated list of addresses for the host.
Addresses are returned in network byte order.

} HOSTENT, *PHOSTENT, FAR *LPHOSTENT;

【asio 设置同步操作的超时？没有正规方法】
由BOOST::THREAD创建的线程，调用receive_from阻塞住。
当在另主线程里，调用server_thread_.interrupt();时，会出现下面的异常。
UDP服务器接收数据时异常: receive_from: 一个封锁操作被对 WSACancelBlockingCall 的调用中断。
socket_.shutdown(boost::asio::ip::udp::socket::shutdown_both);  一个效果


[asio 串口编程]
i/o 读写的codecvt local facet
boost/program_options/detail/utf8_codecvt_facet.hpp
		static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
		boost::property_tree::wptree xml;
		boost::property_tree::read_xml( wstring2string( xml_file ), xml, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
		
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
	boost::property_tree::read_xml( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
	boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );

http://msdn.microsoft.com/en-us/library/ff802693.aspx
串口通信开发文档。
Overlapped I/O operation

boost::asio::socket 异步读写时  socket关闭问题？需要同步吗？

Using the attached sample program (a slightly modified version of the daytime3 tutorial). When I connect with a telnet session to the server and close the connection directly I get the following output from the server: Transfer status: Success. Transfer status: Broken pipe. Transfer status: Broken pipe. Transfer status: Broken pipe.

After the first error I close the socket and would expect a boost::asio::error::operation_aborted error instead of the broken pipe.

Reproduced under both Debian Lenny (gcc 4.3.4) and Windows XP (MSVC 2008).
当调用close后，正在写的操作，就completed with an error as soon as the client closed the connection
The behaviour is correct. The write operations are not pending when you call close, it's just that the handlers haven't been called yet. The write operations themselves completed with an error as soon as the client closed the connection.

CloseHandle(impl.handle_) 串口，即使只有一个线程，也会死在句。退不出来。USB2PORT
I agree with both previous posts.

This is a bug in the driver for FTDI chipset under Windows XP.
The native method CloseHandle() never returns, when the port handle is closed.

https://connect.microsoft.com/VisualStudio/feedback/details/202137/serialport-close-hangs-the-application

This is not a normal situation.
Unplugging the USB device usually helps.
This problem is related to the glitches in the FTDI driver, which is responsible for implementing a virtual COM port. On the other hand those "glitches" are related to various malfunctions of the USB devices. (Of course this doesn't justify the FTDI driver).

BTW there're several other known problems with some FTDI drivers:

Sometimes call to CloseHandle just hangs the calling thread.
Sometimes also the application is still "visible" in the task manager, even after it's closed. Task manager can't terminate the application, and the debugger can't be attached to it. Its EXE file is locked (can't be erased).
Usually unplugging the USB device immediately helps in those situations. The FTDI driver, which seems to be "waiting for something" awakes.

一个boost::asio::socket, 在不同的线程，写，不加互斥，是不安全的。
The only way to protect you from hitting this case is to build your program to avoid situations like this.

One way to do that is by writing an application layer send buffer 
which a single thread is responsible for pushing onto the socket. 
That way you could protect the send buffer itself only. 
Keep in mind though that a simple std::vector won't work, 
since adding bytes to the end may end up re-allocating it, 
possibly while there is an outstanding async_write_some() referencing it. 
Instead, it's probably a good idea to use a linked list of buffers, a
nd make use of the scatter/gather feature of asio.

write and async_write are not thread safe in the manner you are using them. 
The canonical way to approach this is to queue your messages, then write them out one at a time.

Tip::tcp::socket  hread Safety
Distinct objects: Safe.
Shared objects: Unsafe.

boost::socket对象在工作线程中同步读写的情况，在另一线程里关闭？没有常规的办法。
Thread-safely closing a boost::asio::ip::tcp::socket being used synchronously
异步读写的情况下，可以先cancel
If your acceptor is in async_accept, you can call ip::tcp::acceptor::cancel() to cancel any async operations on it. 
试验结果，虽然cancel了，还是会接收到数据（m_serial_port.cancel  m_serial_port.close 那个会再引导异步I/O操作？）

Cancel is useful if you want to stop pending operations without closing down the socket.
Note that the Boost documentation recommends using close for greater portability (from doc page):
... For portable cancellation, consider using one of the following alternatives:
Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.
Use the close() function to simultaneously cancel the outstanding operations and close the socket.

Note however the remarks for cancel() also state When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. 
This function does not have the problems described above. 
C  Sam Miller Jun 22 '11 at 15:33 
thank you and Sam Miller for help,i understand a little now,thank you

cancel won't close the socket, so use cancel if you intend to continue using the socket object. In particular, if you have code in asynchronous handler methods that references the socket's member functions, you may not want to close the socket until you are guaranteed that your currently executing asynchronous handlers have completed.

cancel doesn't guarantee anything about currently executing asynchronous handlers, it only guarantees (per the boost documentation) that "This function causes all outstanding asynchronous connect, send and receive operations to finish immediately" in the case of the socket::cancel() call, or "This function forces the completion of any pending asynchronous operations on the host resolver" in the case of the resolver::cancel() call. This "completion" means that boost will call your asynchronous handler method, it has no jurisdiction to inject any cancellation logic into your asynchronous handler (not to mention it doesn't know about the handler's implementation to begin with).

I would suggest adding your own logic into your asynchronous handler method to handle the case where the socket/resolver/etc. is canceled. If you are calling the cancel method, then you likely have the ability to communicate this cancellation to the asynchronous handler method.

basic_serial_port::close (1 of 2 overloads)

Close the serial port.

void close();  根据下面的解释，Close前没有必要调用cancel
This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.







---------------------------------------------------------------------------
【结构体的序列化】
http://stackoverflow.com/questions/3938307/serializing-c-style-structs-using-c
Doing a memcpy of classes/structs is okay if they're just Plain Old Data (POD), but if that's the case, then you could rely on C++ doing the copying for you via copy constructors (which exist for bothstruct and class types in C++).
Certainly you can do it the way you have been doing it - one of the products I've worked on serializes data using memcpy, sends the data over the wire, and client applications decode the bytestream to get the data back.
But if you have a choice, you might want something higher level like boost.serialization, which offers more flexibility and deep-pointer copying. The aforementioned Google ProtoBuffers would work nicely too.
Here are some threads discussing serialization methods in C++:
boost serialization vs google protocol buffers?
C++ Serialization Performance
http://stackoverflow.com/questions/1061169/boost-serialization-vs-google-protocol-buffers
Boost Serialisation
is a library for writing data into a stream.
does not compress data.
does not support data versioning automatically.
supports STL containers.
properties of data written depend on streams chosen (e.g. endian, compressed).
Protocol Buffers
generates code from interface description (supports C++, Python and Java by default. C, C# and others by 3rd party).
optionally compresses data.
handles data versioning automatically.
handles endian swapping between platforms.
does not support STL containers.
Boost serialisation is a library for converting an object into a serialised stream of data. Protocol Buffers do the same thing, but also do other work for you (like versioning and endian swapping). Boost serialisation is simpler for "small simple tasks". Protocol Buffers are probably better for "larger infrastructure".
http://stackoverflow.com/questions/321619/c-serialization-performance
I'm building a distributed C++ application that needs to do lots of serialization and deserialization of simple data structures that's being passed between different processes and computers.
http://baike.baidu.com/view/1708160.htm
Protocol Buffers是Google公司开发的一种数据描述语言，
类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。
它不依赖于语言和平台并且可扩展性极强。
现阶段官方支持C++、JAVA、Python等三种编程语言，但可以找到大量的几乎涵盖所有语言的第三方拓展包
Protocol Buffers经常被简称为protobuf
Protocol Buffers在谷歌被广泛用于各种结构化信息存储和交换。
Protocol Buffers作为一个自定义的远程过程调用（RPC）系统，
用于在谷歌几乎所有的设备间的通信
每一个protocol buffer 信息都是一小段结构，包含了一些名字。
下面是一个.proto 文件内容的样例。
[pre]message Point { required int32 x = 1; required int32 y = 2; optional string label = 3;} message Line { required Point start = 1; required Point end = 2; optional string label = 3;} message Polyline { repeated Point point = 1; optional string label = 2;}
http://www.parashift.com/c++-faq-lite/serialize-text-format.html
序列化的过程，是把结构体，改成一个字符串，再由对方解析出。
http://www.ocoudert.com/blog/2011/07/09/a-practical-guide-to-c-serialization/


【archive-xml-iarchive.png】
http://stackoverflow.com/questions/652193/serialize-and-send-a-data-structure-using-boost
std::ostringstream archive_stream;
boost::archive::text_oarchive archive(archive_stream);
archive << your_struct;
outbound_data_ = archive_stream.str();
boost::asio::async_write(socket_, 
   boost::asio::buffer(outbound_data_), handler);
http://www.boost.org/doc/libs/1_38_0/doc/html/boost_asio/example/serialization/server.cpp
http://stackoverflow.com/questions/15251415/exception-when-using-boostserialization-with-boostasio


序列化
http://en.wikipedia.org/wiki/Serialization
http://stackoverflow.com/questions/652193/serialize-and-send-a-data-structure-using-boost
http://stackoverflow.com/questions/523872/how-do-you-serialize-an-object-in-c
http://www.boost.org/doc/libs/1_54_0/libs/serialization/doc/index.html
serialization   序列化
将任意一组C++数据结构解构为一串字节的、可逆的过程
把类的对象  序列化  保存到文件里，
从文件里读出 序列化数据，加载成类对象
void save_schedule(const bus_schedule &s, const char * filename){
   // make an archive
   std::ofstream ofs(filename);
   boost::archive::text_oarchive oa(ofs);
   oa << s;
}

void
restore_schedule(bus_schedule &s, const char * filename)
{
   // open the archive
   std::ifstream ifs(filename);
   boost::archive::text_iarchive ia(ifs);

   // restore the schedule from the archive
   ia >> s;
}
 we have used a particular archive class - text_oarchive for saving and text_iarchive for loading

The binary_oarchive and binary_iarchive classes are implemented in terms of the more basicstd::streambuf

---------------------------------------------------------------------------
【bitset】【bitset-1.png】【bitset-2.png】
#include <iostream> 
#include <bitset> 
int main()  
{  
    std::bitset<8> bs(8);  
    std::cout << "输出所有binary bit: " << bs << std::endl;  
    std::cout << "bitset - any() 是否存在置为1的bit: " << std::boolalpha << bs.any() << std::noboolalpha << std::endl;  
    std::cout << "bitset - none() 是否不存在置为 1 的bit: " << bs.none() << std::endl;  
    std::cout << "bitset - count() bit为 1 的个数: " << bs.count() << std::endl;  
    std::cout << "bitset - size() bit的个数: " << bs.size() << std::endl;  
    bs.flip();  
    std::cout << "bitset - flip() 把所有bit逐位取反 后: " << bs << std::endl;  
    bs.flip(0);  
    std::cout << "bitset - flip(size_t pos) 把在pos(zero-based)处的bit 按位取反 后: " << bs << std::endl;  
    std::cout << "bitset - [] 使用[]操作符访问pos处的bit: " << bs[0] << std::endl;  
    bs.set();  
    std::cout << "bitset - set() 把所有的bit都置为1: " << bs << std::endl;  
    bs.set(0);  
    std::cout << "bitset - set(size_t pos) 把pos处的bit置为1: " << bs << std::endl;  
    std::cout << "bitset - test(size_t pos) 测试pos处的bit是否为1: " << std::boolalpha << bs.test(0) << std::noboolalpha << std::endl;  
    std::cout << "bitset - to_ulong() 返回一个unsigned long值: " << bs.to_ulong() << std::endl;  
    std::cout << "bitset - to_string() 返回一个std::string值: " << bs.to_string() << std::endl;  
    return 0;  
}



std::bitset

 
C++
 
Utilities library
 
std::bitset
 
Defined in header <bitset>
template< std::size_t N >
class bitset;
The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers.

---------------------------------------------------------------------------

最好的JSON解析器
http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
JsonCpp (http://jsoncpp.sourceforge.net/)
json_spirit::write( root, json_spirit::pretty_print );

I'm using JSON Spirit on a project at the moment, I'm impressed with it so far.
Note that it does rely on Boost (if only for headers).
Handy features:
Has Unicode support.
Uses std::vector to hold Arrays which helps interoperability.
Provides a pretty print function (write_formatted).
Has read and write functions for strings and streams.
Note that Objects are also implemented using vector (not map), which means slower access, but it does mean that the order of elements is maintained.

Boost property_tree does not fully support all type information. 
From the documentation: JSON values are mapped to nodes containing the value. 
However, all type information is lost; numbers, as well as the literals "null", "true" and "false" 
are simply mapped to their string form

Packet injection(注入)
By utilizing raw sockets, NDIS function calls, or direct access to a network adapter kernel mode driver, arbitrary packets can be constructed and injected into a computer network. These arbitrary packets can be constructed from any type of packet protocol (ICMP, TCP, UDP, and others) since there is full control over the packet header while the packet is being assembled

The basic service set (BSS) provides the basic building-block of an 802.11 wireless LAN.
Each BSS or ESS is identified by a service set identifier (SSID) - a 1 to 32 byte string

An extended service set (ESS) is a set of two or more interconnected wireless BSSs that share the same SSID (network name), 
security credentials and integrated (providing translation between 802.3 and 802.11 frames) wired local area networks that appear 
as a single BSS to the logical link control layer at any station associated with one of those BSSs 
which facilitates mobile IP and fast secure roaming applications; 
the BSSs may work on the same channel, or work on different channels to boost aggregate throughput.



---------------------------------------------------------------------------
boost::system::error_code 的类型判断
void SerialPort::on_receive_(const boost::system::error_code& ec, size_t bytes_transferred)
{
	try {
		//boost::mutex::scoped_lock lock( m_mutex );
		
		if( ec ) {                                          判断这个ERROR是否是，国为串已经关闭
			// 如果出错了，直接读下次的
			m_port.async_read_some( boost::asio::buffer( m_read_buf_raw, SERIAL_PORT_READ_BUF_SIZE), 
				boost::bind( &SerialPort::on_receive_, this, 
					boost::asio::placeholders::error, 
					boost::asio::placeholders::bytes_transferred ) );
			return;
		}

可以确认：如果需要关闭后，重新打开同一个串口，最好的方法是，用新串口对象及新io_service对象.

	if(m_port) m_port.reset(); //在对应的服务重置前，先把旧的串口对象删除了（因为删除析构的时候，需要用到io_service）
	m_io_service.reset(new boost::asio::io_service());
	m_port.reset(new boost::asio::serial_port(*m_io_service));

		//FIX：下面这个顺序是否有问题？  不正确，这样串口仍补占用，未关闭. 先调用m_port->close()再关闭服务就可以了。
		if(m_io_service) m_io_service->stop();
		if(m_io_service_thread) m_io_service_thread->join();
		if(m_port) m_port->close();


m_io_service.reset(new boost::asio::io_service);
new boost::asio::io_service 后面需要添加括号吗？

最近需要x取及DQUSB devices的模式，用到SetupDi****相P的API，@些API都是放在setupapi.he，找了很久，在W路上也有人提到，但都是片面的，也都分散在不同的地方，F在我就⑵湔合放在我自己的Bloge，@酉麓我用也不忘。@一MAPI是Microsoft PlatformSDK提供的，路揭苍VSe

// Open a handle to the serial port.
  ::HANDLE handle = ::CreateFileA(name.c_str(),
      GENERIC_READ | GENERIC_WRITE, 0, 0,
      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
  if (handle == INVALID_HANDLE_VALUE)
  {
    DWORD last_error = ::GetLastError();
    ec = boost::system::error_code(last_error,
        boost::asio::error::get_system_category());
    return ec;
  }
  
  	if(m_port) {
		m_port->stop();
		//m_port.reset();
	}
	m_service.stop();    先停止了SERVICE,再调用串口对象的关闭函数,关闭是无效的。
	if(m_comrev_thread) m_comrev_thread->join();
	
SerialPort 对象重新打开，最好的方法，是创建新的对象。同时其对应的SERVICE也需要，创建新的对象。




---------------------------------------------------------------------------

通用唯一识别码（英语：Universally Unique Identifier，简称UUID）是一种软件建构的标准，亦为自由软件基金会组织在分散式计算环境领域的一部份。
UUID的目的，是让分散式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定
一组UUID，是由一串16位组（亦称128位）的16进位数字所构成，是故UUID理论上的总数为216 x 8=2128，约等于3.4 x 1038。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完
UUID的标准型式包含32个16进位数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例：
550e8400-e29b-41d4-a716-446655440000





---------------------------------------------------------------------------
【boost::iostream】http://stackoverflow.com/questions/4961155/boostiostream-zlib-compressing-multiple-files-into-one-archive
boost::iostream zlib compressing multiple files into one archive
The zlib Filters depend on the third-party zlib library, which is not included in the Boost distribution. Prebuilt zlib binaries are available on most UNIX and UNIX-like systems, and will be found automatically by the Boost build system. Windows users can obtain prebuilt binaries at the zlib homepage. Users can also configure the Boost Iostream library to build zlib from the source code, which is available at the zlib homepage. For details on configuring the build system to find your zlib installation, please see Installation
---------------------------------------------------------------------------
【chrono】
boost::this_thread::sleep_for(boost::chrono::milliseconds(500));
误写成了
boost::this_thread::sleep_for(boost::chrono::microseconds(500));
导致线程，占用过多CPU。       



---------------------------------------------------------------------------
【date_time】
boost ptime
http://remonstrate.wordpress.com/2011/07/03/boost-%E7%9A%84-date_time/

ptime -> utc 一个整数
ptime -> string

boost::gregorian::to_iso_wstring( time_.date() );
boost::posix_time::to_iso_wstring( iter->time() )

boost::date_time 的时间 -> 字符串的转换
                 字符串 -> 时间的转换

		CPositionData tmp(x, y, boost::posix_time::ptime::is_not_a_date_time); 这句话是错的，为什么？ 
		CPositionData tmp(x, y, boost::posix_time::not_a_date_time); 这个是正确的

时间点构造
tmp.time = boost::posix_time::microsec_clock::local_time();
ptime d3(not_a_date_time);

时长构造
tmp.duration = tmp.time - tmp.time;  构造时间段  tmp.duration = boost::posix_time::time_duration(0, 0, 0, 0);

using namespace boost::posix_time;
time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds

using namespace boost::posix_time;      
time_duration td = hours(1) + seconds(10); //01:00:01
td = hours(1) + nanoseconds(5); //01:00:00.000000005

Syntax	Description
Example
time_duration(hours,
              minutes,
              seconds,
              fractional_seconds)
Construct a duration from the counts. The fractional_second parameter is a number of units and is therefore affected by the resolution the application is compiled with (see Build-Compiler Information). If the fractional_seconds argument exceeds the limit of the compiled precision, the excess value will be "carried over" into the seconds field. See above for techniques to creating a resolution independent count.
time_duration td(1,2,3,9);
//1 hr 2 min 3 sec 9 nanoseconds
time_duration td2(1,2,3,123456789);
time_duration td3(1,2,3,1000);
// with microsecond resolution (6 digits)
// td2 => "01:04:06.456789"
// td3 => "01:02:03.001000"
// with nanosecond resolution (9 digits)
// td2 => "01:02:03.123456789"
// td3 => "01:02:03.000001000"
time_duration(special_value sv)
Special values constructor. Important note: When a time_duration is a special value, either by construction or other means, the following accessor functions will give unpredictable results:
hours(), minutes(), seconds(), ticks(), 
fractional_seconds(), total_nanoseconds(),
total_microseconds(), total_milliseconds(),
total_seconds()
The remaining accessor functions will work as expected.

std::string to_simple_string(time_duration)
To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.
10:00:01.123456789
std::string to_iso_string(time_duration)
Convert to form HHMMSS,fffffffff.
100001,123456789

time_duration td(1,2,3, 1000);
td.fractional_seconds(); // --> 1000

posix time  字符串时间格式
simple_string                  2012-12-12 10:12:22
iso_string                        20121212T101222
to_iso_extended_string
 //! Allows expression of durations as milli seconds
  /*! \ingroup time_basics
   */
  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;
  //! Allows expression of durations as micro seconds
  /*! \ingroup time_basics
   */
  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
注意其中的断续关系
 class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };



boost::local_time::time_zone_ptr tz( new boost::local_time::posix_time_zone( "MST+07" ) );
boost::local_time::local_date_time ltm = boost::local_time::local_sec_clock::local_time( tz);
会获取指定时区的 正确的当前时间。
http://stackoverflow.com/questions/6730422/boost-chrono-vs-boost-date-time
Boost.Chrono seems focused on dealing with time intervals[间隔时间 ['?ntevl]

]. 不关心，日期（大于小时的时间单位）。
http://en.cppreference.com/w/cpp/chrono  c++11 std::chrono 实现
时间区段  boost posix_time time_period 对象的，contains，方法：
如果是结束点，则返回FALSE
A period that is created with beginning and end points being equal, or with a duration of zero, is known as a zero length period. Zero length periods are considered invalid (it is perfectly legal to construct an invalid period). For these periods, the last point will always be one unit less that the begin point
指定的结束点，实际结束点，比指定结束时间点，小一个 time_count ()

bool contains(ptime)
True if ptime is within the period. Zero length periods cannot contain any points.
date d(2002,Jan,01);
ptime t1(d, seconds(10)); //10 sec after midnight
ptime t2(d, hours(10)); //10 hours after midnight
ptime t3(d, hours(2)); //2 hours after midnight
time_period tp(t1, t2); 
tp.contains(t3); // true
time_period tp2(t1, t1);
tp2.contains(t1); // false


---------------------------------------------------------------------------

[filesystem]

#include <boost/filesystem.hpp>
std::string filename_noext;
filename_noext = boost::filesystem::path("D:\\files\\file.lua").stem().string().
const char* result_as_const_char = filename_noext.c_str();

获取当前进程的EXE文件所在路径。
http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
Some OS-specific interfaces:

Mac OS X: _NSGetExecutablePath() (man 3 dyld)
Linux: readlink /proc/self/exe
Solaris: getexecname()
FreeBSD: sysctl CTL_KERN KERN_PROC KERN_PROC_PATHNAME -1
FreeBSD if it has procfs: readlink /proc/curproc/file (FreeBSD doesn't have procfs by default)
NetBSD: readlink /proc/curproc/exe
DragonFly BSD: readlink /proc/curproc/file
Windows: GetModuleFileName() with hModule = NULL

To summarize:

On Unixes with /proc really straight and realiable way is to:

readlink("/proc/self/exe", buf, bufsize) (Linux)

readlink("/proc/curproc/file", buf, bufsize) (FreeBSD)

readlink("/proc/self/path/a.out", buf, bufsize) (Solaris)

On Unixes without /proc (i.e. if above fails):

If argv[0] starts with "/" (absolute path) this is the path.

Otherwise if argv[0] contains "/" (relative path) append it to cwd (assuming it hasn't been changed yet).

Otherwise search directories in $PATH for executable argv[0].

Afterwards it may be reasonable to check whether the executable isn't actually a symlink. If it is resolve it relative to the symlink directory.

This step is not necessary in /proc method (at least for Linux). There the proc symlink points directly to executable.

Note that it is up to the calling process to set argv[0] correctly. It is right most of the times however there are occasions when the calling process cannot be trusted (ex. setuid executable).

On Windows: use GetModuleFileName(NULL, buf, bufsize)

boost 提出EXE当前路径
boost 从文件路径里提出 文件名，及路径

filesystem::path 类的成员
// decomposition 分解
        path  root_name() const;
        path  root_directory() const;
        path  root_path() const;
        path  relative_path() const;
        path  parent_path() const;
        path  filename() const;
        path  stem() const;
        path  extension() const;
		
 // query
        bool empty() const;
        bool has_root_name() const;
        bool has_root_directory() const;
        bool has_root_path() const;
        bool has_relative_path() const;
        bool has_parent_path() const;
        bool has_filename() const;
        bool has_stem() const;
        bool has_extension() const;
        bool is_absolute() const;
        bool is_relative() const;

		
// modifiers
        void  clear();
        path& make_absolute(const path& base);
        path& make_preferred();  // ISO/IEC 9945: no effect. Windows: convert slashes to backslashes
        path& remove_filename();
        path& replace_extension(const path& new_extension = path());
        void  swap(path& rhs);


boost filesystem
常用函数 :
path p (argv[1]);
exists(p)
is_regular_file(p)
is_directory(p)
可以复制文件，文件夹，快捷方式
可以创建，删除：文件，文件夹
directory_iterator

explicit directory_iterator(const path& p);
directory_iterator() noexcept;  // creates the "end" iterator   唯一合法的，结束条件
recursive_directory_iterator  递归，所有子文件夹


在Windows平台下我们知道可以使用API函数GetModuleFileName来获取应用程序的路径。最近发现boost库也可以实现这个功能
http://blog.csdn.net/clever101/article/details/5822296
string fullpath = boost::filesystem::initial_path<boost::filesystem::path>().string();
boost::filesystem::initial_path Returns: current_path() as of the first call to initial_path()
boost::filesystem::current_path (获取的是当前(工作)路径)
The current path as returned by many operating systems is a dangerous global variable. It may be changed unexpectedly by a third-party or system library functions, or by another thread
http://stackoverflow.com/questions/1528298/get-path-of-executable
There is no cross platform way that I know. (没有跨平台的方法，用于获取程序所在路径)
For Linux: readlink /proc/self/exe
Windows: GetModuleFileName
http://stackoverflow.com/questions/5694190/boostfile-system-how-to-find-out-in-which-directory-your-executable-is
Do you mean the current working directory (en.wikipedia.org/wiki/Working_directory), or the actual directory where the executable lives?
However if you're on windows you can call GetModuleFileName to get the complete path of the executable and then use boost::filesystem to get the directory. ( see parent_path)
http://stackoverflow.com/questions/933850/how-to-find-the-location-of-the-executable-in-c
GetModuleFileName
第一个参数 _In_opt_  HMODULE hModule,
If this parameter is NULL,GetModuleFileName retrieves the path of the executable file of the current process
This function is useful for input idle detection.
BOOL WINAPI GetLastInputInfo(
 _Out_  PLASTINPUTINFO plii
);
typedef struct tagLASTINPUTINFO {
 UINT  cbSize;
 DWORD dwTime;  The tick count when the last input event was received.
                 DWORD WINAPI GetTickCount(void);

} LASTINPUTINFO, *PLASTINPUTINFO;



filesystem - Portable paths, iteration over directories, and other useful filesystem operations, from Beman Dawes
文件创建，复制，删除；文件夹创建删除等等操作。

---------------------------------------------------------------------------
【字符串转换】
UTF8 <-> UNICODE
Class template std::wstring_convert performs conversions between byte string std::string and wide string std::basic_string<Elem>, 
using an individual code conversion facet Codecvt. 
std::wstring_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. 
The standard facets suitable for use with std::wstring_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions

void test()
{
wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
string s8 = u8"This is a UTF8 string";
wstring s16 = converter.from_bytes(s8);
string s88 = converter.to_bytes(s16);
if (s8!=s88)
cerr <"Insane!\n";
}

string <-> number
to_string





---------------------------------------------------------------------------
【LOG】
<boost/log/utility/manipulators/dump.hpp>
dump binary data

http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/log/detailed/utilities.html
void on_receive(std::vector< unsigned char > const& packet)
{
   // Outputs something like "Packet received: 00 01 02 03 04 05 06 07 and 67 bytes more"
   BOOST_LOG(lg) << "Packet received: " << logging::dump(packet.data(), packet.size(), 8);
}
void process(std::vector< double > const& matrix)
{
   // Note that dump_elements accepts the number of elements in the matrix, not its size in bytes
   BOOST_LOG(lg) << "Matrix dump: " << logging::dump_elements(matrix.data(), matrix.size());
}

boost.log 全局类

            // In pure C++ this should never happen, since there cannot be two
            // different tag types that have equal type_infos. In real life it can
            // happen if the same-named tag is defined differently in two or more
            // dlls. This check is intended to detect such ODR violations. However, there
            // is no protection against different definitions of the logger type itself.
            throw_odr_violation(typeid(TagT), typeid(logger_type), *holder);
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT( log, boost::log::sources::logger_mt );
定义了一个结构体：log 是结构体的TAG名称。并不是简单的定义一个全局对象。
log::get 会创建一个LOGGER对象。这个对象是全局的。::get函数内部实现的线程的同步操作。
这个宏的定义里，学习type_info类型。
#include <boost/log/common.hpp>
#include <boost/log/sources/logger.hpp>
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT( log, boost::log::sources::logger_mt );

D:\project\3rdParty\boost_1_54_0\libs\log\example

BOOST的例子

http://www.csdn123.com/html/itweb/20130912/114957_114950_114945.htm
http://blog.csdn.net/karl_max/article/details/4972664
boost log 学习
和boost的其他类库一样，充分的发挥了C++的各种高级用法，命名参数、lamba表达式、函数编程。结果就是一大堆还不算太旧的编译器都无法编译，例如：MSVC 7.0 and older，GCC 4.0 and older。对其他库的依赖也很厉害，需要Boost.Filesystem, Boost.System, Boost.DateTime, Boost.Thread  and Boost.Regex，用户代码还必须启用RTTI
---------------------------------------------------------------------------
[线程]

线程同步：
互斥体的类型  锁的类型
        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;

boost condition(创建，销毁，发送信号，等待锁+条件) 、 mutex+lock , 

Differences between <semaphore.h> and <sys/sem.h>
<sys/sem.h> provides the interface for XSI (originally Unix System V) semaphores.
<semaphore.h> defines POSIX semaphores, which are designed in such a way that they can be implemented entirely in userspace, except in the contended case where the process will call into the kernel to go to sleep. 

信号量（英语：Semaphore）又称为号志，它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待（busy waiting）的一种方法。
信号量的概念是由荷兰计算机科学家艾兹格・迪杰斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。

计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。
运作方式：
初始化，给与它一个非负数的整数值。
运行 P（wait()），信号量S的值将被减少。企图进入临界区段的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区段。
运行 V（又称signal()），信号量S的值会被增加。退出离开临界区段的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。


多线程同步方式
http://www.boost.org/doc/libs/1_54_0/doc/html/thread/synchronization.html#thread.synchronization.barriers

A barrier is a simple concept. Also known as a rendezvous, it is a synchronization point between multiple threads. The barrier is configured for a particular number of threads (n), and as threads reach the barrier they must wait until all n threads have arrived. Once the n-th thread has reached the barrier, all the waiting threads can proceed, and the barrier is reset

---------------------------------------------------------------------------

散列函数 -> 冗余检校验 -> 校验和 -> 循环冗余校验（CRC）
循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据数据包或电脑文件等数据产生简短固定位数校验码的一种散列函担主要用来检测或校验数据传输或者保存后可能出现的错误
生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化
一般来说，循环冗余校验的值都是32位的整数
它是由W. Wesley Peterson在他1961年发表的论文中披露
校验和（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或者时间（如计算机存储）传送的数据的完整性进行检查的一种简单方法。
计算机领域常见的校验和的方法有循环冗余校验（CRC）、MD5、SHA家族等
在通信领域中，冗余校验是消息中附加的用于错误检测与错误校正的数据。
任何一个散列函数都可以用于冗余检校验。最简单的冗余校验，叫作校验和，它包括校验位、校验码以及纵向冗余校验（LRC，en:longitudinal redundancy check）。其它类型的冗余校验包括循环冗余校验（CRC，cyclic redundancy check）、水平冗余校验、竖直冗余校验以及en:cryptographic message digest。
奇偶校验仅仅是一个错误检测的机制，根据所用奇校验与偶校验的不同可以检查偶数或者奇数的错误
奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数还是偶数的二进制数。奇偶校验位是最简单的错误检测码


 
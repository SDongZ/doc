【BOOST编译】
b2 toolset=msvc-10.0 --with-iostreams
b2.exe --show-libraries
b2.exe --with-<library>

---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
---------------------------------------------------------------------------
【boost asio 缓存集】
发送多个缓存
                boost::array<boost::asio::const_buffer, 2> bufs;
                bufs[0] = boost::asio::buffer(&id_, sizeof(id_));
                bufs[1] = boost::asio::buffer(this, sizeof(this));
                socket.send_to(bufs, remote);
接收时，就需要有几个缓存
                boost::array<boost::asio::mutable_buffer, 2> bufs = {
                        boost::asio::buffer(&id, sizeof(id)),
                        boost::asio::buffer(buffer)    这个BUFFER 是怎么定义的？
                };
                size_t rcv_size = socket_.receive_from(bufs, remote_endpoint);
---------------------------------------------------------------------------
通过咨询某个做过IM的同事，参考答案应该是，自己实现的心跳机制通用，可以无视底层的UDP或TCP协议。如果只是用TCP协议的话，那么直接使用KeepAlive机制就足够
---------------------------------------------------------------------------
把整数，转换成带千分号的字符串。
1. 整数格式化成字符串
2. 插入千分号。
std::string InsertSeparator (DWORD dwNumber) {
        boost::format fmt("%d");
        fmt % dwNumber;
        std::string str = fmt.str();
        for (int i = str.length() - 3; i > 0; i -= 3) {
                str.insert(i, ",");
        }
        return (str);
}

boost::fomat
format_fwd.hpp contains this typedef:
typedef basic_format<wchar_t >  wformat;
I think this will get you started. This works here:
std::wcout << boost::wformat(L"...") % ...
Also the boost::str works using wformat.
wstring s = boost::str(boost::format(L"...") % ...)
wcout << boost::format(L"...") % …

boost::fomat
format_fwd.hpp contains this typedef:
typedef basic_format<wchar_t >  wformat;
I think this will get you started. This works here:
std::wcout << boost::wformat(L"...") % ...
Also the boost::str works using wformat.
wstring s = boost::str(boost::format(L"...") % ...)
wcout << boost::format(L"...") % …
char t = 0xaa;  ( 0xaa 作为整形常量存在 常量区中, 常量后缀 )
warning C4309: “初始化”: 截断常量值  解决方法  char t = char( 0xaa );
        char t = 0xaa;
        printf( "%02X", t );
输出结果是：        FFFFFFAA, 原因是 printf 做了类型转换，把 char t 转成了 int
http://stackoverflow.com/questions/3959674/printf-too-smart-casting-from-char-to-int
Anything you pass to printf (except the first parameter) undergoes "default promotions", which means (among other things) that char and short are both promoted to int before being passed. So, even if what you were passing really did have type char, by the time it got to printf it would have typeint. In your case, you're using a character literal, which already has type int anyway.
The same is true with scanf, and other functions that take variadic parameters
char buffer[4] = { char(0xaa), char(0x40), char(0x01), char(0x01) };
const char *buf
std::string tmp = boost::str( boost::format( "%d" ) % buf[i] );
奇怪的事情发生了：
这里tmp 得到的值 是 0xaa, 不是字符串，而是一个值，像直接赋值一样
下面 是可以正常格式化的  (问题出在 buf[i] 上)
std::string tmp = boost::str( boost::format( "%d" ) % 0xaa );
std::string tmp = boost::str( boost::format( "%02X" ) % 0xa );
%02X 期待得到一个整型
而我们传给它一个 char， 但是boost未做类型转换
奇怪的结果，真不知道，怎么理解了。  tmp 字符串有两个字节，
0x30(是补的零) 0x0a(保持原值)
                                char t = 0xa;    // 转成 unsigned int 就正常了
                                std::string tmp = boost::str( boost::format( "%02X" ) % t );
char 不可以正常转换，与  格式化器（ formatter string ）有关？  
%02X 期待得到一个整型
而我们传给它一个 char
format formatter("%+5d");
cout << formatter % x;
unsigned int n = formatter.size();
另一个奇怪的问题 ( 有符号字符，无符号字符，转成整型时，会得到不同的值)
char buffer3[4] = { char(0xaa), char(0x40), char(0x01), char(0x01) };
unsigned int t = buffer3[i];   // 这里的 t 得到的值 是 0xffffffaa
char buffer3[4] = { char(0xaa), char(0x40), char(0x01), char(0x01) };
unsigned int t = unsigned char(buffer3[1]);
                        
unsigned int t = buffer3[0];
t = buffer3[1];                  // 0x40
t = buffer3[2];                  // 0x01
unsigned int t = *buffer3;  也是 0xffffffaa
unsigned int t = char( 0xaa );   也是0xffffffaa
unsigned int t = unsigned char(0xaa);  是 0x000000aa
unsigned int t = 0xaa;   是 0x000000aa
http://stackoverflow.com/questions/9923949/boostformat-form-c-string-or-stdstring
---------------------------------------------------------------------------
#include <boost/timer.hpp>
timer类可以测量时间的流逝，是一个小型的计时器，提供毫秒级别的计时精度和操作函数
timer();            // 构造函数，计时开始 
void restart();            // 计时重新开始 
double elapsed();        // 已经流逝的时间(秒) 
double elapsed_min(); // 可度量的最小时间(秒)，Win32平台精确度最小能够达到毫秒，Linux精确到微秒。   double elapsed_max();        // 可度量的最大时间(秒)
---------------------------------------------------------------------------
BOOST::BIND  产生两种函数对象。？  
但是回调时，（定义的回调函数），只传递占位符指定的参数。
占位符，指定了，参数，在回调时的顺序。_1, _2

传参数的，如：boost::thread 接受的函数对象
传占位符的，如: boost::single2 接受的函数对象
---------------------------------------------------------------------------
#include <boost/program_options.hpp>
boost::program_options （命名空间）
options_description desc("Allowed options")
desc.add_options()
            ("help", "produce help message")
            ("compression", value<double>(), "set compression level")
        ;
//示例：value
//value< vector<string> >()
//value<int>(&opt)->default_value(10)   变量地址(&opt)  /  缺省值 10
//("include-path,I", po::value< vector<string> >(),   两个参数  "--include-path" 和 "-I" 两者都可以使用
//调用 store, parse_command_line 和 notify 函数，使得 vm 保存了命令行中发现的所有选项
variables_map vm;
store(parse_command_line(ac, av, desc), vm);
notify(vm);  
//调用
vm["compression"].as<int>()
xx.exe --xml cccc -psw 888
//示例代码
                boost::program_options::options_description des("输入选项");
                des.add_options()("xml", boost::program_options::value<std::string>(), "指定要修改的XML")
                                                 ("psw", boost::program_options::value<std::string>(), "指定的密码");
                boost::program_options::variables_map vm;
                boost::program_options::store(boost::program_options::parse_command_line(argc, argv, des), vm);
                boost::program_options::notify(vm);
                std::cout << vm["xml"].as<std::string>() << "\n" << vm["psw"].as<std::string>();
---------------------------------------------------------------------------
extern std::vector<float> get_vector_float();
BOOST_FOREACH( float f, get_vector_float() )
{
   // 注: get_vector_float() 只会被调用一次
}

反序循环迭代
std::list<int> list_int( /*...*/ );
BOOST_REVERSE_FOREACH( int i, list_int )
{
   // 用 i 来做一些操作
}
---------------------------------------------------------------------------
boost库命名规则

libboost_regex-vc71-mt-d-1_34.lib
lib
Prefix: except on Microsoft Windows, every Boost library name begins with this string. On Windows, only ordinary static libraries use the lib prefix; import libraries and DLLs do not.6
boost_regex
Library name: all boost library filenames begin with boost_.
-vc71
Toolset tag: identifies the toolset and version used to build the binary.
-mt
Threading tag: indicates that the library was built with multithreading support enabled. Libraries built without multithreading support can be identified by the absence of -mt.
-d
ABI tag: encodes details that affect the library's interoperability with other compiled code. For each such feature, a single letter is added to the tag:
Key
Use this library when:
Boost.Build option
s
linking statically to the C++ standard library and compiler runtime support libraries.
runtime-link=static
g
using debug versions of the standard and runtime support libraries.
runtime-debugging=on
y
using a special debug build of Python.
python-debugging=on
d
building a debug version of your code.7
variant=debug
p
using the STLPort standard library rather than the default one supplied with your compiler.
stdlib=stlport
For example, if you build a debug version of your code for use with debug versions of the static runtime library and the STLPort standard library in “native iostreams” mode, the tag would be:-sgdpn. If none of the above apply, the ABI tag is ommitted.
-1_34
Version tag: the full Boost release number, with periods replaced by underscores. For example, version 1.31.1 would be tagged as "-1_31_1".
.lib
Extension: determined according to the operating system's usual convention. On most unix-style platforms the extensions are .a and .so for static libraries (archives) and shared libraries, respectively. On Windows, .dll indicates a shared library and .lib indicates a static or import library. Where supported by toolsets on unix variants, a full version extension is added (e.g. ".so.1.34") and a symbolic link to the library file, named without the trailing version number, will also be created.
---------------------------------------------------------------------------
LISTENING状态   FTP服务启动后首先处于侦听（LISTENING）状态。
ESTABLISHED的意思是建立连接。表示两台机器正在通信
CLOSE_WAIT
        对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭
4、TIME_WAIT
    我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。
        目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。
5、SYN_SENT状态
   SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因
---------------------------------------------------------------------------
boost format
boost::format("This is a string with some %s and %d numbers") %"strings" %42
返回值是什么？
---------------------------------------------------------------------------
 Boost.Process
http://lists.boost.org/Archives/boost/2010/10/171690.php
http://www.crystalclearsoftware.com/cgi-bin/boost_wiki/wiki.pl?BoostProcess/ExistingLibraries
http://svn.boost.org/svn/boost/sandbox/process/libs/process/
http://pocoproject.org/docs/Poco.Process.html#9431
http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html

---------------------------------------------------------------------------
boost/lexical_cast.hpp

#include <boost/lexical_cast.hpp>
std::wstring tm = boost::lexical_cast<std::wstring>( m_mgr.duration() / 1000 );
include <boost/numeric/conversion/cast.hpp>
安装的数字类型转换（int转成short）
由于缺乏对范围的保护，所以数字类型间的转换很容易出错。这对于隐式转换和显式转换(通过 static_cast) 都是一样的。 numeric_cast 可以在转换一个数字类型时检查范围的损失，如果范围不能被保持就抛出一个异常
short s=numeric_cast<short>(i);
---------------------------------------------------------------------------
和函数及函数指针一起使用 bind

// 线程   boost bind绑定其它类的成员函数
boost::thread t(boost::bind(&boost::asio::io_service::run, &io_service_));
int f(int a, int b)
{
   return a + b;
}

int g(int a, int b, int c)
{
   return a + b + c;
}
bind(f, 1, 2) 会产生一个“无元”函数对象，它（函数对象）不需要参数并返回 f(1, 2)。
同样，bind(g, 1, 2, 3)() 等价于 g(1, 2, 3)。
上面这两句话，理解的关键是：“函数对象”
有选择性地只绑定一部分参数也是有可能的。bind(f, _1, 5)(x) 等价于 f(x, 5)，这里，_1 是一个占位符参数，它的含义是“用第一个输入参数取代”
注意这个 ‘5’ 是怎么传进去的？（被称为bind 持有的参数）
bind 持有的参数被返回的函数对象拷贝并内部持有
int i = 5;
bind(f, i, _1);
//让函数对象存储一个引用而不是拷贝
bind(f, ref(i), _1);            // 将传入引用  boost::ref   boost::cref
bind(f, cref(42), _1);
理解下面的函数对象意义：
bind(f, _2, _1)(x, y);                 // f(y, x)
bind(g, _1, 9, _1)(x);                 // g(x, 9, x)
bind(g, _3, _3, _3)(x, y, z);          // g(z, z, z)
bind(g, _1, _1, _1)(x, y, z);          // g(x, x, x)
和函数及函数指针一起使用 bind

和函数对象一起使用 bind

和成员指针一起使用 bind

为函数组合使用嵌套的 binds

和标准算法一起使用 bind

和 Boost.Function 一起使用 bind

Boost.Function 库包含一组作为 function object wrappers（函数对象包装类）的类模板。在概念上类似一个泛化的 callback（回调）
使用函数指针的任何地方都是用来推迟一个调用或做一个回调
传给接口的参数被 Boost.Function 指定为可以转换为目标函数对象的参数
void func1 (const int& i)
{ }
boost::function<void()> f1 = boost::bind (&func1, 1);
Boost.Function 判断是否可用
void my_func(int a, int b, boost::function<void()> err_callback = 0) {
  if (error && err_callback)  // tests err_callback by converting to bool
     err_callback();
}
 You can test if it's empty by calling its empty() method, comparing it to 0, or simply using it in a boolean context
---------------------------------------------------------------------------
boost::system::error_code 的用法
赋值，描述
 if (ec)  就可判断有无错误，不用  err.value()
void connect_handler(const boost::system::error_code& error)
{
 if (!error)
 {
   // Connect succeeded.
  }
}
error->assign( 1, boost::system::get_system_category() );
Boost.System 是一个定义了四个类的小型库，用以识别错误。 boost::system::error_code 是一个最基本的类，用于代表某个特定操作 的 异常
来自操作系统或其它底层API的错误通常会以一个表示错误代码的整数来报告。当这些底层API调用被包装在可移植的代码中时，例如在一 个可移植的库 中，有些用户会希望以可移植的方式处理这些错误代码。而其它用户则可能需要得到系统特定的错误代码，这样他们可以处理系统特定的需要。Boost System 库提供了简单、轻量级的 error_code 对象，封装系统特定的错误代码值，此外还通过 error_condition 对象提供了对更为抽象和可移植的错误条件的访问。因为 error_code 对象可以表示来自操作系统以外的错误，包括用户自定义的来源，所以每个 error_code 和 error_condition 都有一个相关联的 error_category
本库还提供一个异常类 system_error. 它派生自 std::runtime_error, 用于捕获引起异常的问题的底层 error_code，以便不会丢失这些重要信息
虽然异常是首选的C++缺省的错误代码报告机制，但是使用依赖于底层API的库的用户通常需要通过错误代码参数和/或返回值而不是抛出 异常来报告错误条件。否则，当错误不是意外事件且必须被处理时，程序会变得充满 try/catch 块，不可读并且非常低效。Boost System 库既支持通过异常也支持通过错误代码进行错误报告。
int main() 
{ 
 boost::system::error_code ec; 
 std::string hostname = boost::asio::ip::host_name(ec); 
 std::cout << ec.value() << std::endl; 
 
 异常处理
std::exception has a member function called what() that returns a const char* that mightexplain what happened. If you want to log it (guessing that LOG_FATAL wraps printf somehow) you can do:
catch(std::exception const&  ex)
{
   LOG_FATAL("Can't init settings. %s", ex.what());
}
For boost::exception though you can use boost::get_error_info to find out more about it.
}
---------------------------------------------------------------------------
http://stackoverflow.com/questions/4586768/how-to-iterate-a-boost-property-tree
boost property_tree 使用 迭代器，
BOOST_FOREACH is just a convenient way for iterating that can be done by iterator, begin() and end()
http://www.boost.org/doc/libs/1_54_0/libs/crc/crc.html
http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/qi/reference/binary/binary_little.html
分析字符串，"\x01\x02"，并转成，对应的 高位序  与  底位序
http://stackoverflow.com/questions/105252/how-do-i-convert-between-big-endian-and-little-endian-values-in-c
---------------------------------------------------------------------------
【JSON】

Creating JSON arrays in Boost using Property Trees

boost::property_tree::ptree root, arr, elem1, elem2;
elem1.put<int>("key0", 0);
elem1.put<bool>("key1", true);
elem2.put<float>("key2", 2.2f);
elem2.put<double>("key3", 3.3);
arr.push_back( std::make_pair("", elem1) );
arr.push_back( std::make_pair("", elem2) );
root.put_child("path1.path2", arr);
boost tree , json , 数据中的类型信息全丢失了，全部保存成字符串类型
Boost property_tree does not fully support all type information. From the documentation: JSON values are mapped to nodes containing the value. However, all type information is lost; numbers, as well as the literals "null", "true" and "false" are simply mapped to their string form
JsonCpp / JSON Spirit 
        json_spirit::Object root, obj;
        obj.push_back( json_spirit::Pair( "title", "精品录播系统说明") );
        obj.push_back( json_spirit::Pair( "teacher", "开发部") );
        obj.push_back( json_spirit::Pair( "school", "高鸿") );
        root.push_back( json_spirit::Pair( "courseware", obj ) );
        
        ofstream of( "d:\\test.json" );
        json_spirit::write( root, of, json_spirit::pretty_print );
utf-8 问题
        json_spirit::wObject root, obj;
        json_spirit::wArray items;
        obj.push_back( json_spirit::wPair( L"title", L"精品录播系统说明") );
        obj.push_back( json_spirit::wPair( L"teacher", L"开发部") );
        obj.push_back( json_spirit::wPair( L"school", L"高鸿") );
        obj.push_back( json_spirit::wPair( L"time", L"45分钟") );
        root.push_back( json_spirit::wPair( L"courseware", obj ) );
        obj.clear();
        obj.push_back( json_spirit::wPair( L"title", L"氧气的物理性质" ) );
        obj.push_back( json_spirit::wPair( L"timestamp", 12 ) );
        obj.push_back( json_spirit::wPair( L"pic", L"幻灯片1.png" ) );
        obj.push_back( json_spirit::wPair( L"note", L"大气中，氧气的含量21%。" ) );
        items.push_back( obj );
        root.push_back( json_spirit::wPair( L"items", items ) );
        obj.clear();
        obj.push_back( json_spirit::wPair( L"vga", L"vga-courseware.mp4" ) );
        obj.push_back( json_spirit::wPair( L"student", L"student-courseware.mp4" ) );
        obj.push_back( json_spirit::wPair( L"teacher", L"teacher-courseware.mp4" ) );
        root.push_back( json_spirit::wPair( L"video", obj ) );
        root.push_back( json_spirit::wPair( L"template", 3 ) );
        root.push_back( json_spirit::wPair( L"path", L"" ) );
        std::wstring rs = json_spirit::write( root );
        
        ofstream of( "d:\\test.json" );
        of << Unicode2UTF8( rs );
        of.close();
宽字符问题
        json_spirit::wObject root, obj;
        obj.push_back( json_spirit::wPair( L"title", L"精品录播系统说明") );
        obj.push_back( json_spirit::wPair( L"teacher", L"开发部") );
        obj.push_back( json_spirit::wPair( L"school", L"高鸿") );
        root.push_back( json_spirit::wPair( L"courseware", obj ) );
 enum Output_options{
pretty_print = 0x01,   // Add whitespace to format the output nicely.
raw_utf8 = 0x02,      
               // This prevents non-printable characters from being escapted using "\uNNNN" notation.
              // Note, this is an extension to the JSON standard. It disables the escaping of
               // non-printable characters allowing UTF-8 sequences held in 8 bit char strings
                // to pass through unaltered.
remove_trailing_zeros = 0x04,
          // outputs e.g. "1.200000000000000" as "1.2"
single_line_arrays = 0x08,
           // pretty printing except that arrays printed on single lines unless they contain
           // composite elements, i.e. objects or arrays
always_escape_nonascii = 0x10,
            // all unicode wide characters are escaped, i.e. outputed as "\uXXXX", even if they are
           // printable under the current locale, ascii printable chars are not escaped
                       };
                       
                       
                       spirit - LL 分析器框架，以内联的C++方式直接从 EBNF 语法实现分析器，来自 Joel de Guzman 及其团队
Boost 的高可扩展性 Spirit 解析器框架。该解析器生成程序遵循 Extended Backus Naur Form (EBNF) 规范并使用 C++ 编写，可以显著缩短开发时间
Boost.Spirit能使我们轻松地编写出一个简单脚本的语法解析器，
它巧妙利用了元编程并重载了大量的C++操作符
使得我们能够在C++里直接使用类似EBNF的语法构造出一个完整的语法解析器
---------------------------------------------------------------------------
json 文件里中的，字符串，转义符（escape character）问题？http://stackoverflow.com/questions/4113967/escaping-character-in-json-string
std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair<int,float> 或者 std：：pair<double,double>等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数
This class couples together a pair of values, which may be of different types (T1 and T2). The individual values can be accessed through its public members first and second.
---------------------------------------------------------------------------
http://cpp.ezbty.org//myfiles/boost/libs/smart_ptr/smart_ptr.htm
boost智能指针
scoped_ptr
<boost/scoped_ptr.hpp>
简单的单一对象的唯一所有权。不可拷贝。
scoped_array
<boost/scoped_array.hpp>
简单的数组的唯一所有权。不可拷贝。
shared_ptr
<boost/shared_ptr.hpp>
在多个指针间共享的对象所有权。
shared_array
<boost/shared_array.hpp>
在多个指针间共享的数组所有权。
weak_ptr
<boost/weak_ptr.hpp>
一个属于 shared_ptr 的对象的无所有权的观察者。
intrusive_ptr
<boost/intrusive_ptr.hpp>
带有一个侵入式引用计数的对象的共享所有权。

---------------------------------------------------------------------------
[http-request-response.png][http-request.png][http-response.png]
http 协议  客户端请求
GET / HTTP/1.1
Host:www.google.com
<request line>
<headers>
<blank line>
[<request-body>]
表单提交中get和post方式的区别归纳如下几点：

（1）get是从服务器上获取数据，post是向服务器传送数据。
（2）对于表单的提交方式，在服务器端只能用Request.QueryString来获取Get方式提交来的数据，用Post方式提交的数据只能用Request.Form来获取。
（3）一般来说，尽量避免使用Get方式提交表单，因为有可能会导致安全问题。比如说在登陆表单中用Get方式，用户输入的用户名和密码将在地址栏中暴露无遗。但是在分页程序中，用Get方式就比用Post好

http://www3.ntu.edu.sg/home/ehchua/programming/webprogramming/http_basics.html

---------------------------------------------------------------------------
http://stackoverflow.com/questions/3150942/c-delete-this
http://www.parashift.com/c++-faq-lite/delete-this.html
http://stackoverflow.com/questions/447379/what-is-the-use-of-delete-this
关于delete this 的思考：
delete this
1. 违背了“谁分配，谁释放”的原则。
( C++ 不充许 对象自己创建自己。必然是另一个对象创建了它。)
2. 使分配的指针，变成了“野指针”。（无法把指针置空）
As long as you're careful, it's OK for an object to commit suicide (delete this).
"delete this" is commonly used for ref counted objects（引用计数的对象）. For a ref counted object the decision of when to delete is usually placed on the object itself.
ATL COM objects are a prime example of this pattern.
int MyRefCountedObject::Release() {
 _refCount--;
 if ( 0 == _refCount ) {
   delete this;
   return 0;
 }
 return _refCount;
}
http://stackoverflow.com/questions/550189/is-it-safe-to-delete-this
delete this is a "code smell" (代码异味) that your code might not have a symmetric(均衡的) strategy(策略) for object ownership (who allocates and who deletes).
https://www.securecoding.cert.org/confluence/display/cplusplus/OOP05-CPP.+Avoid+deleting+this
Avoid deleting this

Deleting this leaves it as a "dangling" pointer, which leads to undefined behavior if it is accessed. Deleting this is only valid if you can guarantee that the this pointer is never dereferenced again. Furthermore, deleting this is only valid if you can guarantee the object was allocated using the {{new]} operator.
---------------------------------------------------------------------------
http://www.cnblogs.com/TianFang/archive/2013/02/04/2891538.html
http://blog.csdn.net/vagrxie/article/details/4225133
boost 字符串比较算法
<boost/algorithm/string.hpp>
忽略大小写比较字符串
tolower()
将字符转换成小写字符
toupper()
将字符转换成大写字符 
boost库在头文件<boost/algorithm/string.hpp>中提供了不少字符串处理函数，用以帮助我们实现基本的字符串处理功能，极大程度上缓解了字符串函数不够用的问题
#include <boost/algorithm/string.hpp>
// Or, for fewer header dependencies:
//#include <boost/algorithm/string/predicate.hpp>

std::string str1 = "hello, world!";
std::string str2 = "HELLO, WORLD!";

if (boost::iequals(str1, str2))  还可比较 宽字符串 与 多字节字符串，（转码不行。。。默认怎么转的？）
boost::iequals(pname, processInfo->szExeFile)
---------------------------------------------------------------------------
boost::flyweight

使用Boost.Flyweight的好处

http://www.cnblogs.com/zhangwusheng/archive/2011/09/23/2185957.html
http://blog.csdn.net/zirandeai/article/details/8288404
简单点说，就是当需要生成N个实例，而这N个实例中有部分域是冗余重复的，那么这个时候就可以使用flyweight模式了，就是享元模式
享元模式的思想就是把重复的数据只在一个桶中保存一份，当外部对象需要使用数据时，只要保存一个该数据在桶中的引用即可，而无需每个对象都持有该数据
vector< boost::flyweight<string> >  boost_v
boost_v.push_back( boost::flyweight<string>( tmp )  );
vector< string >  stl_v;
stl_v.push_back( (tmp)  );
使用flyweight后，每次保存的不是实际的对象，而只是handler，从而使得在存储冗余数据时，内存消耗大大减小
---------------------------------------------------------------------------
http://www.cppblog.com/youxia/archive/2010/10/17/130218.html
http://stlab.adobe.com/gil/presentation/index.htm
gil - Generic Image Library, from Lubomir Bourdev and Hailin Jin  通用图形库
---------------------------------------------------------------------------
#include <Windows.h>
#include <boost/asio.hpp>  
vc 命令行程序（不包含任何其它头文件的情况下），
出现下面的错误
boost_1_54_0\boost\asio\detail\socket_types.hpp(22): fatal error C1189: #error :  WinSock.h has already been included
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
在头文件前加上这个宏处理片段，就可以正常编译了。
http://stackoverflow.com/questions/9750344/boostasio-winsock-and-winsock-2-compatibility-issue
Try and change the order or includes. Start with boost/asio.hpp and put windows.h after it.
There's a similar issue with ACE, including ace/OS.h before anything else solves it.
---------------------------------------------------------------------------
inprocess  server 程序，使用，managed_window_shared_memory,  
boost::interprocess::open_only  打开，出下面的错误。 
(debug版本没有问题，debug是用户启动的，不是系统启动的服务。)  改成managed_shared_memory 就可以用了。
[查看录播机状态]创建共享内存异常 : 系统找不到指定的文件。
---------------------------------------------------------------------------
http://www.boost.org/community/review_schedule.html
BOOST预览库(注意其中的dropbox链接)
---------------------------------------------------------------------------
BOOST_FOREACH 原理？会调用 begin()吗？还是别的函数
http://www.boost.org/doc/libs/1_54_0/doc/html/foreach.html
So you can't use a range-based for-loop here. You have to use a real for-loop over the iterators
for(auto &attrIt = children.begin(); attrIt != children.end();)
---------------------------------------------------------------------------
https://svn.boost.org/trac/boost/ticket/4182
包含boost库出现 警告
warning C4005: “INT8_MIN”
This is nothing to do with us - the fact that two Microsoft headers conflict with each other is their issue not ours - sorry to be so blunt, but we should be able to use <stdint.h> without worrying what other headers may have been included.
#include <intsafe.h>
#include <stdint.h>
warning c4005宏重定义  boost
http://wanwan722.wordpress.com/category/boost/
lF是Visual Studio 2010和Windows SDK 7.0的定xn突}  下面是这个问题的链接
Including stdint after intsafe generates warnings  (This is fixed in VS 2012.)
http://connect.microsoft.com/VisualStudio/feedback/details/621653/including-stdint-after-intsafe-generates-warnings
解决方法：（在stdafx.h头文件，开头写入下面两行）
#define _INTSAFE_H_INCLUDED_
#include <stdint.h>
---------------------------------------------------------------------------

http://boost.cowic.de/rc/pdf/ 
http://meetingcpp.com/tl_files/blog/boost_1_55.png
c++ boost 库，联系图
Boost.Asio writes debugging output to the standard error stream.
---------------------------------------------------------------------------
【property-tree】
boost::property_tree::ptree设置树路径 的分隔符
http://stackoverflow.com/questions/1948745/boost-property-tree-with-filename-as-key
第一种解决方法：
pt.push_back( ptree::value_type("example.txt", ptree(10)) );
第二种解决方法： (这种方法没有重载函数)
pt.put('/', "example.txt", "10");
pt.get<string>('/', "example.txt");
http://www.boost.org/doc/libs/1_47_0/doc/html/boost_propertytree/accessing.html
typedef ptree::path_type path;
pt.get<float>(path("p.a.t.h/t.o/v.a.l.u.e", '/'));
pt.get(path("p.a.t.h/t.o/v.a.l.u.e", '/'), 0, NULL);
pt.get_optional<std::string>(path("p.a.t.h/t.o/v.a.l.u.e", '/'));


写XML出现很多空的换行符
So the solution was to add the trim_whitespace flag to the call to read_xml:
read_xml("file.xml", pt, boost::property_tree::xml_parser::trim_whitespace );
boost::property_tree::read_xml
( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
http://stackoverflow.com/questions/6572550/boostproperty-tree-xml-pretty-printing
        boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);
        boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );
        
        
WriteXMLData  wptree 含有有中文 时，
        boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);
        boost::property_tree::write_xml( xml_path, ptree, std::locale(), settings ); 会异常。
wptree问题
http://stackoverflow.com/questions/10568531/boost-property-tree-issue-when-converting-to-unicode
http://notes.xj-labs.net/?p=52
Boost 目前是支持 UTF8 的，但是不能用 直接用 Unicode。所以，如果要存储宽字符就有点麻烦需要用到 Boost 提供的 utf8_codecvt_facet 做转换
#include "boost/program_options/detail/utf8_codecvt_facet.hpp"
std::locale utf8Locale(
oldLocale,
           new boost::program_options::detail::utf8_codecvt_facet());
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
boost::property_tree::xml_writer_settings<wchar_t> settings(L'\t', 1);  格式化输出XML
boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );  
把UNICODE输出为UTF8
读的时候也出这个问题
http://stackoverflow.com/questions/10568531/boost-property-tree-issue-when-converting-to-unicode/16071043#16071043  (这里方法显然不行)
boost::property_tree::read_xml( wstring2string( xml_file ), xml, 0, utf8Locale );
注意后面两个字符串，是用于输出 文件 流格式化的。
ptree.put_child( node_name, file_node );  
已经存在 ，就覆盖，能不能抛异常，或者其它处理方式呢？

http://www.boost.org/doc/libs/1_43_0/doc/html/boost/property_tree/basic_ptree.html#id979449-bb  ptree文档
assoc_iterator find(const key_type & key) ;  应该输入什么？键值吗？可是还是找不到啊(只找其子节点的)
Find a child with the given key, or not_found() if there is none
始终不对, 不存在，也能找到
http://boost.2283326.n4.nabble.com/property-tree-find-no-match-for-operator-td3860490.html
 I know that ptree uses multi_index
Anyway :
- you have a get_optional() method.
- you can try replacing end() with not_found()
用find 未找到使用方法，暂时用get_child_optional 来判断。
        std::string path = "product." + wstring2string( pro );
        if( m_tree.get_child_optional( path ) ) {
                throw std::exception( "产品名称已经存在" );
        }
        m_tree.put( path, "" );

理解 key_type
ptree 的数据结构，可以理解为下面的形式
struct ptree
{
  data_type data;                         // data associated with the node
  list< pair<key_type, ptree> > children; // ordered list of named children
};
Both key_type and data_type are configurable, but will usually be std::string
optional< self_type & > get_child_optional(const path_type & path) ;
Get the child at the given path, or return boost::null.
boost property_tree 判断已经存在的节点
http://stackoverflow.com/questions/7568607/boost-property-tree-check-if-child-exists
if( node.count("possibliy_missing") == 0 )
{
  ...
}
ptree::const_assoc_iterator it = ptree.find("possibly_missing");
if( it == ptree.not_found() )
{
  ...
}


boost property tree delete child
http://stackoverflow.com/questions/11047950/boost-property-tree-remove-a-node
/** Erase the child pointed at by the iterator. This operation
        * invalidates the given iterator, as well as its equivalent
        * assoc_iterator.
        * @return A valid iterator pointing to the element after the erased.
        */
       iterator erase(iterator where);
ptree::const_assoc_iterator it = ptree.find("possibly_missing");



boost property_tree ptree write_xml 空节点问题
recordfileinfo.add_child( "Tags",  boost::property_tree::ptree( "" ) );
recordfileinfo.add( "Tags",  “”);
有区别吗？  两者一样都是： <Tags/>  空节点问题


xml读写
http://blog.csdn.net/wf520pb/article/details/2644549
查询属性（attribute）节点  
 
  以上的各种方法都返回元素（element)节点（集），返回属性（attribute），只需要采用相应的方法，在属性名前加一个@符号即可，例如：  
 
   objNodeList = objDoc.SelectNodes(“Company/Department/Employees/Employee/@id”)  
 
   objNodeList = objDoc.SelectNodes(“Company//@id”)  
最常见的XML数据类型有：Element, Attribute，Comment, Text.
MSXML2库实现了DOM模型读取XML的模块


关于ini文件的注释格式http://blog.163.com/wangzhenbo85@126/blog/static/101363282201011146306646/

[xxx]
a=a
;这里是a的注释
b=b
;这里是b的注释
c=c
d=d
注意： 这样写会把后面的分号及之后的内容都包含进去只能在行头加分号



Property Tree? 属性树是什么？

Property Tree库提供了一种数据结构，用于保存任意嵌套层数的由值组成的树，每一层以 某个键值来索引。树的每个节点保存了它本身的值，以及一个由该节点的子节点及其键值 组成的有序列表。这种树可以通过类似于路径的方式很方便地访问任一节点，这个路径由 多个键值串接而成.
这个库还提供了一些分析器和生成器，对应于多种可用于表示一棵树的数据格式， 如 XML, INI 和 JSON
属性树是多功能的数据结构，尤其适合用于保存配置数据。该树提供了它自己本身、树专用 的接口，而且每个节点都是其子节点的一个STL兼容序列
struct ptree
{
  data_type data;                         // data associated with the node 与节点相关联的数据
   list< pair<key_type, ptree> > children; // ordered list of named children 命名子节点的有序列表
};
key_type 和 data_type 都是可配置的，但通常都是 std::string
XML Parser XML分析器

本库包含了一个小而快的 RapidXML 分析器(当前版本为 1.13)以提供XML分析的支持。 RapidXML 并不完全支持XML标准；它不能分析DTDs，因此不能实现完全的实体替换
使用Boost property tree来解析带attribute的xml
boost property tree的5分钟教程虽然简单明了，可惜使用的xml不够典型。今天由于工作上要读取带属性并且有几层嵌套的xml配置文件，因此研究了一下如何使用
#include <boost/property_tree/ptree.hpp> 
#include <boost/property_tree/xml_parser.hpp>
ptree pt;
read_xml("debug_settings.xml", pt);
BOOST_FOREACH(ptree::value_type &v1, pt.get_child("debug"))
v1.first == "<xmlattr>"
v1.second.get<string>("name")
boost::property_tree::read_xml(vm["xml"].as<std::string>(), pt);
boost tree 的概念：
boost::property_tree::ptree m_tree;
pt.get_child("beans.bean")  返回什么？
属性树类似于(几乎就是)一个值类型为 pair<string, ptree> 的标准容器
ptree::value_type("pi", ptree("3.14159"))
pt.push_back(ptree::value_type("pi", ptree("3.14159")));
float v = pt.get<float>("a.path.to.float.value");
float v = pt.get("a.path.to.float.value", -1.f);
boost::optional<float> v = pt.get_optional<float>("a.path.to.float.value");
要从树中(不是某个子键)获取值，请用 get_value, get_value (缺省值版本)， 和 get_value_optional。它们具有与 get 函数相同的语义，除了一点， 它们不接受 path 参数
pt.put("a.path.to.float.value", 3.14f);
类似于 get_value，也有一个 put_value 函数
自己写的代码：
std::string tmp = pt.get<std::string>("beans.bean.<xmlattr>.id");
return m_tree.get<int>("set.listenPort");
m_tree.put("set.listenPort", port);
ptree pt;
pt.put("a.path.to.float.value", 3.14f);
boost::property_tree::ini_parser::read_ini(file_name, m_tree);  不能是宽字
---------------------------------------------------------------------------
boost optional
 optional库使用"容器"语义，包装了"可能产生无效值"的对象，实现了"未初始化"的概念.
http://blog.csdn.net/mmzsyx/article/details/8163259
"无意义"的值:
函数并不总能返回有效的返回值，很多时候函数可能返回"无意义"的值，
这不意味着函数执行失败，而是表明函数正确执行了，但结果却不是有用的值
optional很像一个仅能存放一个元素的容器，它实现了"未初始化"的概念：
如果元素未初始化，那么容器就是空的，否则，容器内就是有效的，已经初始化的值
optional的真实接口很复杂，因为它要能够包装任何的类型
---------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
http://stackoverflow.com/questions/9538114/utf-8-locale-in-visual-c-2010
这个会和boost的函数冲突造成
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
出现下面错误
error C2661: “std::locale::facet::operator new”: 没有重载函数接受 3 个参数
If you are looking for existing memory leaks, you can use DEBUG_NEW if you are in VS2010.
---------------------------------------------------------------------------
boost::is_any_of( "_." )  造成警告：
warning C4996: 'std::_Copy_impl'  这个警告只在DEBUG版里出，RELEASE版本里不出。
Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'
http://stackoverflow.com/questions/14141476/warning-with-boostsplit-when-compiling
忽略警告
-D_SCL_SECURE_NO_WARNINGS
---------------------------------------------------------------------------
---------------------------------------------------------------------------

md5 sha1 boost
http://en.wikipedia.org/wiki/Crypto%2B%2B
www.boost.org/doc/libs/1_46_0/boost/uuid/sha1.hpp
boost::uuids::detail::sha1 s
s.process_bytes(a.c_str(), a.size());
unsigned int digest[5];
s.get_digest(digest);
---------------------------------------------------------------------------
【VISCA.png】
asio pdf
http://meetingcpp.com/tl_files/mcpp/slides/12/Boost.Asio%20-%20Asynchronous%20IO.pdf
http://en.wikipedia.org/wiki/VISCA_Protocol
http://www.vaddio.com/images/downloads/tc_sony_z700_commandlist.pdf
使用BOOST::ASIO 读取COM串口数据，最后，总是多出一些数据
90 41 FF 90 51 FF

Serial ports are available on all POSIX platforms. For Windows, serial ports are only available at compile time when the I/O completion port backend is used (which is the default). A program may test for the macro BOOST_ASIO_HAS_SERIAL_PORTS to determine whether they are supported.

boost asio write_some 与 write有什么区别？
                boost::asio::io_service::work work( m_io_service );
                m_io_service.run();


【asio-tcp-iostream.png】
【boost asio 缓存集】
发送多个缓存
                boost::array<boost::asio::const_buffer, 2> bufs;
                bufs[0] = boost::asio::buffer(&id_, sizeof(id_));
                bufs[1] = boost::asio::buffer(this, sizeof(this));
                socket.send_to(bufs, remote);
接收时，就需要有几个缓存
                boost::array<boost::asio::mutable_buffer, 2> bufs = {
                        boost::asio::buffer(&id, sizeof(id)),
                        boost::asio::buffer(buffer)
                };
                size_t rcv_size = socket_.receive_from(bufs, remote_endpoint);
asio
typedef std::pair<void*, std::size_t> mutable_buffer;
typedef std::pair<const void*, std::size_t> const_buffer;
asio 中的 I/O 对象  基于流的对象
socket,
ip::tcp::socket, ssl::stream<>, posix::stream_descriptor, windows::stream_handle



获取本地IP地址   BOOST ASIO如何做？  （所有地址列表）
gethostbyname ip address
http://beej.us/guide/bgnet/output/html/multipage/gethostbynameman.html
http://msdn.microsoft.com/en-us/library/windows/desktop/ms738552(v=vs.85).aspx
typedef struct hostent {
 char FAR      *h_name;
 char FAR  FAR **h_aliases;
 short         h_addrtype;
 short         h_length;

 char FAR  FAR **h_addr_list;  
A NULL-terminated list of addresses for the host.
Addresses are returned in network byte order.

} HOSTENT, *PHOSTENT, FAR *LPHOSTENT;

【asio 设置同步操作的超时？没有正规方法】
由BOOST::THREAD创建的线程，调用receive_from阻塞住。
当在另主线程里，调用server_thread_.interrupt();时，会出现下面的异常。
UDP服务器接收数据时异常: receive_from: 一个封锁操作被对 WSACancelBlockingCall 的调用中断。
socket_.shutdown(boost::asio::ip::udp::socket::shutdown_both);  一个效果


[asio 串口编程]
i/o 读写的codecvt local facet
boost/program_options/detail/utf8_codecvt_facet.hpp
		static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
		boost::property_tree::wptree xml;
		boost::property_tree::read_xml( wstring2string( xml_file ), xml, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
		
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
	boost::property_tree::read_xml( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
	boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );

http://msdn.microsoft.com/en-us/library/ff802693.aspx
串口通信开发文档。
Overlapped I/O operation

boost::asio::socket 异步读写时  socket关闭问题？需要同步吗？

Using the attached sample program (a slightly modified version of the daytime3 tutorial). When I connect with a telnet session to the server and close the connection directly I get the following output from the server: Transfer status: Success. Transfer status: Broken pipe. Transfer status: Broken pipe. Transfer status: Broken pipe.

After the first error I close the socket and would expect a boost::asio::error::operation_aborted error instead of the broken pipe.

Reproduced under both Debian Lenny (gcc 4.3.4) and Windows XP (MSVC 2008).
当调用close后，正在写的操作，就completed with an error as soon as the client closed the connection
The behaviour is correct. The write operations are not pending when you call close, it's just that the handlers haven't been called yet. The write operations themselves completed with an error as soon as the client closed the connection.

CloseHandle(impl.handle_) 串口，即使只有一个线程，也会死在句。退不出来。USB2PORT
I agree with both previous posts.

This is a bug in the driver for FTDI chipset under Windows XP.
The native method CloseHandle() never returns, when the port handle is closed.

https://connect.microsoft.com/VisualStudio/feedback/details/202137/serialport-close-hangs-the-application

This is not a normal situation.
Unplugging the USB device usually helps.
This problem is related to the glitches in the FTDI driver, which is responsible for implementing a virtual COM port. On the other hand those "glitches" are related to various malfunctions of the USB devices. (Of course this doesn't justify the FTDI driver).

BTW there're several other known problems with some FTDI drivers:

Sometimes call to CloseHandle just hangs the calling thread.
Sometimes also the application is still "visible" in the task manager, even after it's closed. Task manager can't terminate the application, and the debugger can't be attached to it. Its EXE file is locked (can't be erased).
Usually unplugging the USB device immediately helps in those situations. The FTDI driver, which seems to be "waiting for something" awakes.

一个boost::asio::socket, 在不同的线程，写，不加互斥，是不安全的。
The only way to protect you from hitting this case is to build your program to avoid situations like this.

One way to do that is by writing an application layer send buffer 
which a single thread is responsible for pushing onto the socket. 
That way you could protect the send buffer itself only. 
Keep in mind though that a simple std::vector won't work, 
since adding bytes to the end may end up re-allocating it, 
possibly while there is an outstanding async_write_some() referencing it. 
Instead, it's probably a good idea to use a linked list of buffers, a
nd make use of the scatter/gather feature of asio.

write and async_write are not thread safe in the manner you are using them. 
The canonical way to approach this is to queue your messages, then write them out one at a time.

Tip::tcp::socket  hread Safety
Distinct objects: Safe.
Shared objects: Unsafe.

boost::socket对象在工作线程中同步读写的情况，在另一线程里关闭？没有常规的办法。
Thread-safely closing a boost::asio::ip::tcp::socket being used synchronously
异步读写的情况下，可以先cancel
If your acceptor is in async_accept, you can call ip::tcp::acceptor::cancel() to cancel any async operations on it. 
试验结果，虽然cancel了，还是会接收到数据（m_serial_port.cancel  m_serial_port.close 那个会再引导异步I/O操作？）

Cancel is useful if you want to stop pending operations without closing down the socket.
Note that the Boost documentation recommends using close for greater portability (from doc page):
... For portable cancellation, consider using one of the following alternatives:
Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.
Use the close() function to simultaneously cancel the outstanding operations and close the socket.

Note however the remarks for cancel() also state When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. 
This function does not have the problems described above. 
C  Sam Miller Jun 22 '11 at 15:33 
thank you and Sam Miller for help,i understand a little now,thank you

cancel won't close the socket, so use cancel if you intend to continue using the socket object. In particular, if you have code in asynchronous handler methods that references the socket's member functions, you may not want to close the socket until you are guaranteed that your currently executing asynchronous handlers have completed.

cancel doesn't guarantee anything about currently executing asynchronous handlers, it only guarantees (per the boost documentation) that "This function causes all outstanding asynchronous connect, send and receive operations to finish immediately" in the case of the socket::cancel() call, or "This function forces the completion of any pending asynchronous operations on the host resolver" in the case of the resolver::cancel() call. This "completion" means that boost will call your asynchronous handler method, it has no jurisdiction to inject any cancellation logic into your asynchronous handler (not to mention it doesn't know about the handler's implementation to begin with).

I would suggest adding your own logic into your asynchronous handler method to handle the case where the socket/resolver/etc. is canceled. If you are calling the cancel method, then you likely have the ability to communicate this cancellation to the asynchronous handler method.

basic_serial_port::close (1 of 2 overloads)

Close the serial port.

void close();  根据下面的解释，Close前没有必要调用cancel
This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.







---------------------------------------------------------------------------
【结构体的序列化】
http://stackoverflow.com/questions/3938307/serializing-c-style-structs-using-c
Doing a memcpy of classes/structs is okay if they're just Plain Old Data (POD), but if that's the case, then you could rely on C++ doing the copying for you via copy constructors (which exist for bothstruct and class types in C++).
Certainly you can do it the way you have been doing it - one of the products I've worked on serializes data using memcpy, sends the data over the wire, and client applications decode the bytestream to get the data back.
But if you have a choice, you might want something higher level like boost.serialization, which offers more flexibility and deep-pointer copying. The aforementioned Google ProtoBuffers would work nicely too.
Here are some threads discussing serialization methods in C++:
boost serialization vs google protocol buffers?
C++ Serialization Performance
http://stackoverflow.com/questions/1061169/boost-serialization-vs-google-protocol-buffers
Boost Serialisation
is a library for writing data into a stream.
does not compress data.
does not support data versioning automatically.
supports STL containers.
properties of data written depend on streams chosen (e.g. endian, compressed).
Protocol Buffers
generates code from interface description (supports C++, Python and Java by default. C, C# and others by 3rd party).
optionally compresses data.
handles data versioning automatically.
handles endian swapping between platforms.
does not support STL containers.
Boost serialisation is a library for converting an object into a serialised stream of data. Protocol Buffers do the same thing, but also do other work for you (like versioning and endian swapping). Boost serialisation is simpler for "small simple tasks". Protocol Buffers are probably better for "larger infrastructure".
http://stackoverflow.com/questions/321619/c-serialization-performance
I'm building a distributed C++ application that needs to do lots of serialization and deserialization of simple data structures that's being passed between different processes and computers.
http://baike.baidu.com/view/1708160.htm
Protocol Buffers是Google公司开发的一种数据描述语言，
类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面。
它不依赖于语言和平台并且可扩展性极强。
现阶段官方支持C++、JAVA、Python等三种编程语言，但可以找到大量的几乎涵盖所有语言的第三方拓展包
Protocol Buffers经常被简称为protobuf
Protocol Buffers在谷歌被广泛用于各种结构化信息存储和交换。
Protocol Buffers作为一个自定义的远程过程调用（RPC）系统，
用于在谷歌几乎所有的设备间的通信
每一个protocol buffer 信息都是一小段结构，包含了一些名字。
下面是一个.proto 文件内容的样例。
[pre]message Point { required int32 x = 1; required int32 y = 2; optional string label = 3;} message Line { required Point start = 1; required Point end = 2; optional string label = 3;} message Polyline { repeated Point point = 1; optional string label = 2;}
http://www.parashift.com/c++-faq-lite/serialize-text-format.html
序列化的过程，是把结构体，改成一个字符串，再由对方解析出。
http://www.ocoudert.com/blog/2011/07/09/a-practical-guide-to-c-serialization/


【archive-xml-iarchive.png】
http://stackoverflow.com/questions/652193/serialize-and-send-a-data-structure-using-boost
std::ostringstream archive_stream;
boost::archive::text_oarchive archive(archive_stream);
archive << your_struct;
outbound_data_ = archive_stream.str();
boost::asio::async_write(socket_, 
   boost::asio::buffer(outbound_data_), handler);
http://www.boost.org/doc/libs/1_38_0/doc/html/boost_asio/example/serialization/server.cpp
http://stackoverflow.com/questions/15251415/exception-when-using-boostserialization-with-boostasio


序列化
http://en.wikipedia.org/wiki/Serialization
http://stackoverflow.com/questions/652193/serialize-and-send-a-data-structure-using-boost
http://stackoverflow.com/questions/523872/how-do-you-serialize-an-object-in-c
http://www.boost.org/doc/libs/1_54_0/libs/serialization/doc/index.html
serialization   序列化
将任意一组C++数据结构解构为一串字节的、可逆的过程
把类的对象  序列化  保存到文件里，
从文件里读出 序列化数据，加载成类对象
void save_schedule(const bus_schedule &s, const char * filename){
   // make an archive
   std::ofstream ofs(filename);
   boost::archive::text_oarchive oa(ofs);
   oa << s;
}

void
restore_schedule(bus_schedule &s, const char * filename)
{
   // open the archive
   std::ifstream ifs(filename);
   boost::archive::text_iarchive ia(ifs);

   // restore the schedule from the archive
   ia >> s;
}
 we have used a particular archive class - text_oarchive for saving and text_iarchive for loading

The binary_oarchive and binary_iarchive classes are implemented in terms of the more basicstd::streambuf

---------------------------------------------------------------------------
【bitset】【bitset-1.png】【bitset-2.png】
#include <iostream> 
#include <bitset> 
int main()  
{  
    std::bitset<8> bs(8);  
    std::cout << "输出所有binary bit: " << bs << std::endl;  
    std::cout << "bitset - any() 是否存在置为1的bit: " << std::boolalpha << bs.any() << std::noboolalpha << std::endl;  
    std::cout << "bitset - none() 是否不存在置为 1 的bit: " << bs.none() << std::endl;  
    std::cout << "bitset - count() bit为 1 的个数: " << bs.count() << std::endl;  
    std::cout << "bitset - size() bit的个数: " << bs.size() << std::endl;  
    bs.flip();  
    std::cout << "bitset - flip() 把所有bit逐位取反 后: " << bs << std::endl;  
    bs.flip(0);  
    std::cout << "bitset - flip(size_t pos) 把在pos(zero-based)处的bit 按位取反 后: " << bs << std::endl;  
    std::cout << "bitset - [] 使用[]操作符访问pos处的bit: " << bs[0] << std::endl;  
    bs.set();  
    std::cout << "bitset - set() 把所有的bit都置为1: " << bs << std::endl;  
    bs.set(0);  
    std::cout << "bitset - set(size_t pos) 把pos处的bit置为1: " << bs << std::endl;  
    std::cout << "bitset - test(size_t pos) 测试pos处的bit是否为1: " << std::boolalpha << bs.test(0) << std::noboolalpha << std::endl;  
    std::cout << "bitset - to_ulong() 返回一个unsigned long值: " << bs.to_ulong() << std::endl;  
    std::cout << "bitset - to_string() 返回一个std::string值: " << bs.to_string() << std::endl;  
    return 0;  
}



std::bitset

 
C++
 
Utilities library
 
std::bitset
 
Defined in header <bitset>
template< std::size_t N >
class bitset;
The class template bitset represents a fixed-size sequence of N bits. Bitsets can be manipulated by standard logic operators and converted to and from strings and integers.

---------------------------------------------------------------------------

最好的JSON解析器
http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
JsonCpp (http://jsoncpp.sourceforge.net/)
json_spirit::write( root, json_spirit::pretty_print );

I'm using JSON Spirit on a project at the moment, I'm impressed with it so far.
Note that it does rely on Boost (if only for headers).
Handy features:
Has Unicode support.
Uses std::vector to hold Arrays which helps interoperability.
Provides a pretty print function (write_formatted).
Has read and write functions for strings and streams.
Note that Objects are also implemented using vector (not map), which means slower access, but it does mean that the order of elements is maintained.

Boost property_tree does not fully support all type information. 
From the documentation: JSON values are mapped to nodes containing the value. 
However, all type information is lost; numbers, as well as the literals "null", "true" and "false" 
are simply mapped to their string form

Packet injection(注入)
By utilizing raw sockets, NDIS function calls, or direct access to a network adapter kernel mode driver, arbitrary packets can be constructed and injected into a computer network. These arbitrary packets can be constructed from any type of packet protocol (ICMP, TCP, UDP, and others) since there is full control over the packet header while the packet is being assembled

The basic service set (BSS) provides the basic building-block of an 802.11 wireless LAN.
Each BSS or ESS is identified by a service set identifier (SSID) - a 1 to 32 byte string

An extended service set (ESS) is a set of two or more interconnected wireless BSSs that share the same SSID (network name), 
security credentials and integrated (providing translation between 802.3 and 802.11 frames) wired local area networks that appear 
as a single BSS to the logical link control layer at any station associated with one of those BSSs 
which facilitates mobile IP and fast secure roaming applications; 
the BSSs may work on the same channel, or work on different channels to boost aggregate throughput.



---------------------------------------------------------------------------
boost::system::error_code 的类型判断
void SerialPort::on_receive_(const boost::system::error_code& ec, size_t bytes_transferred)
{
	try {
		//boost::mutex::scoped_lock lock( m_mutex );
		
		if( ec ) {                                          判断这个ERROR是否是，国为串已经关闭
			// 如果出错了，直接读下次的
			m_port.async_read_some( boost::asio::buffer( m_read_buf_raw, SERIAL_PORT_READ_BUF_SIZE), 
				boost::bind( &SerialPort::on_receive_, this, 
					boost::asio::placeholders::error, 
					boost::asio::placeholders::bytes_transferred ) );
			return;
		}

可以确认：如果需要关闭后，重新打开同一个串口，最好的方法是，用新串口对象及新io_service对象.

	if(m_port) m_port.reset(); //在对应的服务重置前，先把旧的串口对象删除了（因为删除析构的时候，需要用到io_service）
	m_io_service.reset(new boost::asio::io_service());
	m_port.reset(new boost::asio::serial_port(*m_io_service));

		//FIX：下面这个顺序是否有问题？  不正确，这样串口仍补占用，未关闭. 先调用m_port->close()再关闭服务就可以了。
		if(m_io_service) m_io_service->stop();
		if(m_io_service_thread) m_io_service_thread->join();
		if(m_port) m_port->close();


m_io_service.reset(new boost::asio::io_service);
new boost::asio::io_service 后面需要添加括号吗？

最近需要x取及DQUSB devices的模式，用到SetupDi****相P的API，@些API都是放在setupapi.he，找了很久，在W路上也有人提到，但都是片面的，也都分散在不同的地方，F在我就⑵湔合放在我自己的Bloge，@酉麓我用也不忘。@一MAPI是Microsoft PlatformSDK提供的，路揭苍VSe

// Open a handle to the serial port.
  ::HANDLE handle = ::CreateFileA(name.c_str(),
      GENERIC_READ | GENERIC_WRITE, 0, 0,
      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
  if (handle == INVALID_HANDLE_VALUE)
  {
    DWORD last_error = ::GetLastError();
    ec = boost::system::error_code(last_error,
        boost::asio::error::get_system_category());
    return ec;
  }
  
  	if(m_port) {
		m_port->stop();
		//m_port.reset();
	}
	m_service.stop();    先停止了SERVICE,再调用串口对象的关闭函数,关闭是无效的。
	if(m_comrev_thread) m_comrev_thread->join();
	
SerialPort 对象重新打开，最好的方法，是创建新的对象。同时其对应的SERVICE也需要，创建新的对象。




---------------------------------------------------------------------------

通用唯一识别码（英语：Universally Unique Identifier，简称UUID）是一种软件建构的标准，亦为自由软件基金会组织在分散式计算环境领域的一部份。
UUID的目的，是让分散式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定
一组UUID，是由一串16位组（亦称128位）的16进位数字所构成，是故UUID理论上的总数为216 x 8=2128，约等于3.4 x 1038。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完
UUID的标准型式包含32个16进位数字，以连字号分为五段，形式为8-4-4-4-12的32个字符。示例：
550e8400-e29b-41d4-a716-446655440000





---------------------------------------------------------------------------
【boost::iostream】http://stackoverflow.com/questions/4961155/boostiostream-zlib-compressing-multiple-files-into-one-archive
boost::iostream zlib compressing multiple files into one archive
The zlib Filters depend on the third-party zlib library, which is not included in the Boost distribution. Prebuilt zlib binaries are available on most UNIX and UNIX-like systems, and will be found automatically by the Boost build system. Windows users can obtain prebuilt binaries at the zlib homepage. Users can also configure the Boost Iostream library to build zlib from the source code, which is available at the zlib homepage. For details on configuring the build system to find your zlib installation, please see Installation
---------------------------------------------------------------------------
【chrono】
boost::this_thread::sleep_for(boost::chrono::milliseconds(500));
误写成了
boost::this_thread::sleep_for(boost::chrono::microseconds(500));
导致线程，占用过多CPU。       



---------------------------------------------------------------------------
【date_time】
boost ptime
http://remonstrate.wordpress.com/2011/07/03/boost-%E7%9A%84-date_time/

ptime -> utc 一个整数
ptime -> string

boost::gregorian::to_iso_wstring( time_.date() );
boost::posix_time::to_iso_wstring( iter->time() )

boost::date_time 的时间 -> 字符串的转换
                 字符串 -> 时间的转换

		CPositionData tmp(x, y, boost::posix_time::ptime::is_not_a_date_time); 这句话是错的，为什么？ 
		CPositionData tmp(x, y, boost::posix_time::not_a_date_time); 这个是正确的

时间点构造
tmp.time = boost::posix_time::microsec_clock::local_time();
ptime d3(not_a_date_time);

时长构造
tmp.duration = tmp.time - tmp.time;  构造时间段  tmp.duration = boost::posix_time::time_duration(0, 0, 0, 0);

using namespace boost::posix_time;
time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds

using namespace boost::posix_time;      
time_duration td = hours(1) + seconds(10); //01:00:01
td = hours(1) + nanoseconds(5); //01:00:00.000000005

Syntax	Description
Example
time_duration(hours,
              minutes,
              seconds,
              fractional_seconds)
Construct a duration from the counts. The fractional_second parameter is a number of units and is therefore affected by the resolution the application is compiled with (see Build-Compiler Information). If the fractional_seconds argument exceeds the limit of the compiled precision, the excess value will be "carried over" into the seconds field. See above for techniques to creating a resolution independent count.
time_duration td(1,2,3,9);
//1 hr 2 min 3 sec 9 nanoseconds
time_duration td2(1,2,3,123456789);
time_duration td3(1,2,3,1000);
// with microsecond resolution (6 digits)
// td2 => "01:04:06.456789"
// td3 => "01:02:03.001000"
// with nanosecond resolution (9 digits)
// td2 => "01:02:03.123456789"
// td3 => "01:02:03.000001000"
time_duration(special_value sv)
Special values constructor. Important note: When a time_duration is a special value, either by construction or other means, the following accessor functions will give unpredictable results:
hours(), minutes(), seconds(), ticks(), 
fractional_seconds(), total_nanoseconds(),
total_microseconds(), total_milliseconds(),
total_seconds()
The remaining accessor functions will work as expected.

std::string to_simple_string(time_duration)
To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.
10:00:01.123456789
std::string to_iso_string(time_duration)
Convert to form HHMMSS,fffffffff.
100001,123456789

time_duration td(1,2,3, 1000);
td.fractional_seconds(); // --> 1000

posix time  字符串时间格式
simple_string                  2012-12-12 10:12:22
iso_string                        20121212T101222
to_iso_extended_string
 //! Allows expression of durations as milli seconds
  /*! \ingroup time_basics
   */
  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;
  //! Allows expression of durations as micro seconds
  /*! \ingroup time_basics
   */
  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
注意其中的断续关系
 class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };



boost::local_time::time_zone_ptr tz( new boost::local_time::posix_time_zone( "MST+07" ) );
boost::local_time::local_date_time ltm = boost::local_time::local_sec_clock::local_time( tz);
会获取指定时区的 正确的当前时间。
http://stackoverflow.com/questions/6730422/boost-chrono-vs-boost-date-time
Boost.Chrono seems focused on dealing with time intervals[间隔时间 ['?ntevl]

]. 不关心，日期（大于小时的时间单位）。
http://en.cppreference.com/w/cpp/chrono  c++11 std::chrono 实现
时间区段  boost posix_time time_period 对象的，contains，方法：
如果是结束点，则返回FALSE
A period that is created with beginning and end points being equal, or with a duration of zero, is known as a zero length period. Zero length periods are considered invalid (it is perfectly legal to construct an invalid period). For these periods, the last point will always be one unit less that the begin point
指定的结束点，实际结束点，比指定结束时间点，小一个 time_count ()

bool contains(ptime)
True if ptime is within the period. Zero length periods cannot contain any points.
date d(2002,Jan,01);
ptime t1(d, seconds(10)); //10 sec after midnight
ptime t2(d, hours(10)); //10 hours after midnight
ptime t3(d, hours(2)); //2 hours after midnight
time_period tp(t1, t2); 
tp.contains(t3); // true
time_period tp2(t1, t1);
tp2.contains(t1); // false







格里历日期系统
boost::gregorian
boost/date_time/gregorian/gregorian_types.hpp
boost/date_time/gregorian/gregorian.hpp
boost::gregorian::date 是日期编程的主要接口
创建 date 的方法包括：从时钟读取当前日期，使用 日期迭代器，以及 日期算法或生成器
boost::gregorian::date 是保存为一个32位整数类型的
该类特别被设计为不含虚函数。这样的设计可以进行高效的运算，
以及处理大量日期时具有高效的内存使用率。
booost date_time   date 头文件
#include "boost/date_time/gregorian/gregorian.hpp" //include all types plus i/o
or
#include "boost/date_time/gregorian/gregorian_types.hpp" //no i/o just types
boost date_time time 头文件
#include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
or
#include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types
Gregorian [gr??g??r??n]  现行公历即格里历
boost 格式化时间字符串
#include "boost/date_time/posix_time/posix_time.hpp"
http://stackoverflow.com/questions/5018188/how-to-format-a-datetime-to-string-using-boost
http://stackoverflow.com/questions/1904317/c-boost-date-with-format-dd-mm-yyyy
time_facet *facet = new time_facet("%d-%b-%Y %H:%M:%S");
locale(cout.getloc()
宽字符版本？
std::string to_iso_string(ptime)  boost::posix_time::to_iso_wstring
from_iso_string(std::string)  没有宽字符版本
std::string FormatTime( void ) {
  static std::locale loc( std::cout.getloc(), new boost::posix_time::time_facet( "%Y%m%d_%H%M%S" ) );  // 可重重使用这个locale
  std::basic_stringstream<char> ss;
  ss.imbue( loc );
  ss << boost::posix_time::second_clock::local_time();
  return ss.str();
}
ptime d1(neg_infin);
ptime d2(pos_infin);
ptime d3(not_a_date_time);
ptime d4(max_date_time);
ptime d5(min_date_time);
boost::system_time

时间点(ptime)
ptime(date,time_duration)    日期 + 时间偏差  构建
ptime t1(date(2002,Jan,10),  time_duration(1,2,3));
ptime t2(date(2002,Jan,10),   hours(1)+nanosec(5));
ptime(ptime)  拷贝构建
ptime(special_values sv)  特殊时间点  not-a-date-time, max_date_time, and min_date_time  一些常量
ptime;  默认构建
从时钟返回的时间点
second_clock::local_time() / second_clock::universal_time()
microsec_clock::local_time() / microsec_clock::universal_time()
从字符串，time_t，FILETIME 构建 ptime
时间长度（time duration）
time_duration(hours, minutes, seconds,  fractional_seconds)
特殊时间函数(返回long值)
hours(), minutes(), seconds(), ticks(), fractional_seconds(),
total_nanoseconds(),total_microseconds(), total_milliseconds(),total_seconds()
time_duration td = hours(3);
时间段（Time Period） (开始结束时间)
date d(2002,Jan,01);
ptime t1(d, seconds(10)); //10 sec after midnight
ptime t2(d, hours(10)); //10 hours after midnight
time_period tp(t1, t2);
date d(2002,Jan,01);
ptime t(d, seconds(10)); //10 sec after midnight
time_period tp(t, hours(3));
时间迭代器
date d(2000,Jan,20);
ptime start(d);
ptime end = start + hours(1);
time_iterator titr(start,minutes(15)); //increment by 15 minutes
while (titr < end) {
titr ++;
}
本地时间 与 UTC 时间                精确度 （秒 、 微秒 (1/1000)）
A microsecond is equal to 1000 nanoseconds or 1/1,000 milliseconds.
ptime second_clock::local_time()               ptime t(second_clock::local_time());
ptime second_clock::universal_time()       ptime t(second_clock::universal_time())
ptime microsec_clock::local_time()           ptime t(microsec_clock::local_time());
ptime microsec_clock::universal_time()   ptime t(microsec_clock::universal_time());
Posix 时间系统

定义一个无调整的、分辨率为纳秒/微秒级的、具有稳定的计算特性的时间系统。如果是纳秒级精度的，则每个 ptime 使用96位的底层存储，而微秒级精度则每个 ptime 使用64位存储(详情请见 构建选项)。该时间系统使用格里历来实现时间表示中的日期部分
boost/date_time/posix_time/posix_time.hpp
boost/date_time/posix_time/posix_time_types.hpp
类 boost::posix_time::ptime 是处理时间点的主要接口
类 ptime 依赖于 gregorian::date，作为时间点的日期部分的接口
ptime(date,time_duration)
ptime(ptime)
ptime(special_values sv)
ptime time_from_string(std::string)
ptime from_iso_string(std::string)
ptime second_clock::local_time()
ptime second_clock::universal_time()
ptime microsec_clock::local_time()
ptime microsec_clock::universal_time()
std::string to_simple_string(ptime)   2002-Jan-01 10:00:01.123456789
std::string to_iso_string(ptime)  20020131T100001,123456789
std::string to_iso_extended_string(ptime)   2002-01-31T10:00:01,123456789
获取的 月份总是三个字母的缩写，怎么样获取正确的数字月份呢？
namespace pt = boost::posix_time;
pt::ptime now = pt::second_clock::local_time();
std::stringstream ss;
ss << static_cast<int>(now.date().month()) << "/" << now.date().day()
   << "/" << now.date().year();
std::cout << ss.str() << std::endl;
世界协调时间(Universal Time Coordinated,UTC),GPS 系统中有两种时间区分，一为UTC，另一为LT（地方时）两者的区别为时区不同，UTC就是0时区的时间，(LocalTime)地方时为本地时间，如北京为早上八点（东八区），UTC时间就为零点，时间比北京时晚八小时，以此计算即可
boost::posix_time::time_duration 是负责表示时间长度的基本类型
boost::posix_time::time_period 提供了对两个时间点间的范围的表示法

---------------------------------------------------------------------------

[filesystem]

#include <boost/filesystem.hpp>
std::string filename_noext;
filename_noext = boost::filesystem::path("D:\\files\\file.lua").stem().string().
const char* result_as_const_char = filename_noext.c_str();

获取当前进程的EXE文件所在路径。
http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
Some OS-specific interfaces:

Mac OS X: _NSGetExecutablePath() (man 3 dyld)
Linux: readlink /proc/self/exe
Solaris: getexecname()
FreeBSD: sysctl CTL_KERN KERN_PROC KERN_PROC_PATHNAME -1
FreeBSD if it has procfs: readlink /proc/curproc/file (FreeBSD doesn't have procfs by default)
NetBSD: readlink /proc/curproc/exe
DragonFly BSD: readlink /proc/curproc/file
Windows: GetModuleFileName() with hModule = NULL

To summarize:

On Unixes with /proc really straight and realiable way is to:

readlink("/proc/self/exe", buf, bufsize) (Linux)

readlink("/proc/curproc/file", buf, bufsize) (FreeBSD)

readlink("/proc/self/path/a.out", buf, bufsize) (Solaris)

On Unixes without /proc (i.e. if above fails):

If argv[0] starts with "/" (absolute path) this is the path.

Otherwise if argv[0] contains "/" (relative path) append it to cwd (assuming it hasn't been changed yet).

Otherwise search directories in $PATH for executable argv[0].

Afterwards it may be reasonable to check whether the executable isn't actually a symlink. If it is resolve it relative to the symlink directory.

This step is not necessary in /proc method (at least for Linux). There the proc symlink points directly to executable.

Note that it is up to the calling process to set argv[0] correctly. It is right most of the times however there are occasions when the calling process cannot be trusted (ex. setuid executable).

On Windows: use GetModuleFileName(NULL, buf, bufsize)

boost 提出EXE当前路径
boost 从文件路径里提出 文件名，及路径

filesystem::path 类的成员
// decomposition 分解
        path  root_name() const;
        path  root_directory() const;
        path  root_path() const;
        path  relative_path() const;
        path  parent_path() const;
        path  filename() const;
        path  stem() const;
        path  extension() const;
		
 // query
        bool empty() const;
        bool has_root_name() const;
        bool has_root_directory() const;
        bool has_root_path() const;
        bool has_relative_path() const;
        bool has_parent_path() const;
        bool has_filename() const;
        bool has_stem() const;
        bool has_extension() const;
        bool is_absolute() const;
        bool is_relative() const;

		
// modifiers
        void  clear();
        path& make_absolute(const path& base);
        path& make_preferred();  // ISO/IEC 9945: no effect. Windows: convert slashes to backslashes
        path& remove_filename();
        path& replace_extension(const path& new_extension = path());
        void  swap(path& rhs);


boost filesystem
常用函数 :
path p (argv[1]);
exists(p)
is_regular_file(p)
is_directory(p)
可以复制文件，文件夹，快捷方式
可以创建，删除：文件，文件夹
directory_iterator

explicit directory_iterator(const path& p);
directory_iterator() noexcept;  // creates the "end" iterator   唯一合法的，结束条件
recursive_directory_iterator  递归，所有子文件夹


在Windows平台下我们知道可以使用API函数GetModuleFileName来获取应用程序的路径。最近发现boost库也可以实现这个功能
http://blog.csdn.net/clever101/article/details/5822296
string fullpath = boost::filesystem::initial_path<boost::filesystem::path>().string();
boost::filesystem::initial_path Returns: current_path() as of the first call to initial_path()
boost::filesystem::current_path (获取的是当前(工作)路径)
The current path as returned by many operating systems is a dangerous global variable. It may be changed unexpectedly by a third-party or system library functions, or by another thread
http://stackoverflow.com/questions/1528298/get-path-of-executable
There is no cross platform way that I know. (没有跨平台的方法，用于获取程序所在路径)
For Linux: readlink /proc/self/exe
Windows: GetModuleFileName
http://stackoverflow.com/questions/5694190/boostfile-system-how-to-find-out-in-which-directory-your-executable-is
Do you mean the current working directory (en.wikipedia.org/wiki/Working_directory), or the actual directory where the executable lives?
However if you're on windows you can call GetModuleFileName to get the complete path of the executable and then use boost::filesystem to get the directory. ( see parent_path)
http://stackoverflow.com/questions/933850/how-to-find-the-location-of-the-executable-in-c
GetModuleFileName
第一个参数 _In_opt_  HMODULE hModule,
If this parameter is NULL,GetModuleFileName retrieves the path of the executable file of the current process
This function is useful for input idle detection.
BOOL WINAPI GetLastInputInfo(
 _Out_  PLASTINPUTINFO plii
);
typedef struct tagLASTINPUTINFO {
 UINT  cbSize;
 DWORD dwTime;  The tick count when the last input event was received.
                 DWORD WINAPI GetTickCount(void);

} LASTINPUTINFO, *PLASTINPUTINFO;



filesystem - Portable paths, iteration over directories, and other useful filesystem operations, from Beman Dawes
文件创建，复制，删除；文件夹创建删除等等操作。

---------------------------------------------------------------------------
【字符串转换】
UTF8 <-> UNICODE
Class template std::wstring_convert performs conversions between byte string std::string and wide string std::basic_string<Elem>, 
using an individual code conversion facet Codecvt. 
std::wstring_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. 
The standard facets suitable for use with std::wstring_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions

void test()
{
wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
string s8 = u8"This is a UTF8 string";
wstring s16 = converter.from_bytes(s8);
string s88 = converter.to_bytes(s16);
if (s8!=s88)
cerr <"Insane!\n";
}

string <-> number
to_string





---------------------------------------------------------------------------
【LOG】
<boost/log/utility/manipulators/dump.hpp>
dump binary data

http://www.boost.org/doc/libs/1_54_0/libs/log/doc/html/log/detailed/utilities.html
void on_receive(std::vector< unsigned char > const& packet)
{
   // Outputs something like "Packet received: 00 01 02 03 04 05 06 07 and 67 bytes more"
   BOOST_LOG(lg) << "Packet received: " << logging::dump(packet.data(), packet.size(), 8);
}
void process(std::vector< double > const& matrix)
{
   // Note that dump_elements accepts the number of elements in the matrix, not its size in bytes
   BOOST_LOG(lg) << "Matrix dump: " << logging::dump_elements(matrix.data(), matrix.size());
}

boost.log 全局类

            // In pure C++ this should never happen, since there cannot be two
            // different tag types that have equal type_infos. In real life it can
            // happen if the same-named tag is defined differently in two or more
            // dlls. This check is intended to detect such ODR violations. However, there
            // is no protection against different definitions of the logger type itself.
            throw_odr_violation(typeid(TagT), typeid(logger_type), *holder);
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT( log, boost::log::sources::logger_mt );
定义了一个结构体：log 是结构体的TAG名称。并不是简单的定义一个全局对象。
log::get 会创建一个LOGGER对象。这个对象是全局的。::get函数内部实现的线程的同步操作。
这个宏的定义里，学习type_info类型。
#include <boost/log/common.hpp>
#include <boost/log/sources/logger.hpp>
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT( log, boost::log::sources::logger_mt );

D:\project\3rdParty\boost_1_54_0\libs\log\example

BOOST的例子

http://www.csdn123.com/html/itweb/20130912/114957_114950_114945.htm
http://blog.csdn.net/karl_max/article/details/4972664
boost log 学习
和boost的其他类库一样，充分的发挥了C++的各种高级用法，命名参数、lamba表达式、函数编程。结果就是一大堆还不算太旧的编译器都无法编译，例如：MSVC 7.0 and older，GCC 4.0 and older。对其他库的依赖也很厉害，需要Boost.Filesystem, Boost.System, Boost.DateTime, Boost.Thread  and Boost.Regex，用户代码还必须启用RTTI
---------------------------------------------------------------------------
[线程]

线程同步：
互斥体的类型  锁的类型
        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;

boost condition(创建，销毁，发送信号，等待锁+条件) 、 mutex+lock , 

Differences between <semaphore.h> and <sys/sem.h>
<sys/sem.h> provides the interface for XSI (originally Unix System V) semaphores.
<semaphore.h> defines POSIX semaphores, which are designed in such a way that they can be implemented entirely in userspace, except in the contended case where the process will call into the kernel to go to sleep. 

信号量（英语：Semaphore）又称为号志，它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待（busy waiting）的一种方法。
信号量的概念是由荷兰计算机科学家艾兹格・迪杰斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。

计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。
运作方式：
初始化，给与它一个非负数的整数值。
运行 P（wait()），信号量S的值将被减少。企图进入临界区段的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区段。
运行 V（又称signal()），信号量S的值会被增加。退出离开临界区段的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。


多线程同步方式
http://www.boost.org/doc/libs/1_54_0/doc/html/thread/synchronization.html#thread.synchronization.barriers

A barrier is a simple concept. Also known as a rendezvous, it is a synchronization point between multiple threads. The barrier is configured for a particular number of threads (n), and as threads reach the barrier they must wait until all n threads have arrived. Once the n-th thread has reached the barrier, all the waiting threads can proceed, and the barrier is reset

---------------------------------------------------------------------------

散列函数 -> 冗余检校验 -> 校验和 -> 循环冗余校验（CRC）
循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据数据包或电脑文件等数据产生简短固定位数校验码的一种散列函担主要用来检测或校验数据传输或者保存后可能出现的错误
生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化
一般来说，循环冗余校验的值都是32位的整数
它是由W. Wesley Peterson在他1961年发表的论文中披露
校验和（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或者时间（如计算机存储）传送的数据的完整性进行检查的一种简单方法。
计算机领域常见的校验和的方法有循环冗余校验（CRC）、MD5、SHA家族等
在通信领域中，冗余校验是消息中附加的用于错误检测与错误校正的数据。
任何一个散列函数都可以用于冗余检校验。最简单的冗余校验，叫作校验和，它包括校验位、校验码以及纵向冗余校验（LRC，en:longitudinal redundancy check）。其它类型的冗余校验包括循环冗余校验（CRC，cyclic redundancy check）、水平冗余校验、竖直冗余校验以及en:cryptographic message digest。
奇偶校验仅仅是一个错误检测的机制，根据所用奇校验与偶校验的不同可以检查偶数或者奇数的错误
奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数还是偶数的二进制数。奇偶校验位是最简单的错误检测码


 
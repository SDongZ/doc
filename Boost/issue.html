<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>使用BOOST遇到的问题</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="zh-CN" class="article"><div class="titlepage"><div><div><h2 class="title"><a name="id460645"></a>使用BOOST遇到的问题</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Xiang</span> <span class="surname">Wang</span></h3></div></div></div><hr></div><div class="toc"><p><b>目录</b></p><dl class="toc"><dt><span class="section"><a href="#id460651">使用BOOST遇到的问题</a></span></dt><dt><span class="section"><a href="#id460675">stdint.h(72): warning C4005: “INT8_MIN”: 宏重定义</a></span></dt><dt><span class="section"><a href="#id460748">BOOST编译</a></span></dt><dt><span class="section"><a href="#id460979">header.hpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</a></span></dt><dt><span class="section"><a href="#id461355">LOG 宽字符版本</a></span></dt><dt><span class="section"><a href="#id461389">boost::log::keywords::file_name = log_file 指定的文件无法创建的问题</a></span></dt><dt><span class="section"><a href="#id461478">boost互斥体的用法</a></span></dt><dt><span class="section"><a href="#id461496">boost thread obj 析构 不能使 线程退出</a></span></dt><dt><span class="section"><a href="#id461561">boost智能指针的用法</a></span></dt><dt><span class="section"><a href="#id461573">boost::asio 读串口 USB转的串口的区别(CC2431定位时)</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id460651"></a>使用BOOST遇到的问题</h2></div></div></div><p>使用BOOST遇到的问题</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id460675"></a>stdint.h(72): warning C4005: “INT8_MIN”: 宏重定义</h2></div></div></div><p>解决方法：在stdafx.h文件头添加 </p><pre class="programlisting">

#define _INTSAFE_H_INCLUDED_
#include &lt;stdint.h&gt;

	</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id460748"></a>BOOST编译</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">bootstrap.bat 生成BOOST构建引擎 b2.exe</li><li class="listitem">b2 --show-libraries 显示所有需要编译的库</li><li class="listitem">b2 toolset==msvc-10.0 --with-log 编译指定的库，并且指定toolset</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id460979"></a>header.hpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</h2></div></div></div><p>使用notepad++ 找到非法字符并去掉, 使用正则表达式查找 [^\x00-\x7F]。我遇到的非法字符是 '’' </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461355"></a>LOG 宽字符版本</h2></div></div></div><p>LOG 宽字符版本  BOOST_LOG(SKLog::get()) &lt;&lt; L"启动程序"; 可编译,但运行时会出错</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461389"></a>boost::log::keywords::file_name = log_file 指定的文件无法创建的问题</h2></div></div></div><p>boost::log::keywords::file_name = log_file 指定的文件无法创建的问题</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461478"></a>boost互斥体的用法</h2></div></div></div><p>头文件boost/thread/mutex.hpp boost::mutex m_mutex; boost::mutex::scoped_lock lock(m_mutex);</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461496"></a>boost thread obj 析构 不能使 线程退出</h2></div></div></div><p>
线程: 是io_service::run
注意，这个智能指针析构时，也不会退出线程，用reset(),置空，也不能退出线程。
最后调用io_service::stop，来结束的。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461561"></a>boost智能指针的用法</h2></div></div></div><pre class="programlisting">
下面这段代码的错在那里？
boost::scoped_ptr&lt;boost::thread&gt; m_comrev_thread;
m_comrev_thread = new boost::thread(boost::bind(&amp;CLocationDlg::ComRevThread, this));

应该这样写
this-&gt;thr.reset(new boost::thread(boost::ref(*this-&gt;proc)));
	</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id461573"></a>boost::asio 读串口 USB转的串口的区别(CC2431定位时)</h2></div></div></div><p>open close  cancel 都会引起串口读事件。 USB转的会一直读，没有异步IO机制（可能与驱动有关）。
	关闭与读取之间不用互斥来保护boost::asio::serial_port对象？</p><p>在做CC2431时，与USB转的串口通信时，关闭串口的时候死锁它与正常串的区别是：会不停的发出异步读命令（可能与驱动有关）。可能的原因：m_serial_port.close  等待驱动返回停止信号。驱动发出的读命令，又被m_serial_port.close的互斥休，锁住了。</p></div></div></body></html>

You need to use GetWindowRect instead of GetClientRect.

The client rect only includes the client area which is the non windows elements (such as border) of the window.

SetWindowPos MoveWidnow的区别?
The MoveWindow and SetWindowPos functions are similar; 
both set the size or position of a single application window. 
The SetWindowPos function includes a set of flags that affect the window's show state; 
MoveWindow does not include these flags. 
Use the BeginDeferWindowPos, DeferWindowPos, and EndDeferWindowPos functions to simultaneously set the position of a number of windows, 
including the size, position, position in the z-order, and show state.

How to get size and location of a control placed on a dialog in MFC?
CRect rect;
CWnd *pWnd = pDlg->GetDlgItem(YOUR_CONTROL_ID);
pWnd->GetWindowRect(&rect);
pDlg->ScreenToClient(&rect); //optional step - see below

//position:  rect.left, rect.top
//size: rect.Width(), rect.Height()
GetWindowRect gives the screen coordinates of the control. pDlg->ScreenToClient will then convert them be relative to the dialog's client area, which is usually what you need.

Note: pDlg above is the dialog. If you're in a member function of the dialog class, just remove the pDlg->.


CButton  bitmap icon
BM_SETIMAGE message
Associates a new image (icon or bitmap) with the button.
Parameters

wParam
The type of image to associate with the button. This parameter can be one of the following values:
IMAGE_BITMAP
IMAGE_ICON
lParam
A handle (HICON or HBITMAP) to the image to associate with the button.

The appearance of text, an icon, or both on a button control depends on the BS_ICON and BS_BITMAP styles, and whether the BM_SETIMAGE message is called. The possible results are as follows:
BS_ICON or BS_BITMAP Set?	BM_SETIMAGE Called?	Result
Yes	Yes	Show icon only.
No	Yes	Show icon and text.
Yes	No	Show text only.
No	No	Show text only

The GetStockObject function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.fnObject [in]
The type of stock object. This parameter can be one of the following values.
Value	Meaning
BLACK_BRUSH
Black brush.
DKGRAY_BRUSH
Dark gray brush.
DC_BRUSH
Solid color brush. The default color is white. The color can be changed by using the SetDCBrushColor function. For more information, see the Remarks section.
GRAY_BRUSH
Gray brush.
HOLLOW_BRUSH
Hollow brush (equivalent to NULL_BRUSH).
LTGRAY_BRUSH
Light gray brush.
NULL_BRUSH
Null brush (equivalent to HOLLOW_BRUSH).
WHITE_BRUSH
White brush.
BLACK_PEN
Black pen.
DC_PEN
Solid pen color. The default color is white. The color can be changed by using the SetDCPenColor function. For more information, see the Remarks section.
NULL_PEN
Null pen. The null pen draws nothing.
WHITE_PEN
White pen.
ANSI_FIXED_FONT
Windows fixed-pitch (monospace) system font.
ANSI_VAR_FONT
Windows variable-pitch (proportional space) system font.
DEVICE_DEFAULT_FONT
Device-dependent font.
DEFAULT_GUI_FONT
Default font for user interface objects such as menus and dialog boxes. It is not recommended that you use DEFAULT_GUI_FONT or SYSTEM_FONT to obtain the font used by dialogs and windows; for more information, see the remarks section.
The default font is Tahoma.
OEM_FIXED_FONT
Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font.
SYSTEM_FONT
System font. By default, the system uses the system font to draw menus, dialog box controls, and text. It is not recommended that you use DEFAULT_GUI_FONT or SYSTEM_FONT to obtain the font used by dialogs and windows; for more information, see the remarks section.
The default system font is Tahoma.
SYSTEM_FIXED_FONT
Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0.
DEFAULT_PALETTE
Default palette. This palette consists of the static colors in the system palette.

/* Stock Logical Objects */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16

#if(WINVER >= 0x0400)
#define DEFAULT_GUI_FONT    17
#endif /* WINVER >= 0x0400 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
#define DC_BRUSH            18
#define DC_PEN              19
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
#define STOCK_LAST          19
#elif (WINVER >= 0x0400)
#define STOCK_LAST          17
#else
#define STOCK_LAST          16
#endif

#define CLR_INVALID     0xFFFFFFFF

更改编辑框的字体
CWindow::SetFont
Changes the window's current font by sending a WM_SETFONT message to the window.

由StockObject font 创建一个CFont  m_Font.Attach(GetStockObject(DEFAULT_GUI_FONT)); 
stock font size 
CFont *m_pFont = new CFont;
m_pFont->CreateFont(...);
myEdit->SetFont(m_pFont);

GetDlgItem(IDC_EDIT1)->SetFont(&m_editFont);

void makebold(HWND hwnd)
{
	HFONT hFontB,hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	LOGFONT lf;
	GetObject(hFont, sizeof(LOGFONT), &lf);
	lf.lfWeight = FW_BOLD;
	hFontB = CreateFontIndirect(&lf);
	SendMessage(hwnd,WM_SETFONT,(int)hFontB,1);
}

To change the font: WM_SETFONT.
To change the back color: WM_CTLCOLOREDIT.

CComboBox:: 添加在后面
m_serial_port_cbox.AddString(L"COM1");
m_serial_port_cbox.AddString(L"COM2");
m_serial_port_cbox.AddString(L"COM3");
m_serial_port_cbox.AddString(L"COM4");
m_serial_port_cbox.AddString(L"COM5");
m_serial_port_cbox.AddString(L"COM6");
m_serial_port_cbox.AddString(L"COM7");
CComboBox:: 获取当前编辑框的文本
	CString cur_port;
	m_serial_port_cbox.GetWindowText(cur_port);


/*
 * MessageBox() Flags
 */
#define MB_OK                       0x00000000L
#define MB_OKCANCEL                 0x00000001L
#define MB_ABORTRETRYIGNORE         0x00000002L
#define MB_YESNOCANCEL              0x00000003L
#define MB_YESNO                    0x00000004L
#define MB_RETRYCANCEL              0x00000005L
#if(WINVER >= 0x0500)
#define MB_CANCELTRYCONTINUE        0x00000006L
#endif /* WINVER >= 0x0500 */


#define MB_ICONHAND                 0x00000010L
#define MB_ICONQUESTION             0x00000020L
#define MB_ICONEXCLAMATION          0x00000030L
#define MB_ICONASTERISK             0x00000040L

#if(WINVER >= 0x0400)
#define MB_USERICON                 0x00000080L
#define MB_ICONWARNING              MB_ICONEXCLAMATION
#define MB_ICONERROR                MB_ICONHAND
#endif /* WINVER >= 0x0400 */

#define MB_ICONINFORMATION          MB_ICONASTERISK
#define MB_ICONSTOP                 MB_ICONHAND

#define MB_DEFBUTTON1               0x00000000L
#define MB_DEFBUTTON2               0x00000100L
#define MB_DEFBUTTON3               0x00000200L
#if(WINVER >= 0x0400)
#define MB_DEFBUTTON4               0x00000300L
#endif /* WINVER >= 0x0400 */

#define MB_APPLMODAL                0x00000000L
#define MB_SYSTEMMODAL              0x00001000L
#define MB_TASKMODAL                0x00002000L
#if(WINVER >= 0x0400)
#define MB_HELP                     0x00004000L // Help Button
#endif /* WINVER >= 0x0400 */

#define MB_NOFOCUS                  0x00008000L
#define MB_SETFOREGROUND            0x00010000L
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L

#if(WINVER >= 0x0400)
#define MB_TOPMOST                  0x00040000L
#define MB_RIGHT                    0x00080000L
#define MB_RTLREADING               0x00100000L

#endif /* WINVER >= 0x0400 */

#ifdef _WIN32_WINNT
#if (_WIN32_WINNT >= 0x0400)
#define MB_SERVICE_NOTIFICATION          0x00200000L
#else
#define MB_SERVICE_NOTIFICATION          0x00040000L
#endif
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

#define MB_TYPEMASK                 0x0000000FL
#define MB_ICONMASK                 0x000000F0L
#define MB_DEFMASK                  0x00000F00L
#define MB_MODEMASK                 0x00003000L
#define MB_MISCMASK                 0x0000C000L


下面这段代码的错在那里？
boost::scoped_ptr<boost::thread> m_comrev_thread;
m_comrev_thread = new boost::thread(boost::bind(&CLocationDlg::ComRevThread, this));

应该这样写
this->thr.reset(new boost::thread(boost::ref(*this->proc)));

线程: 是io_service::run
注意，这个智能指针析构时，也不会退出线程，用reset(),置空，也不能退出线程。
最后调用io_service::stop，来结束的。

批处理：当前目录的写法？
%0代指批处理文件自身
%~d0 是指批处理所在的盘符
%~dp0 是盘符加路径 
cd %~dp0 就是进入批处理所在目录了

set service_exe=%1 指处理=号，两边不能加空格

批处理：“点击任意键退出”  
pause   这一句会提示，“请按任意键继续. . .”
exit

printf 里的类型转换，下面这里(unsigned char)data[i]，如不强制转换
会出出错，会当成有符号整数, 转成很大的十六进制字符串。

void CLocationDlg::RevData(std::string &data) {
	wchar_t word[8] = {0};
	for(int i = 0; i < data.length(); i++) {
		swprintf_s(word, 8, L"%02X", (unsigned char)data[i]);
		word[3] = 0;
		m_com_string += word;
	}
}


std::list
back() 返回最后一个元素 
front() 返回第一个元素 
pop_back() 删除最后一个元素 
pop_front() 删除第一个元素 
push_back() 在list的末尾添加一个元素 
push_front() 在list的头部添加一个元素 

std::string
append() 在字符串的末尾添加文本 (可添加字符（可指定重复添加字符个数），字符串)

string str1, str2 = "War and Peace";
str1.assign( str2, 4, 3 );  为字符串赋新值 
cout << str1 << endl;

std::string::at() 按给定索引值返回字符 

关于字符串下面三个函数
std::string::empty() 如果字符串为空，返回真 
std::string::length() 返回字符串的长度 
std::string::size() 返回字符串中字符的数量 

iterator std::string::erase( iterator pos ); 返回指向下一个字符的迭代器
iterator std::string::erase( iterator start, iterator end ); 返回指向下一个字符的迭代器
basic_string &std::string::erase( size_type index = 0, size_type num = npos ); 
如果不加参数，将会把字符串全部删除
如果只指定index, 删除index及其后的所有字符

std::string::data() 返回内容的字符数组形式 
std::string::size_type copy( char *str, size_type num, size_type index );
copy()函数拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数


std::string::swap()函数把str和本字符串交换。例如：

    string first( "This comes first" );
    string second( "And this is second" );
    first.swap( second );
    cout << first << endl;
    cout << second << endl;

显示：

    And this is second
    This comes first


std::string::reserve() 保留一定容量以容纳字符串（设置capacity值） 

basic_string std::string::substr( size_type index, size_type num = npos );



 
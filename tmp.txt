【把其它几个地方的内容全整理过来】
QQ备忘录，baidu云盘，GOOGLE-DOC（其它文档）

有七年C\C++语言开发经验，主要使用VisualStudio开发工具，在Windows平台开发视频类软件。熟悉STD与BOOST库。了解Windows的COM组件技术（刻录，OFFICE开发，WindowsMediaSDK，WebBrowser）。熟悉WINDOWS消息机制，及界面控件绘制过程。

其它平台开发经验：
MAC下编译修改FFMPEG程序。
UBUNTU下修改SPICE客户端程序。

逻辑层（水层），低层模块。

参与过的项目
全自动高清课堂录播系统
数据化校园客户端软件
Windows系统还原管理软件
银行理财产品录音系统

云游戏服务器端管理程序

蓝光DVD复制软件。
DVD制作刻录软件。
音视格式转换软件。

有项目管理经验。


这个求职者叫Andrew Collier，他在Elance简历上称自己是数据科学家，期望自己的工资最低为25美元一小时。他称自己可以完成机器学习、建模、数据分析和可视化等相关的工作
【】baidu account sdwx83 / wangxiangc@gmail.com /y
【】teamviewer wangxiang/wangxiangc@gmail.com/godhd123
【】How to delete bunch of unwanted bookmarks in Google Chrome

C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Profile 1\Bookmarks
C:\Users\Administrator\AppData\Roaming\Google\Local Search History\google%2Eweb.w

C:\Users\Administrator\AppData\Local\Google\Chrome\User Data

Hi 

Inside of this folder c:\Documents and Settings\ 

LOOK FOR THIS ANOTHER FOLDER: 

Google\Chrome\User Data\Default\ 

DELETE THE "HISTORY" FILE THAT IS INSIDE OF "DEFAULT" FOLDER, AND THAT'S ALL.
【】托动图标的实现

【】代码片段是否要保留这个分类？

【google】
goagent 使用的账号
regcoupans@gmail.com	车G1	wangxiang83@gmail.com
goagent20120501|goagent20120502|goagent20120503|goagent20120504|goagent20120505

https://appengine.google.com  regcoupans@gmail.com(车G1)
APPID列表
goagent20120429|goagent20120430|goagent20120431|goagent20120432|goagent20120433
goagent20120501|goagent20120502|goagent20120503|goagent20120504|goagent20120505

http://www.samabox.com/projects/chrome/switchy/ - 安装
https://goagent.googlecode.com/files/SwitchyOptions.bak - 在线导入

上传服务器文件时，需要启动goagent

服务器上的版本 v2.1.11-60-g41459c4 - 20111231

【BOOST】
namespace boost
{
  namespace system
  {
    //  class system_error  ------------------------------------------------------------//

    class BOOST_SYMBOL_VISIBLE system_error : public std::runtime_error
    // BOOST_SYMBOL_VISIBLE is needed by GCC to ensure system_error thrown from a shared
    // library can be caught. See svn.boost.org/trac/boost/ticket/3697
    {
    public:
      system_error( error_code ec )
          : std::runtime_error(""), m_error_code(ec) {}

      system_error( error_code ec, const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( error_code ec, const char* what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( int ev, const error_category & ecat )
          : std::runtime_error(""), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const char * what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      virtual ~system_error() throw() {}

      const error_code &  code() const throw() { return m_error_code; }
      const char *        what() const throw();

    private:
      error_code           m_error_code;
      mutable std::string  m_what;
    };

    //  implementation  ------------------------------------------------------//

    inline const char * system_error::what() const throw()
    // see http://www.boost.org/more/error_handling.html for lazy build rationale
    {
      if ( m_what.empty() )
      {
#ifndef BOOST_NO_EXCEPTIONS
        try
#endif
        {
          m_what = this->std::runtime_error::what();
          if ( !m_what.empty() ) m_what += ": ";
          m_what += m_error_code.message();
        }
#ifndef BOOST_NO_EXCEPTIONS
        catch (...) { return std::runtime_error::what(); }
#endif
      }
      return m_what.c_str();
    }

  } // namespace system
} // namespace boost



std::string system_error_category::message( int ev ) const
  {
# ifndef BOOST_NO_ANSI_APIS  
    LPVOID lpMsgBuf = 0;
    DWORD retval = ::FormatMessageA( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        ev,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPSTR) &lpMsgBuf,
        0,
        NULL 
    );
    detail::local_free_on_destruction lfod(lpMsgBuf);
    if (retval == 0)
        return std::string("Unknown error");
        
    std::string str( static_cast<LPCSTR>(lpMsgBuf) );
# else  // WinCE workaround
    LPVOID lpMsgBuf = 0;
    DWORD retval = ::FormatMessageW( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        ev,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &lpMsgBuf,
        0,
        NULL 
    );
    detail::local_free_on_destruction lfod(lpMsgBuf);
    if (retval == 0)
        return std::string("Unknown error");
    
    int num_chars = (wcslen( static_cast<LPCWSTR>(lpMsgBuf) ) + 1) * 2;
    LPSTR narrow_buffer = (LPSTR)_alloca( num_chars );
    if (::WideCharToMultiByte(CP_ACP, 0, static_cast<LPCWSTR>(lpMsgBuf), -1, narrow_buffer, num_chars, NULL, NULL) == 0)
        return std::string("Unknown error");

    std::string str( narrow_buffer );
# endif
    while ( str.size()
      && (str[str.size()-1] == '\n' || str[str.size()-1] == '\r') )
        str.erase( str.size()-1 );
    if ( str.size() && str[str.size()-1] == '.' ) 
      { str.erase( str.size()-1 ); }
    return str;
  }
# endif

} // unnamed namespace

【BOOST】
m_pAcceptor = new tcp::acceptor(m_ioSrv, m_peer, false);
两个进程，监听同一个，TCP端口，会出现什么情况？抛出异常

【BOOST】
创建监听端口时，抛出异常：9090端口。 (现在遇到的问题是这个端口，不知道被那个进程打开了，找不到打开这个端口的进程。)

m_pAcceptor = new tcp::acceptor(m_ioSrv, m_peer, false); 创建这个时，抛出异常
bind: 通常每个套接字地址(协议/网络地址/端口)只允许使用一次

  basic_socket_acceptor(boost::asio::io_service& io_service,
      const endpoint_type& endpoint, bool reuse_addr = true)
    : basic_io_object<SocketAcceptorService>(io_service)
  {
    boost::system::error_code ec;
    const protocol_type protocol = endpoint.protocol();
    this->get_service().open(this->get_implementation(), protocol, ec);
    boost::asio::detail::throw_error(ec, "open");
    if (reuse_addr)
    {
      this->get_service().set_option(this->get_implementation(),
          socket_base::reuse_address(true), ec);
      boost::asio::detail::throw_error(ec, "set_option");
    }
    this->get_service().bind(this->get_implementation(), endpoint, ec);
    boost::asio::detail::throw_error(ec, "bind"); -------------------------这句抛出异常。
    this->get_service().listen(this->get_implementation(),
        socket_base::max_connections, ec);
    boost::asio::detail::throw_error(ec, "listen");
  }
  
  “断续”后，这个异常能够，过去。
  
 
我们在做socket的开发的时候，经常会遇到这个错误：通常每个套接字地址 (协议/网络地址/端口)只允许使用一次
错误指示很明确：通信端口被占用了，导致通信无法进行。
但为什么端口被占用了呢？什么端口被占用了？
这里其实有一个大前提：你的程序中有没有指定socket通信端口？
如果指定了，解决办法很简单，每次通信完成手动释放就行了。下次通信重新建立连接。
如果没有指定，说明以下几点（可能你命中的是其中一点）：
1、你的服务器开启的端口数太少；
2、连接释放等待时间太长；
3、你的socket通信并发量太大。
以上几点导致你服务器端口被占满，下次通信无空闲端口可用，程序就抛出了“通常每个套接字地址 (协议/网络地址/端口)只允许使用一次”的异常。

原因找到了，解决起来也就简单了，针对1、2两点，我们修改服务器配置就行了。
如果你的服务器是windows2003或xp，默认端口只开到5000，而且超时等待默认是240秒（这里有官方说明：http://msdn.microsoft.com/zh-cn/library/aa560610(v=bts.10).aspx），我们只需把服务器端口全打开，并且根据自己的情况调整超时时间。
具体操作：
1、打开注册表（运行命令：regedit）
2、找到注册表节点：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters
3、新增2项（如果已存在就修改项值），值对应的都是10进制数字
MaxUserPort=65534 （端口数设到最大）
TcpTimedWaitDelay=5 （超时等待是5秒，根据个人需要）
4、重启服务器

搞定！


你绑定的端口没有释放,需要等待一段时间,或者在程序退出时调用close关闭udp套接字
端口是非托管资源，你必须自行释放
所有非托管资源程序员必须能控制资源释放，诸如数据库连接，SOCKET连接等在使用后都应当显示关闭，如果是长连接，在程序退出时应当确保所有占用的连接都被关闭

【】
2011年12月8日 - 对于H.264（MPEG-4 AVC）而言，级别（Level）是与档次（Profile）同等重要的参数。

【VDUAUD】
vs_image_scale_nearest_Y

【BOOST】
boost::bind is a generalization of the standard functions std::bind1st and std::bind2nd. It supports arbitrary function objects, functions, function pointers, and member function pointers, and is able to bind any argument to a specific value or route（[英][ru:t] [美][rut, raʊt]） input arguments into arbitrary（[英][ˈɑ:bitrəri] [美][ˈɑrbɪˌtrɛri]随意的） positions. bind does not place any requirements on the function object; in particular, it does not need the result_type, first_argument_type and second_argument_type standard typedefs.


【想法】知道网址，知道图片名称，是不是可以获得其浏览器缓存中的图片？（HTTP，加载不用重新下载了？）(同一个浏览器可以，换个浏览器其缓存数据又变了)
【想法】安装包，文档资源等等怎么整理？
【想法】整理下，累积的文件。
【想法】代码中的注释全用英语，避免使用汉字
        INI -> 类 ->保存
【D2D】 把YUY2，格式的图片，显示在窗口上。
【DSHOW】 简单播放器
http://forum.videohelp.com/threads/292835-GraphStudio-open-source-update-of-GraphEdit

http://blog.monogram.sk/janos/tools/monogram-graphstudio/
svn co svn://dev.monogram.sk/public/graphstudio/trunk

http://blog.monogram.sk/janos/directshow-programming/ 

【MFC】
怎么防止，自定义消息，重复？
通过一个函数来获取，指定的消息。

【MFC】
EnumWindows(enumerator, reinterpret_cast<LPARAM>(&hWnd));

回调函数
To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.

BOOL CALLBACK CMCBackMgrApp::enumerator(HWND hWnd, LPARAM lParam)
{
DWORD result;
if (!SendMessageTimeout(hWnd, g_are_you_me_message_id, 0, 0, SMTO_BLOCK, 200, &result)  || result != g_are_you_me_message_id)
return true;
*reinterpret_cast<HWND*>(lParam) = hWnd;
return false;
}

EnumWindows function
Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.
Syntax

C++

BOOL WINAPI EnumWindows(
  _In_  WNDENUMPROC lpEnumFunc,
  _In_  LPARAM lParam
);

An application-defined callback function used with the EnumWindows or EnumDesktopWindows function. It receives top-level window handles. The WNDENUMPROC type defines a pointer to this callback function. EnumWindowsProc is a placeholder for the application-defined function name

【WH】
安装驱动时，出现下面的错误。（未找到解决方法）（基本确定应该是删除软件时，未删除干净，有些注册项未删除掉）
error 1406 could not write value

单击开始，单击运行，键入口令控制，，然后单击确定。
创建新的计算机管理员帐户。
单击开始，单击运行，键入regedit，然后单击确定
在注册表编辑器中，用鼠标右键单击HKEY_CURRENT_USER\Software，然后单击权限。
单击添加，键入所有人，然后单击确定。
在组或用户名称中，单击任何人。
在权限中，单击以选中允许列中的完全控制，然后单击确定。
找到下面的子项：读
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\Current Version\Setup
为每个子项，请执行以下步骤：
单击该子项。
删除InstanceComponentSet。#在右侧面板中的字符串值。请注意， # 是一个数字，然后此关键字的值是 {66563AD8-637B-407F-BCA7-0233A16891AB}。
注销，然后重新注册 Microsoft Windows Installer 服务。若要执行此操作，请执行以下步骤：
单击开始，然后单击运行，类型msiexec 注销 /，然后单击确定。
单击开始，单击运行，键入msiexec /regserver，，然后单击确定。
插入 Business Contact Manager 安装 CD，然后按照提示安装 Business Contact Manager。

安装采集卡驱动时的错误是，下面这项
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\Folders
数值名称是：C:\Windows\Installer\{C4549CC5-F7A9-4C71-8170-7C8F237E4E11}\

Could not write value AuthorizedCDFPrefix to key ... 
verify that you have sufficient([英][səˈfɪʃnt] [美][səˈfɪʃənt] 足够的) access to that key, or contact your support personnel([英][ˌpɜ:səˈnel] [美][ˌpɚsəˈnɛl]人员).

http://support.microsoft.com/kb/300451
安装软件时，会出现 Windows 安装错误 1406

错误 1406年。无法写入密钥 Software\Microsoft\Windows\CurrentVersion\Installer\InProgress 值文件夹。请验证您具有足够的权限访问该密钥或技术支持人员的联系人

http://www.justanswer.com/computer/4vh32-running-windows-7-recently-tried-upgrade-program.html
Yesterday, when trying to reason through what was going on, it seemed to me that there might be an issue with the uninstall, given the nature of the message. I started an uninstall program that I have and, sure enough, even though the old program no longer showed on my list of available programs on my computer, it did show on the list of installed programs in my uninstall program. When I ran a deep level uninstall, it removed the program and showed that there were over two thousand related registry keys still installed. I had the program remove those. After that, the new program installed very easily and is now functioning fine. So, that seems to have been the program.
是因为旧程序没有删除干净

【VC】
Microsoft Visual Studio Ultimate 2013有效序列号：
BWG7X-J98B3-W34RT-33B3R-JVYW9
Ultimate:
BWG7X-J98B3-W34RT-33B3R-JVYW9
Premium:
FBJVC-3CMTX-D8DVP-RTQCT-92494

【API】
void CShowAnotherDlg::FindMultiMonitors()
{
	int i = 0;
	DISPLAY_DEVICE displayDevice;
	ZeroMemory(&displayDevice,sizeof(displayDevice));
	displayDevice.cb = sizeof(displayDevice);
	map<int,PDISPLAY_DEVICE> mapDevice;
	while(EnumDisplayDevices(NULL,i,&displayDevice,0)){		
		i++;
	}
	HMONITOR hWndMonitor = MonitorFromWindow(GetSafeHwnd(), MONITOR_DEFAULTTOPRIMARY);
	MONITORINFOEX monitorInfo;
	if (hWndMonitor == NULL) return;
	monitorInfo.cbSize = sizeof(MONITORINFOEX);
	GetMonitorInfo(hWndMonitor, &monitorInfo);
	MoveWindow(monitorInfo.rcMonitor.right,0,1000,200);
	return;
}

【MFC】
ON_REGISTERED_MESSAGE和ON_MESSAGE区别
on_message用于处理一切消息，但是on_registered_message只用处理在系统已经注册过的消息。    
The RegisterWindowMessage function is used to define a new window message that is guaranteed to be unique throughout the system.
The macro ON_REGISTERED_MESSAGE is used to handle these messages. This macro accepts a name of a UINT NEAR variable that contains the registered windows message ID.

ON_REGISTERED_MESSAGE也可以从类向导里添加

LPCTSTR temp = theApp.m_lpCmdLine;
	hMutex=CreateMutex(NULL,FALSE,_T("MCBACKMGR-XL231-OKuA23-LIUQIANG-31PL2S-ASSS#225"));
	if (GetLastError() == ERROR_ALREADY_EXISTS){
		HWND hWnd = NULL;
		EnumWindows(enumerator, reinterpret_cast<LPARAM>(&hWnd));
		if (_wcsnicmp(temp,_T("Close"),5) == 0){
			::SendMessage(hWnd,MGR_SIGN_OUT,0,0);
		}else if (_wcsnicmp(temp,_T("Mgr_login"),9) == 0){
			::SendMessage(hWnd,MGR_LOGIN,0,0);		
		}else if(_wcsnicmp(temp,_T("Mgr_quit"),8) == 0){
			::SendMessage(hWnd,CHILD_IN,0,0);
		}
		return FALSE;
	}
BOOL CALLBACK CMCBackMgrApp::enumerator(HWND hWnd, LPARAM lParam)
{
	DWORD result;
	if (!SendMessageTimeout(hWnd, g_are_you_me_message_id, 0, 0, SMTO_BLOCK, 200, &result)
		|| result != g_are_you_me_message_id)
		return true;
	*reinterpret_cast<HWND*>(lParam) = hWnd;
	return false;
}
const extern UINT g_are_you_me_message_id = RegisterWindowMessage(_T("MCBACKMGR Are You Me Message"));
ON_REGISTERED_MESSAGE(g_are_you_me_message_id, OnAreYouMe)
long CMCBackMgrDlg::OnAreYouMe(WPARAM, LPARAM)
{
	return g_are_you_me_message_id;
}
刘强 2014-3-12 18:09:43
const extern UINT g_are_you_me_message_id;


【VC】
>C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\Platforms\Win32\Microsoft.Cpp.Win32.Targets(518,5): error MSB8008: 指定的平台工具集(v110)未安装或无效。请确保选择受支持的 PlatformToolset 值

如果是VS2010环境，指定的平台工具集(v110) -->该参数修改为V100.
修改方法：
Project > Properties > Configuration Properties > General (General) > Platform Toolset >> v100

[VIDAUD]
Chroma subsampling  色度抽样

H264支持的色度抽样有
Support of monochrome (4:0:0), 4:2:0, 4:2:2, and 4:4:4 chroma subsampling (depending on the selected profile)

【BOOST】
exception - A library for transporting of arbitrary data in exception objects, and transporting of exceptions between threads (N2179), from Emil Dotchevski.

【D2D】
视频硬解api介绍
　　在一个gpu如此强大的时代，视频解码怎么能少了gpu厂商的参加。为了用硬件加速视频解码，厂商定义了一些api。

　　好吧，一旦和硬件打交道，就会有os的参加，有了硬件与os参加，api肯定会变成很凌乱，看了一点代码，一些wiki，一些文档，写个总结，希望真正的专家斧正一下。

 

windows平台：

　　微软一家说了算，硬件都是小弟。所以api没那么凌乱。就一种

　　DXVA（directx video acceleration)，两个版本，1.0和2.0
【D2D】
Direct3D 9.0 added a new version of the High Level Shader Language,[6] support for floating-point texture formats, Multiple Render Targets, and texture lookups in the vertex shader.
Windows Vista includes a major update to the Direct3D API. Originally called WGF 2.0 (Windows Graphics Foundation 2.0), then DirectX 10 and DirectX Next, Direct3D 10 features an updated shader model 4.0 and optional interruptibility for shader programs.
Direct3D 10.1 was announced by Microsoft shortly after the release of Direct3D 10 as a minor update
Direct3D 11 was released as part of Windows 7
Direct3D 11.1 is an update to the API that ships with Windows 8.
Direct3D 11.2 was shipped with Windows 8.1


StretchRect...果然和文档上说的一样
分类： WaterDrops 2010-09-28 22:54 712人阅读 评论(0) 收藏 举报
文档
存侥幸心理看看能不能从depthbuffer上copy到一个create出来的texture[英]['tekstʃə(r)] [美][ˈtɛkstʃɚ]里。
结果失败，还得按照这里来用INTZ格式来为g80显卡来做texturize的surface。

There is no DX10 version of that function（StretchRect）. Copying resources requires that the source and destination size matches. What you can do is render a texture using a quad to a smaller render target

【STD】
C C++ 定义函数类型的问题？  http://blog.jobbole.com/44639/
typedef QRETURN (QCAP_EXPORT *PF_NO_SIGNAL_DETECTED_CALLBACK)( PVOID pDevice /*IN*/, ULONG nVideoInput /*IN*/, ULONG nAudioInput /*IN*/, PVOID pUserData /*IN*/ );
AFX_EXT_API QRESULT QCAP_EXPORT QCAP_REGISTER_VIDEO_PREVIEW_CALLBACK( PVOID pDevice /*IN*/, PF_VIDEO_PREVIEW_CALLBACK pCB /*IN*/, PVOID pUserData /*IN*/ );

传函数指针的时候，函数名称前面，需要加地址符吗？
其一，函数名会被隐式的转换为函数指针，就像作为参数传递的时候，数组名被隐式的转换为指针一样。在函数指针被要求当作输入的任何地方，都能够使用函数名。其二，解引用符*和取地址符&用在函数名之前基本上都是多余的

类的成员函数指针，需要加地址符

static ,静态成员函数，定义的时候还要写吗？不需要写

【WH】批处理清楚浏览器所有信息（书签，历史，COOCKIE）

【D2D】
Microsoft DirectX Graphics Infrastructure
微软DirectX图形基础设施

DirectX Graphics Infrastructure (DXGI) is a user-mode component of Windows Vista and above which provides a mapping between particular graphics APIs such as Direct3D 10.0 and above (known in DXGI parlance as producers) and the graphics kernel, which in turn interfaces with the user-mode Windows Display Driver Model driver. DXGI provides objects to handle tasks such as enumerating graphics adapters and monitors, enumerating display modes, choosing buffer formats, sharing resources between processes (such as between applications and the Desktop Window Manager), and presenting rendered frames to a window or monitor for display.
Both Direct3D 10 and OpenGL applications in Windows Vista work through DXGI.

纹理，通俗的说就是贴图（比如说使命召唤都是贴图堆起来的，那说的即是纹理），再通俗一点，就是一张张图片。但是这么说又太片面了，事实上，纹理可以分成一维纹理，二维纹理，三维纹理

shader 
已添加
简明释义
n.著色器；着色程序

【WINAPI】事件，通知状态问题（自动与手动的理解）


【MFC】
如果最小化状态，就把窗口，显示到前面来。
实现，类似，鼠标点击，任务栏中，程序，的效果。SC_RESTORE
if( ::IsIconic( wnd ) ) {
							SendMessage( wnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
						}

【MFC】共享内存，内存映射，
创建一块共享内存，存入，当前进程的ID

MFC没有封装这个功能。自定义一个共享内存类
CMemMapFile v1.58 A C++/ATL class to encapsulate Memory Mapped Files
http://www.naughter.com/memmap.html

【MFC】理解CWinApp

【MFC程序接收命令行参数？】

1、GetCommandLine() 获取输入的所有信息，包括程序所在路径及参数

2、AfxGetApp()->m_lpCmdLine 只包含参数  CWinApp::m_lpCmdLine

一般情况下，获取到命令行后就可以针对命令行中的内容进行相应的处理了


BOOL CImageTrackingApp::InitInstance()
{
	LPWSTR cmd = GetCommandLine();
返回值是下面这个样子：
"D:\project\trunk\src\client\ImageTracking\..\..\..\bin\Debug\ImageTracking.exe" start

How to get the command line arguments in mfc applications?
Use GetCommandLine(), which returns the name of the file being executed, followed by the arguments.

The application member m_lpCmdLine ie. yourApp.m_lpCmdLine contains only the arguments.

There is also CWinApp::ParseCommandLine() that you may find useful . refer the link as follows http://msdn.microsoft.com/en-us/library/64c73803.aspx

void ParseCommandLine(
   CCommandLineInfo& rCmdInfo 
);
Parameters
rCmdInfo
A reference to a CCommandLineInfo object.

When you start a new MFC project using the Application Wizard, the Application Wizard will create a local instance of CCommandLineInfo, and then call ProcessShellCommand and ParseCommandLine in the InitInstance member function. A command line follows the route described below:
After being created in InitInstance, the CCommandLineInfo object is passed to ParseCommandLine.
ParseCommandLine then calls CCommandLineInfo::ParseParam repeatedly, once for each parameter.
ParseParam fills the CCommandLineInfo object, which is then passed to ProcessShellCommand.
ProcessShellCommand handles the command-line arguments and flags.

Note that you can call ParseCommandLine directly as needed.（也可以直接处理）

CWinApp::ProcessShellCommand

CWinApp::ParseCommandLine calls ParseParam once for each parameter or flag on the command line, passing the argument to pszParam. If the first character of the parameter is a '-' or a '/', then it is removed and bFlag is set to TRUE. When parsing the final parameter, bLast is set to TRUE.

CCommandLineInfo::ParseParam
virtual void ParseParam( 
   const char* pszParam, 
   BOOL bFlag, 
   BOOL bLast 
);
virtual void ParseParam( 
   const TCHAR* pszParam,  
   BOOL bFlag, 
   BOOL bLast
);

Parameters
pszParam
The parameter or flag.
bFlag
Indicates whether pszParam is a parameter or a flag.
bLast
Indicates if this is the last parameter or flag on the command line.

CCommandLineInfo的成员变量
Data Members
m_bRunAutomated Indicates the command-line /Automation option was found.
efm_bRunEmbedded Indicates the command-line /Embedding option was found.
m_bShowSplash Indicates if a splash screen should be shown.
m_nShellCommand Indicates the shell command to be processed.
m_strDriverName Indicates the driver name if the shell command is Print To; otherwise empty.
m_strFileName Indicates the filename to be opened or printed; empty if the shell command is New or DDE.
m_strPortName Indicates the port name if the shell command is Print To; otherwise empty.
m_strPrinterName Indicates the printer name if the shell command is Print To; otherwise empty.

d:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\atlmfc\include\afxwin.h
// Helper classes
class CCmdUI;           // Menu/button enabling
class CDataExchange;    // Data exchange and validation context
class CCommandLineInfo; // CommandLine parsing helper
class CDocManager;      // CDocTemplate manager object

Also try ATL COM wizard to create non MFC dialog app. (chose the .exe option, not .dll)


GetCommandLine function
Retrieves the command-line string for the current process.
Syntax

C++

LPTSTR WINAPI GetCommandLine(void);

Parameters

This function has no parameters.
Return value

The return value is a pointer to the command-line string for the current process.
Remarks

ANSI console processes written in C can use the argc and argv arguments of the main function to access the command-line arguments. ANSI GUI applications can use the lpCmdLine parameter of the WinMain function to access the command-line string, excluding the program name. The main and WinMain functions cannot return Unicode strings.
Unicode console process written in C can use the wmain or _tmain function to access the command-line arguments. Unicode GUI applications must use the GetCommandLineW function to access Unicode strings.
To convert the command line to an argv style array of strings, call the CommandLineToArgvW function.
Note  The name of the executable in the command line that the operating system provides to a process is not necessarily identical to that in the command line that the calling process gives to the CreateProcess function. The operating system may prepend a fully qualified path to an executable name that is provided without a fully qualified path.

【BOOST THREAD CONDITION】
Notice that the lock is passed to wait: wait will atomically add the thread to the set of threads waiting on the condition variable, and unlock the mutex. When the thread is woken, the mutex will be locked again before the call to wait returns. This allows other threads to acquire the mutex in order to update the shared data, and ensures that the data associated with the condition is correctly synchronized

////////////////////////////////////线程A
boost::condition_variable cond;
boost::mutex mut;
bool data_ready;

void process_data();

void wait_for_data_to_process()
{
    boost::unique_lock<boost::mutex> lock(mut);
    while(!data_ready)
    {
        cond.wait(lock);
    }
    process_data();
}

////////////////////////////////////线程B
void retrieve_data();
void prepare_data();

void prepare_data_for_processing()
{
    retrieve_data();
    prepare_data();
    {
        boost::lock_guard<boost::mutex> lock(mut);
        data_ready=true;
    }
    cond.notify_one();
}

【BOOST 是怎么设置静态库链接的？】
【BOOST】
	BOOST_FOREACH(auto &item, data_) {
		obj.clear();
		
		//这里怎么，获得下一个，值？
		obj.push_back(json_spirit::wPair(L"time", boost::posix_time::to_iso_wstring(item.time())));
		obj.push_back(json_spirit::wPair(L"duration", item.duration().total_milliseconds()));
		obj.push_back(json_spirit::wPair(L"x", item.x()));
		obj.push_back(json_spirit::wPair(L"y", item.y()));
		items.push_back(obj);
	}
	
	item 是什么的引用？data_中元素的引用？
	怎么改为，迭代器呢？
	
	不用BOOST_FOREACH，自己写个，
	//BOOST_FOREACH(auto &item, data_) {
	for(auto item = data_.begin(); item != data_.end();) {
		obj.clear();
		obj.push_back(json_spirit::wPair(L"time", boost::posix_time::to_iso_wstring(item->time())));
		//obj.push_back(json_spirit::wPair(L"duration", item.duration().total_milliseconds()));
		obj.push_back(json_spirit::wPair(L"x", item->x()));
		obj.push_back(json_spirit::wPair(L"y", item->y()));
		auto cur_time = item->time();
		if((++item) != data_.end()) {
			obj.push_back(json_spirit::wPair(L"duration", (item->time() - cur_time).total_milliseconds()));
		    items.push_back(obj);

		} else {
			break;
		}
	}
	root.push_back(json_spirit::wPair(L"locations", items));
	
【STD】
std::list 下标问题？没有下标重载符，可以使用迭代器，一个一个向下走或者向上走。
std::list 的，迭代器，的重载运算符有以下：（没有下标符，加减运算符）
【STD】
WPARAM pa = x << 16 + y;
1>d:\project\trunk\src\client\imagetracking\imagetracking\imagetrackingdlg.cpp(184): 
warning C4554: “<<”: 检查运算符优先级可能存在的错误；使用圆括号阐明优先级

正确的修改：WPARAM pa = (x << 16) + y;
仍报警告的修改：WPARAM pa = （x << 16 + y）;
【STD】

Input iterator(输入迭代器)           读,不能写 只支持自增运算
Output iterator(输出迭代器) ;        写，不能读 只支持自增运算

Forward iterator(前向迭代器)            读和写;只支持自增运算
Bidirectional iterator(双向迭代器) ;    读和写 支持自增和自减运算
Random access iterator(随机访问迭代器)  读和写;支持完整的迭代器算术运算

【STD】
fopen 参数， r/r+ 的区别？
r
Open text file for reading. The stream is positioned at the beginning of the file.

r+

Open for reading and writing. The stream is positioned at the beginning of the file.

w

Truncate[trʌŋ'keɪt] [美][ˈtrʌŋˌket]（截断） file to zero length or create text file for writing. The stream is positioned at the beginning of the file.

w+

Open for reading and writing. The file is created if it does not exist, otherwise it is truncated. The stream is positioned at the beginning of the file.

a

Open for appending (writing at end of file). The file is created if it does not exist. The stream is positioned at the end of the file.

a+

Open for reading and appending (writing at end of file). The file is created if it does not exist. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file

【STD】

ios::app 添加输出                        如果文件不存在，是否会创建？
ios::ate 当已打开时寻找到EOF 
ios::binary 以二进制模式打开文件         如果文件不存在，是否会创建？ 
ios::in 为读取打开文件 
ios::out 为写入打开文件                  如果文件不存在，是否会创建？
ios::trunc 覆盖存在的文件                如果文件不存在，是否会创建？

//下面是测试结果
std::ofstream of(L"d:\t.yuy2", std::iostream::binary); 
//后面的说法是错误的，这一句就可以创建新文件，先前失败的原因是路径反斜杠的问题//文件不存在，打开失败。of.good()返回false

std::ofstream of(L"d:\\t.yuy2", std::iostream::binary); //这句可以创建新文件。


The filebuf constructor to which these flags are passed† has behaviours based on those flags defined in Table 132 in C++11:

+-----------------------------------+-------------------+
|     ios_base flag combination     |  stdio equivalent |
| binary  in    out    trunc    app |                   |
+-----------------------------------+-------------------+
|               +                   |  "w"              |
|               +               +   |  "a"              |
|                               +   |  "a"              |
|               +       +           |  "w"              |
|        +                          |  "r"              |
|        +      +                   |  "r+"             |
|        +      +       +           |  "w+"             |
|        +      +               +   |  "a+"             |
|        +                      +   |  "a+"             |
+-----------------------------------+-------------------+
|   +           +                   |  "wb"             |
|   +           +               +   |  "ab"             |
|   +                           +   |  "ab"             |
|   +           +       +           |  "wb"             |
|   +    +                          |  "rb"             |
|   +    +      +                   |  "r+b"            |
|   +    +      +       +           |  "w+b"            |
|   +    +      +               +   |  "a+b"            |
|   +    +                      +   |  "a+b"            |
+-----------------------------------+-------------------+
As you can see, your flag combination is not found in that table.

【COM】
COINIT enumeration
Determines the concurrency model used for incoming calls to objects created by this thread. This concurrency model can be either apartment-threaded or multithreaded.
Syntax

C++

typedef enum tagCOINIT { 
  COINIT_APARTMENTTHREADED  = 0x2,
  COINIT_MULTITHREADED      = 0x0,
  COINIT_DISABLE_OLE1DDE    = 0x4,
  COINIT_SPEED_OVER_MEMORY  = 0x8
} COINIT;

Constants

COINIT_APARTMENTTHREADED
Initializes the thread for apartment-threaded object concurrency (see Remarks).
COINIT_MULTITHREADED
Initializes the thread for multithreaded object concurrency (see Remarks).
COINIT_DISABLE_OLE1DDE
Disables DDE for OLE1 support.
COINIT_SPEED_OVER_MEMORY
Increase memory usage in an attempt to increase performance.
Remarks

When a thread is initialized through a call to CoInitializeEx, you choose whether to initialize it as apartment-threaded or multithreaded by designating one of the members of COINIT as its second parameter. This designates how incoming calls to any object created by that thread are handled, that is, the object's concurrency.
Apartment-threading, while allowing for multiple threads of execution, serializes all incoming calls by requiring that calls to methods of objects created by this thread always run on the same thread – the apartment/thread that created them. In addition, calls can arrive only at message-queue boundaries. Because of this serialization, it is not typically necessary to write concurrency control into the code for the object, other than to avoid calls to PeekMessage and SendMessage during processing that must not be interrupted by other method invocations or calls to other objects in the same apartment/thread.
Multi-threading (also called free-threading) allows calls to methods of objects created by this thread to be run on any thread. There is no serialization of calls – many calls may occur to the same method or to the same object or simultaneously. Multi-threaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling, since calls to objects are not serialized in any way. This means, however, that the code for objects must enforce its own concurrency model, typically through the use of synchronization primitives, such as critical sections, semaphores, or mutexes. In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in Thread Local Storage).
Note  The multi-threaded apartment is intended for use by non-GUI threads. Threads in multi-threaded apartments should not perform UI actions. This is because UI threads require a message pump, and COM does not pump messages for threads in a multi-threaded apartment.

【API】
MapWindowPoints function
The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window.

This macro calls the function MapWindowPoints.
MapWindowRect( 
  HWND hwndFrom, 
  HWND hwndTo, 
  LPRECT lprc 
); 

【MFC】
以BMP图片为蓝本创建不规则窗口
// Add the pixels (x0, y) to (x, y+1) as a new rectangle in the region  一行一个矩形区， 把所有的矩形区加到一个RGNDATA结构体里。
// Scan each bitmap row from bottom to top (the bitmap is inverted vertically) 扫描每个像素，判断是否透明。
The RGNDATA structure contains a header and an array of rectangles that compose a region. The rectangles are sorted top to bottom, left to right. They do not overlap.
Syntax
C++

typedef struct _RGNDATA {
  RGNDATAHEADER rdh;
  char          Buffer[1];
} RGNDATA, *PRGNDATA;

Members
rdh
A RGNDATAHEADER structure. The members of this structure specify the type of region (whether it is rectangular or trapezoidal), the number of rectangles that make up the region, the size of the buffer that contains the rectangle structures, and so on.
Buffer
Specifies an arbitrary-size buffer that contains the RECT structures that make up the region.

The RGNDATAHEADER structure describes the data returned by the GetRegionData function.
Syntax
C++

typedef struct _RGNDATAHEADER {
  DWORD dwSize;
  DWORD iType;
  DWORD nCount;
  DWORD nRgnSize;
  RECT  rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

Members
dwSize
The size, in bytes, of the header.
iType
The type of region. This value must be RDH_RECTANGLES.
nCount
The number of rectangles that make up the region.
nRgnSize
The size of the RGNDATA buffer required to receive the RECT structures that make up the region. If the size is not known, this member can be zero.
rcBound
A bounding rectangle for the region in logical units.

【WINDOW-HRGN】
ExtCreateRegion function
The ExtCreateRegion function creates a region from the specified region and transformation data.
HRGN ExtCreateRegion(
  _In_  const XFORM *lpXform,
  _In_  DWORD nCount,
  _In_  const RGNDATA *lpRgnData
);
lpXform [in]
A pointer to an XFORM structure that defines the transformation to be performed on the region. If this pointer is NULL, the identity transformation is used.
nCount [in]
The number of bytes pointed to by lpRgnData.
lpRgnData [in]
A pointer to a RGNDATA structure that contains the region data in logical units.

Region coordinates are represented as 27-bit signed integers


PtInRegion function
The PtInRegion function determines whether the specified point is inside the specified region.
Syntax
C++

BOOL PtInRegion(      与 PtInRect 比较
  _In_  HRGN hrgn,
  _In_  int X,
  _In_  int Y
);


CreateEllipticRgn
CreateEllipticRgnIndirect
CreatePolygonRgn
CreatePolyPolygonRgn
CreateRectRgn
CreateRectRgnIndirect
CreateRoundRectRgn
【MFC】
PtInRect function
The PtInRect function determines whether the specified point lies within the specified rectangle. A point is within a rectangle if it lies on the left or top side or is within all four sides. A point on the right or bottom side is considered outside the rectangle.
Syntax
C++

BOOL PtInRect(
  _In_  const RECT *lprc,
  _In_  POINT pt
);

Parameters
lprc [in]
A pointer to a RECT structure that contains the specified rectangle.
pt [in]
A POINT structure that contains the specified point.
Return value
If the specified point lies within the rectangle, the return value is nonzero.
If the specified point does not lie within the rectangle, the return value is zero.
Remarks
The rectangle must be normalized before PtInRect is called. That is, lprc.right must be greater than lprc.left and lprc.bottom must be greater than lprc.top. If the rectangle is not normalized, a point is never considered inside of the rectangle.
Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used determine the units of measure.
【MFC】
SetWindowRgn function
The SetWindowRgn function sets the window regionregion[英]['ri:dʒən] [美][ˈridʒən] of a window. The window region determines the area within the window where the system permits drawing. The system does not display any portion[英]['pɔ:ʃn] [美][ˈpɔrʃən, ˈpor-] of a window that lies outside of the window region

int SetWindowRgn(
  _In_  HWND hWnd,
  _In_  HRGN hRgn,
  _In_  BOOL bRedraw
);

Parameters
hWnd [in]
A handle to the window whose window region is to be set.
hRgn [in]
A handle to a region. The function sets the window region of the window to this region.
If hRgn is NULL, the function sets the window region to NULL.
bRedraw [in]
Specifies whether the system redraws the window after setting the window region. If bRedraw is TRUE, the system does so; otherwise, it does not.
Typically, you set bRedraw to TRUE if the window is visible.

Return value
If the function succeeds, the return value is nonzero.
If the function fails, the return value is zero.
Remarks
When this function is called, the system sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGING messages to the window.
The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.
Note  If the window layout is right-to-left (RTL), the coordinates are relative to the upper-right corner of the window. See Window Layout and Mirroring.
After a successful call to SetWindowRgn, the system owns the region specified by the region handle hRgn. The system does not make a copy of the region. Thus, you should not make any further function calls with this region handle. In particular, do not delete this region handle. The system deletes the region handle when it no longer needed.
To obtain the window region of a window, call the GetWindowRgn function.


Window Regions
In addition to the update region, every window has a visible region that defines the window portion visible to the user. The system changes the visible region for the window whenever the window changes size or whenever another window is moved such that it obscures or exposes a portion of the window. Applications cannot change the visible region directly, but the system automatically uses the visible region to create the clipping region for any display device context retrieved for the window.
The clipping region determines where the system permits drawing. When the application retrieves a display device context using the BeginPaint, GetDC, or GetDCEx function, the system sets the clipping region for the device context to the intersection of the visible region and the update region. Applications can change the clipping region by using functions such as SetWindowRgn, SelectClipPath and SelectClipRgn, to further limit drawing to a particular portion of the update area.
The WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles further specify how the system calculates the visible region for a window. If a window has one or both of these styles, the visible region excludes any child window or sibling windows (windows having the same parent window). Therefore, drawing that would otherwise intrude in these windows will always be clipped.


Raster[英]['ræstə] [美]['ræstə]（光栅） Operation Codes
Raster-operation codes define how the graphics device interface (GDI) combines the bits from the selected pen with the bits in the destination bitmap.
This overview lists and describes the binary and ternary raster operations used by GDI. A binary raster operation involves two operands: a pen and a destination bitmap. A ternary raster operation involves three operands: a source bitmap, a brush, and a destination bitmap. Both binary and ternary raster operations use Boolean operators.

衍射光栅（diffraction grating）是光栅的一种。它通过有规律的结构，使入射光的振幅或相位（或两者同时）受到周期性空间调制。衍射光栅在光学上的最重要应用是作为分光器件，常被用于单色仪和光谱仪上。
实际应用的衍射光栅通常是在表面上有沟槽或刻痕的平板。这样的光栅可以是透射光栅或反射光栅。可以调制入射光的相位而不是振幅的衍射光栅现在也能生产。
衍射光栅的原理是苏格兰数学家詹姆斯·格雷戈里发现的，发现时间大约在牛顿的棱镜实验的一年后。詹姆斯·格雷戈里大概是受到了光线透过鸟类羽毛的启发。公认的最早的人造光栅是德国物理学家夫琅禾费在1821年制成的，那是一个极简单的金属丝栅网。但也有人争辩说费城发明家戴维·里滕豪斯于1785年在两根螺钉之间固定的几根头发才是世界上第一个人造光栅。

【VIM 命令列表】

【不用输入密码，直接打开电脑】rundll32 netplwiz.dll,UsersRunDll



#include <mmsystem.h>
#pragma comment(lib, "WINMM.LIB")
return PlaySound(_PlayPath,NULL,SND_ASYNC|SND_NODEFAULT);

回车退出窗口的问题

SQL 查询时间语句
SELECT *
  FROM [audio].[dbo].[audio] where ( '2013-08-29 18:00:00' < Time )

SELECT *
  FROM [audio].[dbo].[audio] where ( '2013-08-29 17:00:00' < Time AND Time < '2013-08-29 18:00:00' )

SELECT *  这样写也正确
  FROM [audio].[dbo].[audio] where ( '20130829 17:00:00' < Time AND Time < '2013-08-29 18:00:00' )

SELECT *  省略时间也可以
  FROM [audio].[dbo].[audio] where ( '20130829' < Time AND Time < '20130830' )
时间字符串的引号必须加  所有条件的值都要加单引号

CRecordset 的成员 函数
BOOL IsOpen() const;        // Recordset successfully opened?
	BOOL IsBOF() const;     // Beginning Of File
	BOOL IsEOF() const;     // End Of File
	BOOL IsDeleted() const;     // On a deleted record

long GetRecordCount() const;        // Records seen so far or -1 if unknown
这个函数不是返回，表中的记录数。是什么意思？

数据库查询
		m_audio_database.m_strFilter = L"CounterNo=2";
		m_audio_database.Requery();


CDateTimeCtrl
CMonthCalCtrl m_calCtrl;
控件的区别

posix_time 与 MFC CTime的转换			
static boost::posix_time::ptime utc_ptime( boost::gregorian::date( 1970, 1, 1 ) ); 
boost::posix_time::time_duration utc = iter->time() - utc_ptime;
m_audio_database.m_Time = CTime( utc.seconds() );
这里计算出的UTC时间不对。都是

从 ptime里 计算出时分秒

			boost::posix_time::time_duration time = iter->time() - boost::posix_time::ptime( iter->time().date() );
			m_audio_database.m_Time = CTime( 
				iter->time().date().year(),
				iter->time().date().month(),
				iter->time().date().day(),
				time.hours(), time.minutes(), time.seconds() );

CTime 时区问题？


或使用 TRUNCATE TABLE 删除所有行
若要删除表中的所有行，则 TRUNCATE TABLE 语句是一种快速、无日志记录的方法。该语句总是比不带条件的 DELETE 语句要快，因为 DELETE 语句要记录对每行的删除操作，而 TRUNCATE TABLE 语句只记录整个数据页的释放。TRUNCATE TABLE 语句立即释放由该表的数据和索引占用的所有空间。所有索引的分发页也将释放。

与 DELETE 语句相同，使用 TRUNCATE TABLE 清空的表的定义，同其索引和其它相关的对象一起仍保留在数据库中。必须使用 DROP TABLE 语句才能除去表的定义。


			static boost::posix_time::ptime utc_ptime( boost::gregorian::date( 1970, 1, 1 ) ); 
			boost::posix_time::time_duration utc = iter->time() - utc_ptime;
			m_audio_database.m_Time = CTime( utc.seconds() );



http://stackoverflow.com/questions/354902/open-in-explorer
http://forums.codeguru.com/showthread.php?441316-Open-Windows-Explorer-to-Specific-Folder
si.wShowWindow = SW_MINIMIZE;
si.dwFlags |= STARTF_USESHOWWINDOW;

CreateProcess( NULL, _T("explorer.exe C:\\windows"), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi );

You probably are looking for the ShellExecute() function in shell32.h. 
It is called with an "action verb", a path, and optional parameters. 
In your case this will want either "open" or "explore" as follows
ShellExecute(NULL, "open", "C:\", NULL, NULL, SW_SHOWDEFAULT);
ShellExecute(NULL, "open", "http://www.google.com", NULL, NULL, SW_SHOWDEFAULT);


m_list.deleteallitems


SQL Server Express 是由Microsoft所开发的SQL Server的其中一个版本，这个版本是免费且可自由转散布（需经注册），并且可和商用程序一起使用的小型数据库管理系统，它继承了多数的SQL Server功能与特性，像是Transact-SQL、SQL CLR等，相当适合使用在小型的网站，或者是小型的桌面型应用程序，它也可以和 SQL Server 集成，作为数据库复制（Replication）的订阅端

数据库的大小限制：SQL Server 2005 Express 和SQL Server 2008 Express 数据库的大小限制最大为 4GB，最新版本的SQL Server 2008 R2 Express 数据库的大小限制最大为 10G。这个大小的限制只有在数据文件上，事务日志大小则不受此限。 2.只能使用一个 CPU 来运算，这在多个 CPU 的电脑上会造成浪费。
3.可使用的存储器量最高只有 1GB。
4.没有 SQL Agent，若要做调度服务必须自己写程序

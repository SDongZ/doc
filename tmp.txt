静态框 ，调用了，MoveWindow(10, 50, m_width, m_height); 但没有触发，
CImageView::OnSizing(UINT fwSide, LPRECT pRect)事件。
写错了，应该是void CImageView::OnSize(UINT nType, int cx, int cy)事件。可以触发这个事件。


	MoveWindow(10, 50, m_width, m_height);
	m_d2d_target->Resize(D2D1::SizeU(m_width, m_height));  
	如果控件大小变化了，但是没有调用这个Resize函数，会出现什么情况？画的矩形框会被缩放。

Centers a window relative to its parent.
void CenterWindow( 
   CWnd* pAlternateOwner = NULL  
);
Parameters
pAlternateOwner
Pointer to an alternate window relative to which it will be centered (other than the parent window).
Usually called from CDialog::OnInitDialog to center dialog boxes relative to the main window of the application. By default, the function centers child windows relative to their parent window, and pop-up windows relative to their owner. If the pop-up window is not owned, it is centered relative to the screen. To center a window relative to a specific window which is not the owner or parent, the pAlternateOwner parameter may be set to a valid window. To force centering relative to the screen, pass the value returned by CWnd::GetDesktopWindow as pAlternateOwner.

判断WINDOW操作系统版本的函数


CStaic 控件，与，鼠标事件。
SS_NOTIFY
Sends the parent window STN_CLICKED, STN_DBLCLK, STN_DISABLE, and STN_ENABLE notification codes when the user clicks or double-clicks the control.
静态控件需要设置SS_NOTIFY风格，才能响应鼠标事件


RECT 成员变量，初始化, 无法初始化。
error C2661: “tagRECT::tagRECT”: 没有重载函数接受 4 个参数

And I get this error when doing srcRectBg = new RECT(0,0,640,480);
error C2661: 'tagRECT::tagRECT' : no overloaded function takes 4 parameters 

暂时改为，CRect,具有构造函数的，类。
具有构造函数的类，与，没有构造函数的结构体，初始化的区别？


CStatic 控件，GetClientRect，返回值不对，为什么？ 对话框创建完成之前，，在控件的获得，WM_PAINT消息时，可以正确的取得其大小
		GetClientRect(&rt); rt {top=0 bottom=221 left=0 right=536}
		GetWindowRect(&rt); rt {top=278 bottom=499 left=452 right=988}
Windows does not know the size of the controls before the dialog window has been created.


WM_MOUSEMOVE message
Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.
wParam
Indicates whether various virtual keys are down. This parameter can be one or more of the following values.
Value	Meaning
MK_CONTROL
0x0008
The CTRL key is down.
MK_LBUTTON
0x0001
The left mouse button is down.
MK_MBUTTON
0x0010
The middle mouse button is down.
MK_RBUTTON
0x0002
The right mouse button is down.
MK_SHIFT
0x0004
The SHIFT key is down.
MK_XBUTTON1
0x0020
The first X button is down.
MK_XBUTTON2
0x0040
The second X button is down.

lParam
The low-order word specifies the x-coordinate of the cursor. The coordinate is relative to the upper-left corner of the client area.
The high-order word specifies the y-coordinate of the cursor. The coordinate is relative to the upper-left corner of the client area.



Mouse Capture (捕获鼠标的意义是，所有鼠标事件都发送给，捕获鼠标的窗口)

The system typically posts a mouse message to the window that contains the cursor hot spot when a mouse event occurs. 
An application can change this behavior by using the SetCapture function to route mouse messages to a specific window. 
The window receives all mouse messages until the application calls the ReleaseCapture function or specifies another capture window, 
or until the user clicks a window created by another thread.

When the mouse capture changes, the system sends a WM_CAPTURECHANGED message to the window that is losing the mouse capture. 
The lParam parameter of the message specifies a handle to the window that is gaining the mouse capture.

Only the foreground window can capture mouse input. 
When a background window attempts to capture mouse input, it receives messages only for mouse events that occur when the cursor hot spot is within the visible portion of the window.

Capturing mouse input is useful if a window must receive all mouse input, even when the cursor moves outside the window. 
For example, an application typically tracks the cursor position after a mouse button down event, following the cursor until a mouse button up event occurs. 
If an application has not captured mouse input and the user releases the mouse button outside the window, the window does not receive the button-up message.

A thread can use the GetCapture function to determine whether one of its windows has captured the mouse. 
If one of the thread's windows has captured the mouse, GetCapture retrieves a handle to the window.



How to Load a Bitmap from a File
Direct2D uses the Windows Imaging Component (WIC) to load bitmaps. 
To load a bitmap from a file, first use WIC objects to load the image and to convert it to a Direct2D-compatible format, 
then use the CreateBitmapFromWicBitmap method to create an ID2D1Bitmap (ID2D1RenderTarget::CreateBitmapFromWicBitmap method)

WIC绘制图片是在GPU上进行的，所以效率较高
	//加载一个位图
	HRESULT hr = S_OK;
	IWICImagingFactory* pIWICFactory = NULL;  
    IWICBitmapDecoder* pDecoder = NULL;  
    IWICBitmapFrameDecode* pFrame = NULL;  
    IWICFormatConverter* pConverter = NULL;  

	CoCreateInstance(CLSID_WICImagingFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pIWICFactory) ); 
    hr = pIWICFactory->CreateDecoderFromFilename(  
        TEXT("C:\\Users\\Public\\Pictures\\Sample Pictures\\11.jpg"),  
        NULL,  
        GENERIC_READ,  
        WICDecodeMetadataCacheOnLoad,  
        &pDecoder  
        );     
    hr = pDecoder->GetFrame(0, &pFrame);    
    hr = pIWICFactory->CreateFormatConverter(&pConverter);  
    hr = pConverter->Initialize(  
        pFrame,                          // Input bitmap to convert  
        GUID_WICPixelFormat32bppPBGRA,   // Destination pixel format  
        WICBitmapDitherTypeNone,         // Specified dither pattern  
        NULL,                            // Specify a particular palette   
        0.f,                             // Alpha threshold  
        WICBitmapPaletteTypeCustom       // Palette translation type  
        ); 

	m_d2d_target->CreateBitmapFromWicBitmap(pConverter, &m_d2d_bitmap);


WM_CREATE 返回值
If an application processes this message, it should return zero to continue creation of the window. If the application returns C1, the window is destroyed and the CreateWindowEx or CreateWindow function returns a NULL handle.

#define WM_ERASEBKGND                   0x0014 (注意其返回值 ) （对话框上的控件，刷新背景的问题，父窗口负责刷新背景, 返回TRUE与FALSE好像没有区别）
                                        影响刷新背景的函数，InvalidateRect，等等。
Sent when the window background must be erased (for example, when a window is resized). 
The message is sent to prepare an invalidated portion of a window for painting.

An application should return nonzero if it erases the background; otherwise, it should return zero.
The DefWindowProc function erases the background by using the class background brush specified by the hbrBackground member of the WNDCLASS structure. If hbrBackground is NULL, the application should process the WM_ERASEBKGND message and erase the background.
An application should return nonzero in response to WM_ERASEBKGND if it processes the message and erases the background; this indicates that no further erasing is required. If the application returns zero, the window will remain marked for erasing. (Typically, this indicates that the fErase member of the PAINTSTRUCT structure will be TRUE.)



CPreviewDlg::OnInitDialog() 与 控件WM_PAINT消息之间
                            与 控件WM_CREATE消息之间
This method is called in response to the WM_INITDIALOG message.
Windows sends the WM_INITDIALOG message to the dialog box during the Create, CreateIndirect, or DoModal calls, 
                                                                     which occur immediately before the dialog box is displayed.
Override this method if you want to perform special processing when the dialog box is initialized.
In the overridden version, first call the base class OnInitDialog but ignore its return value.
You will typically return TRUE from your overridden method.
Windows calls the OnInitDialog function by using the standard global dialog-box procedure common to all Microsoft Foundation Class Library dialog boxes. 
It does not call this function through your message map, and therefore you do not need a message map entry for this method.


WM_INITDIALOG message
Sent to the dialog box procedure immediately before a dialog box is displayed. Dialog box procedures typically use this message to initialize controls and carry out any other initialization tasks that affect the appearance of the dialog box.
C++

#define WM_INITDIALOG                   0x0110

Parameters

wParam
A handle to the control to receive the default keyboard focus. The system assigns the default keyboard focus only if the dialog box procedure returns TRUE.
lParam
Additional initialization data. This data is passed to the system as the lParam parameter in a call to the CreateDialogIndirectParam, CreateDialogParam, DialogBoxIndirectParam, or DialogBoxParam function used to create the dialog box. For property sheets, this parameter is a pointer to the PROPSHEETPAGE structure used to create the page. This parameter is zero if any other dialog box creation function is used.

Return value

The dialog box procedure should return TRUE to direct the system to set the keyboard focus to the control specified by wParam. Otherwise, it should return FALSE to prevent the system from setting the default keyboard focus.
The dialog box procedure should return the value directly. The DWL_MSGRESULT value set by the SetWindowLong function is ignored.
Remarks

The control to receive the default keyboard focus is always the first control in the dialog box that is visible, not disabled, and that has the WS_TABSTOP style. When the dialog box procedure returns TRUE, the system checks the control to ensure that the procedure has not disabled it. If it has been disabled, the system sets the keyboard focus to the next control that is visible, not disabled, and has the WS_TABSTOP.
An application can return FALSE only if it has set the keyboard focus to one of the controls of the dialog box


http://en.wikipedia.org/wiki/Serial_digital_interface
http://baike.baidu.com/subview/840209/5111289.htm?fr=aladdin
SDI(Serial Digital Interface) 接口即数字串行接口。
人们常在SDI信号中嵌入数字音频信号，也就是将数字音频信号插入到视频信号的行、场同步脉冲（行、场消隐）期间与数字分量视频信号同时传输
SDI接口不能直接传送压缩数字信号，数字录像机、硬盘等设备记录的压缩信号重放后，必须经解压并经SDI接口输出才能进入SDI系统。
如果反复解压和压缩，必将引起图像质量下降和延时增加，为此各种不同格式的数字录像机和非线性编辑系统，规定了自己的用于直接传输压缩数字信号的接口


室内定位技术
http://www.chainless.cn/project_qt.html
杭州辰林信息技术有限公司是一家富于创新，积极进取，充满活力的IT企业。公司面向现代服务业，致力于互联网和移动领域的应用开发与服务，将先进的信息技术，特别是ZIGBEE无线技术、互联网技术

http://www.wellnode.com/cn/category/200.html
nanoPAL是Nanotron公司Find平台核心组成部分,该平台为系统集成商提供精度达1-3米的定位方案。Find平台所提供的定位基站OEM板卡、基于芯片的自主标签设计方案、nanoLES定位引擎、API开发接口、完善的开发文档，能够使系统集成商在1-2个月内完成自主产品与系统设计，大大缩短上市时间。
本解决方案采用Chirp宽带定位技术，通过测量宽带窄脉冲信号的到达时间差(TDOA)来计算标签的1D/2D位置，并获取最高0.6米的位置精度；与基于信号强度的RFID、Wi-Fi定位系统不同，即使在复杂工程环境中，Find平台用户仍然能够可重复地获取1-3米定位精度。

http://www.kingdoes.com/kd/solutions/rtls/
儿童职业体验馆

儿童职业体验馆作为为儿童提供各种职业体验的主题乐园，室内空间较大，环境复杂，家长希望快速找到自己孩子并观察其活动情况的意愿很大，KINGDOES专门研发了“双频电子定位腕带”以解决此问题。家长只需在场馆内的任何一台综合查询机上扫描一下电子手环，便可迅速查询到自己孩子当前位置及行动轨迹，还可以调用附近的摄像头，观察孩子当前活动的实时画面


2009年Hitachi就提出用超l技gM行室榷ㄎ唬精识瓤芍1m；DecaWave公司也以IEEE 802.15.4a的超l释菩卸ㄎ痪片，宣Q_10cm的精识龋比BLE的30cm更精


射频（RF）是Radio Frequency的缩写，表示可以辐射到空间的电磁频率，频率范围从300KHz～300GHz之间。射频简称RF射频就是射频电流，它是一种高频交流变化电磁波的简称。每秒变化小于1000次的交流电称为低频电流，大于10000次的称为高频电流，而射频就是这样一种高频电流

RFID技术的基本工作原理：射频标签进入磁场后，接收解读器(Reader)发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的相关信息（Passive Tag，无源标签或被动标签）
电磁感应（Electromagnetic induction），是指放在变化磁通量中的导体，会产生电动势。此电动势称为感应电动势或感生电动势，若将此导体闭合成一回路，则该电动势会驱使电子流动，形成感应电流（感生电流）

RFID: 读写器发射能量--> 激活标签芯片--> 送出数据-->读写器接收数据 只有读写器有能量 标签靠读写器的射频激发能力
蓝牙和红外是:  发出请求-->接收请求--->传输数据  两端都有能量

被动式[编辑]
被动式标签没有内部供电电源，其内部集成电路通过接收到的电磁波进行驱动，这些电磁波是由RFID读取器发出的。当标签接收到足够强度的讯号时，可以向读取器发出数据。这些数据不仅包括ID号（全球惟一代码），还可以包括预先存在于标签内EEPROM (电可擦拭可编程只读内存)中的数据。
由于被动式标签具有价格低廉，体积小巧，无需电源等优点。目前市场所运用的RFID标签以被动式为主。
被动式射频标签借由读取器发射出的电磁波获得能量，并回传相对应的反向散射信号至读取器。然而在传播路径衰减的环境下，限制了标签的读取距离。

室内无线定位常用的三种方法：接收信号强度定位法、到达时间定位法、接收信号角度定位法、参考点定位法


蓝牙系统一般工作在2.4GHz的ISM频段。起始频率为2.402GHz，终止频率为2.480GHz，还在低端设置了2MHz的保护频段，高端设置了3.5MHz的保护频段。共享一个公共信道的所有蓝牙单元形成一个微网，每个微网最多可以有8个蓝牙单元。在微网中，同一信道的各单元的时钟和跳频均保持同步。 保持同步。


该技术规范定义了两个 NFC 设备之间基于 13.56MHz 频率的无线通讯方式，在 NFC 的世界里没有读卡器，没有卡，只有 NFC 设备。该规范定义了 NFC 设备通讯的两种模式:主动模式和被动模式 


看下面的代码，错在那里？字节，字节，一个字节是两位十六进制
extern float cal_pos(unsigned char low, unsigned char hi);
afx_msg LRESULT CShowPositionWnd::OnNewPosition(WPARAM wParam, LPARAM lParam)
{
	float x = cal_pos((wParam >> 24) & 0xf, (wParam >> 16) & 0xf);
	float y = cal_pos((wParam >> 8) & 0xf, wParam & 0xf);
	m_point_list.push_back(D2D1::Point2F(x, y));
	InvalidateRect(nullptr);
	return 0;
}


template <class T> void SafeRelease(T **ppT)
{
    if (*ppT)
    {
        (*ppT)->Release();
        *ppT = NULL;
    }
}


void CShowPositionWnd::DrawGrid() {
	if(m_render_target) {
		UINT x0 = 0, x1 = m_window_width, y = 0;
		m_solid_brush->SetColor(D2D1::ColorF(D2D1::ColorF::DarkRed));  改变画刷的着色
		while(y < m_window_height) {
			m_render_target->DrawLine(D2D1::Point2F(x0, y), D2D1::Point2F(x1, y), m_solid_brush);
			y += m_pixel_of_element;
		}

		UINT y0 = 0, y1 = m_window_height, x = 0;
		while(x < m_window_width) {
			m_render_target->DrawLine(D2D1::Point2F(x, y0), D2D1::Point2F(x, y1), m_solid_brush);
			x += m_pixel_of_element;
		}
	}
}

void CShowPositionWnd::DrawPoints() {
	if(m_point_list.size()) {
		auto point = m_point_list.begin();
		while(point != m_point_list.end()) {
		    m_solid_brush->SetColor(D2D1::ColorF(D2D1::ColorF::DarkGreen));
			m_render_target->FillEllipse(D2D1::Ellipse(*point, 10, 10), m_solid_brush); 画圆
			point++;
		}

		//draw last point
	}
}



对话框的OnDraw函数并不是一直发送。 最后找到原因，用下面的代码解决这个问题。

PAINTSTRUCT ps;
BeginPaint(m_hwnd, &ps);
EndPaint(m_hwnd, &ps);
或者
ValidateRect(nullptr);

The BeginPaint function automatically validates the entire client area. Neither the ValidateRect nor ValidateRgn function should be called if a portion of the update region must be validated before the next WM_PAINT message is generated.
The system continues to generate WM_PAINT messages until the current update region is validated.

但是自己写了个CWnd派生窗口类，创建的窗口，其OnDraw会一直发送。为什么
frequency WM_PAINT产生的频率，与窗口的样式有关吗？
d2d 官方例子中，创建的窗口，WM_DRAW，也不是一直调用的。Circle
http://msdn.microsoft.com/en-us/library/windows/desktop/ff381401(v=vs.85).aspx
update region 更新区域
Sometimes your program will initiate painting to update the appearance of the window. At other times, the operating system will notify you that you must repaint a portion of the window. When this occurs, the operating system sends the window a WM_PAINT message. The portion of the window that must be painted is called the update region

After you are done painting, call the EndPaint function. 
This function clears the update region, which signals to Windows that the window has completed painting itself

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define SUCCEEDED(hr) (((HRESULT)(hr)) >= 0)

//
// and the inverse
//

#define FAILED(hr) (((HRESULT)(hr)) < 0)


void CPositionDlg::OnPaint()
{
	if (IsIconic())
    {
        // code for handling when window is minimized. Check original CPP file attached.
    }
	该函数确定给定窗口是否是最小化（图标化）的窗口。
函数原型：BOOL IsIconic（HWND hWnd）；


设置窗口，可拖动区域
LRESULT CShowPositionWnd::OnNcHitTest(CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值

	//return CWnd::OnNcHitTest(point);
	return HTCAPTION;
}

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */


去标题栏，边框的方法
Creating a Border-Less, Title Bar-Less
直接Create出来，无论设置那种属性都不行。

这样就可以创建，无边框窗口, 注意扩展属性为零
CreateEx(0, ::AfxRegisterWndClass(0), L"show position", WS_POPUP, CRect(0, 0, m_window_width, m_window_height), nullptr, 0); 

注意MFC创建窗口类的方法，它要把窗口类的消息处理函数，截获了。
BOOL rtt = m_show_pos_window.CreateEx(WS_EX_DLGMODALFRAME, ::AfxRegisterWndClass(0), L"Title", WS_OVERLAPPED, CRect(0, 0, 300, 300), this, NULL);


//
//  函数: MyRegisterClass()
//
//  目的: 注册窗口类。
//
//  注释:
//
//    仅当希望
//    此代码与添加到 Windows 95 中的“RegisterClassEx”
//    函数之前的 Win32 系统兼容时，才需要此函数及其用法。调用此函数十分重要，
//    这样应用程序就可以获得关联的
//    “格式正确的”小图标。
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= WndProc;   //MFC 的窗口类怎么注册？
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, MAKEINTRESOURCE(IDI_TEST));
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= MAKEINTRESOURCE(IDC_TEST);
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	return RegisterClassEx(&wcex);
}


设接收这个消息的窗口过程 WindowProc为
LRESULT CALLBACK WindowProc(
HWND hwnd,
UINT uMsg,
WPARAM wParam,
LPARAM lParam
);
当显示器的分辨率改变后，此窗口过程会接到WM_DISPLAYCHANGE消息
wParam参数为显示设备新的颜色深度，即每个像素所占的颜色位数
lParam参数的低字节部分为显示设备新的水平分辨率，高字节部分为显示设备的新的垂直分辨率。
WM_DISPLAYCHANGE 定义所在的头文件为 Winuser.h (include Windows.h)


CComPtr的用法和普通COM指针几乎一样，另外使用中有以下几点需要注意。
1. CComPtr已经保证了AddRef和Release的正确调用，所以不需要，也不能够再调用AddRef和Release。
2. 如果要释放一个智能指针，直接给它赋NULL值即可。
3. CComPtr本身析构的时候会释放COM指针。
4. 当对CComPtr使用&运算符（取指针地址）的时候，要确保CComPtr为NUL。（因为通过CComPtr的地址对CComPtr赋值时，不会自动调用AddRef，若不为NULL，则前面的指针不能释放，CComPtr会使用assert报警）
以刚才的程序为例：
void SomeApp( IHello * pHello )
{
CComPtr<IHello> pCopy = pHello;
OtherApp();
pCopy->Hello();
}
由于pCopy是一个局部的对象，所以即使OtherApp()抛出异常，pCopy也会被析构，指针能够被释放。
如果不想在程序临近发布前，还因为COM指针的引用计数造成崩溃的话，就牢记这一点吧：程序中除了参数之外，不要直接使用COM指针类型，一定要全部以CComPtr<IXXX>代替

UBUNTU设置开机启动图形应用程序-替换默认图形桌面

1. 禁止默认图形桌面的启动。
   编辑文件 /etc/init/lightdm.conf，在第12行附近，原句“ and runlevel [!06]” 改为“ and runlevel [!026]”。
   （注意：为使上这句有效，需要确保，/etc/init/rc-sysinit.conf，在第14行附近：env DEFAULT_RUNLEVEL=2。）

2. 利用etc/rc.local随机启动，startx脚本。
   编辑文件/etc/rc.local,在"exit 0"前添加一行：/usr/bin/mystartx
   （注：startx脚本的功能是启动，x-server及x-client。）

3. 修改startx脚本，文件末尾有一行
   “xinit "$client" $clientargs -- "$server" $display $serverargs”，
   在这一行的前面加入一行 client="自定义的程序路径"

关机重启，就可以了。

http://linux.about.com/od/linux101/l/blnewbie5_1.htm
Linux Shortcuts and Commands
Part 5 of the Linux Newbie Administrator Guide


vim 命令

d2d
HRESULT CShowPositionWnd::InitD2D() {
	HRESULT hr = S_OK;
	if(!m_d2d_factory) {
		HRESULT hr;
		hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &m_d2d_factory);
		if(SUCCEEDED(hr)) {
			hr = m_d2d_factory->CreateHwndRenderTarget(
				D2D1::RenderTargetProperties(),
				D2D1::HwndRenderTargetProperties(m_hWnd, D2D1::SizeU(m_window_width, m_window_height)),
				&m_render_target);
			if(SUCCEEDED(hr)) {
				hr = m_render_target->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &m_solid_brush);
			}
		}
	}
	return hr;
}
void CShowPositionWnd::OnPaint()
{
	if(IsIconic()) {
	} else {
		if(SUCCEEDED(InitD2D())) {
			m_render_target->BeginDraw();
			m_render_target->Clear(D2D1::ColorF(D2D1::ColorF::Yellow));
			m_render_target->DrawLine(D2D1::Point2(0, 5), D2D1::Point2(m_window_width, 5), m_solid_brush);
			m_render_target->EndDraw();
		} else {
		}
	}
}



ubuntu界面操作，下面的文档配置  及 命令行

http://blog.csdn.net/hustwarhd/article/details/3069066
startx启动过程分析
tartx的用法和xinit的基本一样：startx [ [ client ] options ... ] [ -- [ server ] options ... ]。
为什么呢？这是因为startx其实就是一个脚本，它启动X server就是通过调用xinit命令实现的，startx的参数将全部传给xinit。
因此，这些参数的意义和xinit的参数是一样的

System Settings can be run from the launcher (pinned by default), the Dash, or the power cog. But what command would I enter in a terminal window if I want to run it from there?
gnome-control-center 
Hope this helps you

如果隔一段时间不操作，电脑就会锁屏。怎么把锁屏给去掉
怎么不让ubuntu锁屏
Ubuntu小技巧――禁用Ubuntu的屏幕锁定
http://os.51cto.com/art/201310/413549.htm
登录Ubuntu，点击控制选项（位于菜单栏的最右边的图标）图标并选择“系统设置”
点击系统设置面板里的“亮度和锁屏”图标
最后，关闭“锁定屏幕选项”

操作系统Ubuntu 10.10
在菜单“系统”-》“系统管理”-》“用户和组”设置里有个密码“登录时不询问”已经修改为登录时不询问密码打钩；

系统重新启动不需要输入密码了。
顺便问一下挂起和睡眠后再启动系统总是需要输入密码，如何取消？

ubuntu12.04如何设置系统不休眠和不挂起
我的是桌面版的，在系统更新或者安装软件的时候，往往需要比较长的时间，但是过了一定时间，系统就会自动锁定屏幕，并且关闭网络连接，之前未完成的任务就无法继续了。
官网上说，12.04默认关闭了休眠功能，但是我从电池选项中修改设置如下，还是不行，求高手解答


关闭xorg图形界面
ctrl+ale+F3进入字符界面
ctrl+alt+f1启动shell登录 也可进入字符界面
alt+Ctrl+f7 再回到图形界面

tty'n',是文本模式下的控制台,n代表第几个控制台,可以用CTRL+ALT+F1...F7来切换

重启命令：
1、reboot
2、shutdown -r now 立刻重启(root用户使用)
3、shutdown -r 10 过10分钟自动重启(root用户使用) 
4、shutdown -r 20:35 在时间为20:35时候重启(root用户使用)
如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启
关机命令：
1、halt   立刻关机
2、poweroff  立刻关机
3、shutdown -h now 立刻关机(root用户使用)
4、shutdown -h 10 10分钟后自动关机
如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启


怎么修改etc/init目录下的配置文件？
以root权限用gedit打开文件 
用sudo gedit filename 来打开，不行，报错；
用su，然后输入密码，再gedit filename ，也不行，报错；
如何做？用su - （中划线代表用户名）
输入： su -
输入： 密码
再 gedit filename
OK


linux 常用命令
ls ll

这个不应该称得上是一个问题，但是，发现对于新手，确实是个难题因为少有人能够提到这一点，基本都是上来就直接讲用到的命令。
我开始的时候也曾经被这个问题困扰着，后来，搜了一会儿才弄明白。
1.在菜单内的附件上面有
2.在运行命令的输入框打开
3.快捷方式
4.快捷键
很好弄，在左上角的菜单上点一下，出来一列，在里面选择［附件］ 中的［终端］，点一下就OK。
那是快捷执行图标，可以把图标拖到桌面然后释放，以后在桌面上直接执行。同理，可以拖到上面的任务 栏里面。以后在上面的任务栏点一下就行了。
也不难弄，但不好找。首先按住Alt，然后按一下F2，出来一个运行框，在里面输入 gnome-terminal即可运行。
在这个运行框里，可以执行很多命令，想当于windows的［运行］。
把终端窗口打开放在鼠标右键，效果是在桌面或文件夹内的空白处右键点击，将出现“从终端打开”的快捷方式。那个需要使用一个软件。
安装很简单，打开终端，在里面输入: 
[c-sharp] view plaincopy
sudo apt-get install nautilus-open-terminal   

然后系统就在右键中自动添加该快捷方式了。
Ctrl+Alt+T，快捷键搞定（多谢霜晓雄鹰的评论）


xinit启动X Window System过程初探 (初始化 X Window System)
启动X主要有两种方法：一是Display Manager，如XDM、GDM、KDM，此种方法通过图形界面登录；另一种是通过xinit，此种方法适用于字符界面登录。

LightDM的目标是创造一个轻量、快速、具扩充性以及多桌面环境的X显示管理器[6]。它使用了很多不同的前端来渲染出登录画面[7]，所以又被称为Greeters
LightDM在Ubuntu 12.04作为默认的Unity登录前端

https://wiki.archlinux.org/index.php/Display_Manager_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)
显示管理器或登录管理器是一个在启动最后显示的图形界面。和窗口管理器一样，显示管理器有很多种。通常每个显示管理器都能进行一些定制
XDM: X 显示管理器 (xorg-xdm)
GDM: GNOME 显示管理器 (gdm)
KDM: KDE 显示管理器 (kdebase-workspace)
SLiM: 简单登录管理器 (slim)
LXDM: LXDE 显示管理器 (独立于桌面环境) (lxdm)
Qingy: getty 使用 DirectFB 的替代者 (qingy)
wdm: WINGs 显示管理器 (wdm)
CDM: 控制台显示管理器 (available in the AUR: cdm-git)
LightDM: Ubuntu 开发的 GDM 替代品，使用 WebKit (位于AUR: lightdm, lightdm-bzr)

http://www.embedu.org/Column/Column65.htm
很多LINUX初学者在学习linux图形方面的知识时会遇到一些概念，如：X、X11、Xfree86、WM、KDE、GNOME、QT、QT/E、Qtopia、DirectFB、Framebuffer、显卡加速驱动等等。理解它们之间是什么关系，对我们学习来说是非常重要的。写这篇文章的目的，就是想让大家明晰这些概念及它们之间的关系。（部分内容引用网络上的一些描述比较清晰的内容）
X11表示X协议的第16版.X11R6是X协议第11版第六次发行

XFree86 是X Windows server的X11R6执行程序.
有了协议就需要具体的软件来实现这个协议.
Xfree86是按照X协议的规定来完成X应用程序提交的在屏幕上显示的任务.
实现X协议的软件也并不只有XFree86, XFree86只是实现X协议的一个免费X服务器软件.
有些甚至能够在WINDOWS上有X服务器运行,这样您能够在linux系统上运行一个X应用程序然后在另一台windows系统上显示.
只是在LINUX上最常用的是XFree86.不过现在的linux发行版大多用Xorg了

窗口管理器的作用就是最大化、最小化、移动、关闭窗口等.而这些不是X服务器来负责完成的

KDE 和GNOME是LINUX里最常用的图像界面操作环境,他们不但仅是个窗口管理器那么简单, KDE是K Desktop Environment 的缩写,他不但是个窗口管理器,更有很多配套的应用软件和方便使用的桌面环境,比如任务栏,开始菜单,桌面图标等等.GNOME是GNU Network Object Model Environment 的缩写,和KDE相同,也是个功能强大的综合环境

QT/E 是用于嵌入式Linux系统的QT版本.QT/E中去掉了X lib的依赖而直接工作于Frame Buffer上,因而应用程序处理过程效率比较高.它的运行只要有Framebuffer设备就可以了,不需要X服务器的支持.但其本身运行也是有服务器和客户端的概念

DirectFB项目是由德国Convergence公司推动的Open source计划的一部分,它是专门为满足嵌入式设备要求而开发的小巧、强大、灵活和易于使用的图形系统,并且试图成为一个建构于Linux Framebuffer Device之上的新图形标准.它在FrameBuffer的基础上提供了图形加速、输入设备处理提取、透明窗口和多重显示层的功能,能够对嵌入式系统GUI有较好的支持.与那些通用的嵌入式GUI系统相比,它具有非常简洁、高效的体系结构和硬件图形加速功能

http://www.cnblogs.com/montya/archive/2011/09/09/2172001.html  rc.local开机器不执行.png
解决linux下/etc/rc.local开机器不执行的原因
前不久因项目需要写了开机启动其他程序的shell脚本,因工作忙，调试完给了技术支持人员，也没去注意过。

到后来，有几台服务器突然被重启了，这时候领导问，怎么开机启动的脚本没起作用，还被批了一顿，哎，做事虎头蛇尾,活该！

然后去查，一直没查到原因，

手动执行都是正确的，在排除了权限原因和脚本问题后，很郁闷，怎么放到开机启动项目中就无法执行了呢。

于是去查linux开机启动过程信息。google下，看了下关于一些开机启动启的资料，发现了开机启动程序的级别为3.

果断顺藤莫瓜，找到了这个目录 /etc/rc.d/rc3.d，进去一看恍然大悟。



我的rc.local文件是在 /etc/rc.local中（网上都是说写在这里，我是按照网上来弄的），而我查看了系统指向rc.local文件的路径是 /etc/rc.d/rc.local

后来把开机启动的脚本配置到/etc/rc.d/rc.local中（或者把S99local指向 /etc/rc.local也行），重启检查，成功！

总结:主要还是对linux系统不熟悉，这是个漫长的过程，有时间得多看看这方面的书籍。


改rc.local文件开机自动运行脚本
1.开机自运行
简单的处理开机自运行的方法是修改rc.local文件。此文件位于/etc目录下面.
在默认情况下，rc.local是一个空的脚。您只要修改它就可以了。要注意的是，在此文件中运行的命令其依赖的进程是否运行。本人再实验的时候由于想在
开机时启动dia.试了好多次都失败。我想可能是界面进程还没有启动。我的实验脚本为
       echo   “hello. rc.local” >>home/shanfeng/rc.local 实验成功
在/etc目录下面还有rc*.d的目录。这些目录里面放在很多/etc/init.d/下面脚本的软链接,操作系统根据不同的运行等级，选择运行其中下的脚本。您也可以修改它们达到开机自运行的目的。
2。定时任务
介绍一种简单的处理方式
用cron处理定时任务,首先要保证cron操作已经运行。如果安装了cron 的话。正常情况下cron已经开机自运行了，如果没有运行的话。
/etc/init.d/cron start
用crontab来安排定时任务
crontab [-u user] {-l| -r |   -e}
-l:显示任务
-e:编辑任务
-r:清空任务
任务格式为:
分 时 星期 月份 年 操作命令
eg:
1. * 14 * * * echo ” look me”>>/home/shanfeng/test 表示每天14点运行一次
2. 0-59/2 * * * * echo “look me” >>/tmp/test 表示每两分钟运行一次
3. * 2,15 * * * echo “look me ” >>/tmp/test 表示2与15点运行一次
* : 表示任意 -:表示区间.   / :表示频率   , ：表示枚举

http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html
Linux 的启动流程
开机启动程序加载完毕以后，就要让用户登录了。

一般来说，用户的登录方式有三种：
　　（1）命令行登录
　　（2）ssh登录
　　（3）图形界面登录
这三种情况，都有自己的方式对用户进行认证。
（1）命令行登录：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。
输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。
如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。
（2）ssh登录：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh ），取代getty和login，然后启动shell。
（3）图形界面登录：init进程调用显示管理器，
Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），
然后用户输入用户名和密码。
如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话

linux 在字符界面中如何查看超出屏幕显示范围的内容
你是不是指哪些被滚到屏幕上面的部分？可以用shift+pageUp/pageDown进行滚动

Linux字符界面下对界面进行翻页的几个操作
1.如果文件内容很长，不用 cat命令查看，而使用less、more这样单页显示的工具。
2.使用编辑器 view（vi的只读版本）、nano 等都可以。
3.使用输出重定向符号 ">"，把显示的内容重定向到文件中去，再来查看。
如：假如当前文件夹中有很多文件，要查看文件的信息，可以用>把ls的输出由stdout重定向到指定文件filelist中：ls -l > filelist
4.不得不翻屏的时候可以使用 Shift+PageUp/PageDown，但能翻的不多

cat aa.txt | more
yourcmd | less  例如  ll /etc/init.d | more
yourcmd | more




less textfile
vi testfile

sudo kill 3486

http://tldp.org/LDP/gs/gs.html
Linux Installation and Getting Started

Bootable floppies for PCs usually contain MS-DOS or miniature versions of Linux. The most commonly available floppy disk can hold only 1.4 MB of data in its standard format, making it impractical for loading large operating systems. The use of boot floppies is in decline, due to the availability of other higher-capacity options, such as CD-ROMs or USB flash drives.

The first step is to boot the Linux installation media. In most cases, this is a “Bootable floppies” which contains a small Linux system.
http://www.linfo.org/make_linux_boot_floppy.html
http://www.pendrivelinux.com/boot-multiple-iso-from-usb-via-grub2-using-linux/

Distributions described as lightweight[edit]

Alpine Linux - A security-oriented, lightweight Linux distribution based on uClibc and BusyBox.[4] Mini download is 60 MB; base system (excluding kernel) is under 5 MB.
antiX - Lightweight version of its parent distribution MEPIS Linux, based on Debian testing. Core Install: 128 MB, Base approx 300 MB. Package Manager: Synaptic[5]
BasicLinux - A very lightweight distribution capable of running on an Intel 386 and 3 MB of RAM[6][7]
Bodhi Linux - A lightweight and minimalistic distribution, based on Ubuntu 12.04[8]
CrunchBang Linux - A relatively large (771MB) Debian based distribution designed primarily for speed and ease of use.[9][10]
Damn Small Linux - Download 50 MB. Additional software available as "DSL Extensions" and using the Debian APT tool, which has to be installed. "Light enough to power a 486DX with 16MB of Ram"[11][12]
Feather Linux - Lightweight Linux Distribution derived from Knoppix. Now dormant.[13][14]
Lubuntu - Lightweight in comparison to Ubuntu, it uses the LXDE desktop.[1]
Nanolinux - 14 MB distribution based on Core Linux. [15]
Peppermint Linux OS - Based on Lubuntu.[16]
Porteus - It weighs in at under 300 MB, making it a lightweight contender.[17] Comes with the LXDE and KDE desktops
Puppy Linux - Lightweight relative to most other Linux distributions.[18] Download: 133MB. Package Manager: Synaptic (Lucid Puppy Ubuntu Compatible version)
Semplice Linux lightweight, fast and simple, based on Debian Sid.[19]
SliTaz - 35 MB distribution. Package Manager is Tazpkg with its repository of packages[11]
Tiny Core Linux - 12 MB distribution. Software repository: TCZ packages[20]
Trisquel Mini - Lightweight version of Trisquel with LXDE[21]

http://en.wikipedia.org/wiki/Windows_To_Go
Windows To Go是Windows 8的一种企业功能，被内置于Windows 8企业版（Windows 8 Enterprise）中。
[1]对于满足Windows 8硬件要求的电脑，Windows To Go可使Windows 8从USB驱动器中启动并运行，不必考虑电脑上运行的操作系统（Mac和Windows RT不被支持）。
[1-2]Windows To Go 的设计并不旨在代替台式计算机、便携式计算机，或取代其他移动产品。 
恰恰相反，它为有效使用备用的工作场所方案资源提供有力支持

/etc 

etc不是什么缩写，是and so on的意思 来源于 法语的 et cetera 翻译成中文就是 等等 的意思. 至于为什么在/etc下面存放配置文件， 按照原始的UNIX的说法(linux文件结构参考UNIX的教学实现MINIX) 这下面放的都是一堆零零碎碎的东西, 就叫etc, 这其实是个历史遗留.

这个目录一般用来存放程序所需的整个文件系统的配置文件.

守护进程，也就是通常说的Daemon进程，是Linux中的后台服务进程
在linux或者unix操作系统中在系统的引导的时候会开启很多服务，这些服务就叫做守护进程。为了增加灵活性，root可以选择系统开启的模式，这些模式叫做运行级别，每一种运行级别以一定的方式配置系统。 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断

status state 区别
status 与 state 的区别

status 指人时暗指相对的地位，指物时相当于 situation。

state 人或物存在或所处的状态，和 condition 大体上可以互换使用。

 

situation 较狭义地指由环境综合决定的特定时间上的状态或情形。

condition 指一定的原因/条件或环境所产生的特定情况。

 

以 Recordset 为例

Recordset 具有 Status 和 State 属性，说明二者还是有区别的。

Recordset.Status 表示进行批处理后，当前记录的情况。结果有：操作被取消，结果未被保存；记录被锁无法保存……。

Recordset.State 表示 Recordset 对象是打开的，还是关闭的，还是正在执行异步操作。

 

再举例子

最近的国际形式如何？status。

水在标准大气压下 100 摄氏度时是什么状态？state。


善用backtrace解决大问题
一．用途：
主要用于程序异常退出时寻找错误原因
二．功能：
回溯堆栈，简单的说就是可以列出当前函数调用关系
三．原理：
1． 通过对当前堆栈的分析，找到其上层函数在栈中的帧地址，再分析上层函数的堆栈，再找再上层的帧地址……一直找到最顶层为止，帧地址指的是一块：在栈上存放局部变量，上层返回地址，及寄存器值的空间。
2． 由于不同处理器堆栈方式不同，此功能的具体实现是编译器的内建函数__buildin_frame_address及__buildin_return_address中，它涉及工具glibc和gcc, 如果编译器不支持此函数，也可自己实现此函数，举例中有arm上的实现

利用backtrace和backtrace_symbols函数打印调用栈信息
在头文件"execinfo.h"中声明了三个函数用于获取当前线程的函数调用堆栈。

#include <execinfo.h>
 int backtrace(void **buffer, int size);
 char **backtrace_symbols(void *const *buffer, int size);
 void backtrace_symbols_fd(void *const *buffer, int size, int fd);
 
 void backtrace_symbols_fd (void *const *buffer, int size, int fd)
    backtrace_symbols_fd与backtrace_symbols 函数具有相同的功能,不同的是它不会给调用者返回字符串数组,而是将结果写入文件描述符为fd的文件中,每个函数对应一行.它不需要调用malloc函数,因此适用于有可能调用该函数会失败的情况
	backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)

Vinagre 是新近才出现的 VNC 客户端，它主要为 GNOME 桌面环境而设计。Vinagre 的主要功能包括：能够同时连接多个机器，可以收藏经常使用的连接，支持浏览 VNC 服务器网络，不需要为每个连接都提供密码等等

GtkWidget转换为GObject类型，格式一般为G_OBJECT(button)
GTK_WINDOW
GTK_DIALOG

GTK-WARRING:  cannot  open  display!
#include <gtk/gtk.h>  <--用到了图形库，当然不能在字符模式下运行了，在GNOME下可以正常运行   x server没有启动.
setenv DISPLAY 192.168.0.1:0  
指定一个GUI的接受端即可

尝试在纯字符界面下运行Gtk的界面程序，提示信息：cannot open display。
ioctl是设备驱动程序中对设备的I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下：int ioctl(int fd, int cmd, …)；其中fd就是用户程序打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和cmd的意义相关的。ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就能在用户程序中使用ioctl函数控制设备的I/O通道。


GTK(GIMP Toolkit)是一个Linux平台下基于Xwindow图形窗口的图形用户编程接口工具,可以借助它来开发Linux平台下基于Xwindow的图形用户界面。
这是不是意味着Gtk小程序不能在纯字符界面下运行？？我也不确定，但是minigui写的就可以，所以不死心，想问问谁能给个确切的答案

你都说了，人家gtk本身就是一套“图形用户编程接口工具”，程序里调用gtk的函数当然就是为了显示图形，你不启图形当然不成。

不是这样的，可以不启用Gnome这样的GUI环境，但只要所运行的程序的底层库已加载，Xserve有支持（或是直接用FB驱动），就可以运行图形程序，比如嵌入式系统就是这样的

gtk_window_fullscreen ()
void                gtk_window_fullscreen               (GtkWindow *window);
Asks to place window in the fullscreen state. Note that you shouldn't assume the window is definitely full screen afterward, because other entities (e.g. the user or window manager) could unfullscreen it again, and not all window managers honor requests to fullscreen windows. But normally the window will end up fullscreen. Just don't write code that crashes if not.

You can track the fullscreen state via the "window-state-event" signal on GtkWidget.

window :a GtkWindow

spicy 鼠标退出虚拟机的方法 shift+f12
spicy fullscreen escape
To get out use Shift+F12, not logical I know, but it works :)

SPICE建立Channel的详细步骤及消息传递流程
s: reds_init_net, 注册回调reds_accept 创建listen socket，增加监听watch_add(reds_accept),后续加入select监听

c: RedChannel::run-》RedChannelBase::connect() -》RedPeer::connect_unsecure发送连接请求，等待服务端accept

s: reds_accept
    -》spice_server_add_client，reds_handle_new_link
        -》async_read_handler，异步接收数据，需要客户端发送数据，填充link->link_header结束
c: RedChannelBase::link() -》link_mess.channel_type = _type，send 发送link请求，recive等待
s:            -》reds_handle_read_header_done，
                -》async_read_handler，填充link->link_mess
                    -》reds_handle_read_link_done
                        ―》async_read_handler，填充link->auth_mechanism
                            ->reds_handle_auth_mechanism
                                ->reds_get_spice_ticket
                                   ―》async_read_handler，填充link->tiTicketing.encrypted_ticket.encrypted_data
                                       ―》 reds_handle_ticket
                                           ->reds_handle_link
                                             ->if (link->link_mess->channel_type == SPICE_CHANNEL_MAIN) { reds_handle_main_link(link); }

   async_read_handler-》reds_stream_read堵塞，等待客户端发送消息
 
reds_handle_main_link流程
    -》reds_send_link_result(link, SPICE_LINK_ERR_OK);

c->s: SPICE_CHANNEL_MAIN s: reds_handle_main_link，此过程的详细步骤如上

s->c: SPICE_MSG_MAIN_INIT, c: handle_init

c->s: SPICE_MSGC_MAIN_ATTACH_CHANNELS s: reds_send_channels

s->c: SPICE_MSG_MAIN_CHANNELS_LIST c: handle_channels



gtk 的控件是建立在goject的基础上的, 换句话说, gtk的所有控件都是从gobject派生而来. 如果要学习 gtk 的对象模型, 可以参考 gobject 的相关实现. 

gtk 的控件家族中, 大部分都是所谓的 gtk widget。
gtk widget 是gtk抽象出来的一个上层概念, 这样的一个widget, 在中文的表述中就代表一个控件。
这样的widget只是逻辑上的, 也就是说, 在逻辑上它是一个控件, 实际上可能并没有单独的窗口资源和它相应。

所以在 gtk 的控件家族中, 从这个角度可以将 widget 分成两类:

1. widget 有真正的窗口资源和它对应, 比如一个 toplevel 的 GtkWindow, 在gtk的底层会有一个GdkWindow和它相对应。
一个GdkWindow, 在 X11 中就对应于一个 X11 的window。
在 gtk 中, 只能在 GdkWindow 上进行绘图。
这样的控件, 我们可以为它设置背景,窗口的背景一旦设置, 就由XServer负责在必要的时候重绘。
而对于前景, 在适当的时候(当窗口由不可见到可见), XServer会发送Expose消息给这样的控件。
控件根据需要在前景上进行重绘, 在gtk的实现中, 控件都会实现自己的expose消息处理函数。

这个消息为 RUN_LAST方式运行, 
所以当用户自己用 g_signal_connect 注册了一个 expose 消息处理, 
并且在消息处理函数中 return TRUE, 就会将这个默认的消息变成无效, 
所以如果对 gtk 自己提供的绘制功能不满意的话,
可以利用这种手段自己实现某些绘制功能.

2. widget 没有单独的一个 GdkWindow 和它相对应, 
比如 gtk button 就是这样的一个控件,
自己没有单独的 GdkWindow, 
当这样的控件需要绘制的时候, 就会在父控件的GdkWindow上绘制. 

比如gtk button, 假设一个 button 在一个 toplevel 的窗口中, 
当窗口从不可见到可见的时候, XServer 就会给 toplevel window 发送 expose event, 
由于toplevel 是一个container, toplevel window 在响应自己的 expose 之后, 
会向所有的没有 GdkWindow 的子控件(button)发送 expose event, 
当 button 收到消息后, 就会在它的父 widget(toplevel window) 的相应位置绘制自己.

如果要实现不规则的窗口, 只能使用第一类控件.

window7打开用户目录 C:\Users
                    C:\Users\Administrator\AppData\Roaming

backslash (\ or slash (/)

chkdsk基于所用的文件系统，创建和显示磁盘的状态报告。Chkdsk 还会列出并纠正磁盘上的错误。如果不带任何参数，chkdsk 将显示当前驱动器中的磁盘状态。

语法
chkdsk [volume:][[Path] FileName] [/f] [/v] [/r] [/x] [/c] [/l[:size]]

参数
volume: 
指定驱动器号（冒号分隔）、装入点或卷名。 
[Path} FileName] 
指定需要 chkdsk 检查碎片整理的文件或文件集的位置和名称。使用通配符（* 和 ?）可以指定多个文件。 
/f 
修复磁盘上的错误。必须锁定磁盘。如果 chkdsk 无法锁定驱动器，则会显示一条消息，询问您是否希望在下次重新启动计算机时检查该驱动器。 
/v 
当检查磁盘时，显示所有目录中每个文件的名称。 
/r 
找到坏扇区并恢复可读取的信息。必须锁定磁盘。 
/x 
仅在 NTFS 上使用。如果必要，首先强制卸载卷。该驱动器的所有打开句柄都无效。/x 还包含了/f 的功能。 
/i 
仅随 NTFS 使用。对索引项执行充分检查，降低运行 chkdsk 的所用时间量。 
/c 
仅随 NTFS 使用。跳过文件夹结构中的周期检查，减少运行 chkdsk 所需的时间量。 
/l[:size] 
仅随 NTFS 使用。将日志文件的大小更改为由用户输入的大小。如果省略该参数，则 /l 会显示当前日志文件的大小。 
/?
在命令提示符显示帮助。 
注释
运行 chkdsk 
要在固定磁盘上运行 chkdsk 命令，您必须是该 Administrators 组的成员。

重新启动时检查锁定的驱动器 
如果希望 chkdsk 修复磁盘错误，则此前不能打开该驱动器上的文件。如果有文件打开，会显示下述错误消息：

Chkdsk cannot run because the volume is in use by another process.Would you like to schedule this volume to be checked the next time the system restarts?(Y/N)

使用 Ubuntu 软件中心搜索synaptic，找到“新立得软件包管理器”，一般第一个搜索结果就是了;


如果选择下次重新启动计算机时检查该驱动器，则重新启动计算机后 chkdsk 会自动检查该驱动器并修复错误。如果该驱动器分区为启动分区，则 chkdsk 在检查完该驱动器后会自动重新启动计算机。

报告磁盘错误 
chkdsk 命令会检查磁盘空间和文件分配表 (FAT)以及 NTFS 文件系统的使用情况。Chkdsk 在状态报告中提供特定于每个文件系统的信息。状态报告显示文件系统中找到的错误。在活动分区上运行 chkdsk 时，如果未含 /f 命令行选项，则它可能会因为无法锁定该驱动器而报告虚假信息。应该不定期使用 chkdsk 检查每个磁盘上的错误。

修复磁盘错误 
只有指定 /f 命令行选项，chkdsk 命令才修复磁盘错误。Chkdsk 必须可以锁定驱动器以纠正错误。由于修复通常会更改磁盘的文件分配表，有时还会丢失数据，所以 chkdsk 会首先发送如下所示的确认消息：

10 lost allocation units found in 3 chains.

Convert lost chains to files?

如果按 Y，Windows 会在根目录中将所有丢失链保存在一个名为 Filennnn.chk 的文件中。chkdsk 结束后，可以查看这些文件是否包含了所需的数据。如果按 N，Windows 会修复磁盘，但对于丢失的分配单元，它不保存其内容。

如果不使用 /f 命令行选项，则在有文件需要修复时，chkdsk 会发送消息，但它不修复任何错误。

如果在大磁盘（例如，70 GB）或有大量文件（数百万）的磁盘上使用 chkdsk /f，这可能要花很长时间（比如说，数天）才能完成。因为 chkdsk 直到工作完成它才会交出控制权，所以计算机在这段时间内将不可用。

检查 FAT 磁盘 
Windows 以下列格式显示 FAT 磁盘的 chkdsk 状态报告：

Volume Serial Number is B1AF-AFBF

72214528 bytes total disk space

73728 bytes in 3 hidden files

30720 bytes in 12 directories

11493376 bytes in 386 user files

61440 bytes in bad sectors

60555264 bytes available on disk

2048 bytes in each allocation unit

35261 total allocation units on disk

29568 available allocation units on disk 

检查 NTFS 磁盘 
Windows 以下列格式显示 NTFS 磁盘的 chkdsk 状态报告：

The type of the file system is NTFS.

CHKDSK is verifying files...

File verification completed.

CHKDSK is verifying indexes...

Index verification completed.

CHKDSK is verifying security descriptors...

Security descriptor verification completed.

12372 kilobytes total disk space.

3 kilobytes in 1 user files.

2 kilobytes in 1 indexes.

4217 kilobytes in use by the system.

8150 kilobytes available on disk.

512 bytes in each allocation unit.

24745 total allocation units on disk.

16301 allocation units available on disk.

存在打开文件的情况下使用 chkdsk 
如果该驱动器上有打开的文件，则指定 /f 命令行选项后，chkdsk 会发送错误消息。如果未指定 /f 命令行选项并且存在打开的文件，则 chkdsk 会报告磁盘上丢失的分配单元。如果打开的文件没有记录在文件分配表时，可能会发生这种情况。如果 chkdsk 报告大量分配单元丢失，可以考虑修复该磁盘。

查找物理磁盘错误 
使用 /r 命令行选项可查找文件系统中的物理磁盘错误。

报告磁盘坏扇区 
在磁盘第一次准备运行时，chkdsk 报告的坏扇区标记为损坏。它们不会造成危险。
 chkdsk 完成任务后报告的退出码。
 
0 没有发现错误。 
1 错误已找到并修复。 
2 已执行清理磁盘（例如碎片收集），或者因为没有指定 /f 而未执行清理磁盘。 
3 由于未指定 /f 选项，无法检查磁盘，错误不能修复或错误未修复。 

故障恢复控制台提供了带有不同参数的 chkdsk 命令。 
范例
如果要检查驱动器 D 中的磁盘，并且希望 Windows 修复错误，请键入：

chkdsk d:/f

如果遇到错误，chkdsk 会暂停并显示消息。Chkdsk 完成任务时会显示列有磁盘状态的报告。除非 chkdsk 已完成任务，否则无法打开指定驱动器上的任何文件。

在 FAT 磁盘上，要检查当前目录中所有文件的不相邻块，请键入：

chkdsk *.*

Chkdsk 显示状态报告，然后列出符合具有不相邻块条件的文件。

spice-gtk 在Linux编译
autotools, relatively recent (some workaround like 'mkdir m4' mentioned below)
pixman >= 1.7.1 (any recent)
celt = 0.5.1.3 (this is important, newer versions use a different protocol)
alsa
log4cpp
openssl
libXrandr
cegui
libgcrypt-devel
pyparsing - only if you build from git (tarball releases don't require it)
dev86 (required for?)
iasl (and this?)
for smartcard:
nss

构建一个开发环境，第三库等等。

线程同步：
互斥体的类型  锁的类型
        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;

boost condition(创建，销毁，发送信号，等待锁+条件) 、 mutex+lock , 

Differences between <semaphore.h> and <sys/sem.h>
<sys/sem.h> provides the interface for XSI (originally Unix System V) semaphores.
<semaphore.h> defines POSIX semaphores, which are designed in such a way that they can be implemented entirely in userspace, except in the contended case where the process will call into the kernel to go to sleep. 

信号量（英语：Semaphore）又称为号志，它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待（busy waiting）的一种方法。
信号量的概念是由荷兰计算机科学家艾兹格・迪杰斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。

计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。
运作方式：
初始化，给与它一个非负数的整数值。
运行 P（wait()），信号量S的值将被减少。企图进入临界区段的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区段。
运行 V（又称signal()），信号量S的值会被增加。退出离开临界区段的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。

http://www.fullhan.com/cp_35.asp
FH8735 高性能H.264编码芯片

        FH8735是一款高性能的多通道视音频编码芯片，支持H.264 Main Profile和Baseline Profile。FH8735具有1路1920*1080，2路1280*720或者8路标清的实时编码能力、内置丰富的视频预处理功能和多样的I/O接口，可满足视频监控产品的各种需求，能有效提高产品的集成度并降低系统成本，为视频监控产业的高清化提供强大的编码动力。 
          FH8735的目标应用包括嵌入式DVR、视频采集卡、DVS和百万素网络摄像机
		  
		  富瀚微电子有限公司成立于2004年4月，专注于视频监控芯片及解决方案，满足高速增长的数字视频监控市场对视频编解码和图像信号处理的芯片需求。
   富瀚提供高性能视频编解码SoC和图像信号处理器芯片，以及基于这些芯片的视频监控产品方案。 
    富瀚致力于与国内外设备制造商、解决方案提供商建立紧密合作关系，共同把握市场契机，为客户提供高性价的产品和服务，持续创造价值

http://www.csdn.net/article/2014-01-03/2818015-tiny-hardware-development-boards-of-2013
2013年终盘点：10款最精巧的硬件开发板

// 此源文件在Windows平台上必须保存为Unicode格式（即UTF-16小尾）
// 因为包含的汉字“??”，不能在简体中文版Windows默认的代码页936（即GBK）中表示。
// 该汉字在UTF-16小尾序中用4个字节表示，
// Windows操作系统能正确显示这样的在UTF-16需用4字节表示的字符
// 但是Windows API不能正确处理这样的在UTF-16需用4字节表示的字符，把它判定为2个UCS-2字符
 
#include <windows.h>
int main()
{
	const wchar_t lwc[]=L"??";
 
	MessageBoxW(NULL, lwc, lwc, MB_OK);
 
	int i = wcslen(lwc);
	printf("%d\n", i);
	int j = lstrlenW(lwc);
	printf("%d\n", j);
 
	return 0;
}

UTF8 <-> UNICODE
Class template std::wstring_convert performs conversions between byte string std::string and wide string std::basic_string<Elem>, 
using an individual code conversion facet Codecvt. 
std::wstring_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. 
The standard facets suitable for use with std::wstring_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions

void test()
{
wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
string s8 = u8"This is a UTF8 string";
wstring s16 = converter.from_bytes(s8);
string s88 = converter.to_bytes(s16);
if (s8!=s88)
cerr <"Insane!\n";
}

string <-> number
to_string

Preventing Logoff or Suspend During a Burn
If proper precautions are not made within an application, it is possible for a user to log off during a burn operation. This leads to the interruption of the burn process, which can result in lost data and possibly render the disc unusable.
To avoid this problem, the application should process the WM_QUERYENDSESSION message which is delivered prior to log off. If the application receives this message while performing a burn operation, return FALSE to cancel the logoff procedure. If the application allows the user to decide whether to continue logging off, a warning should be provided indicating that user will lose data.
Power transitions during the burn process can also create potential problems in the success of a burn activity. Preventing these complications during the burn process requires an application to be aware of when power transitions are about to take place. This is accomplished by by enabling the application to process the WM_POWERBROADCAST message. Applications developed for Windows XP or Windows Server 2003 can return BROADCAST_QUERY_DENY in response to PBT_APMQUERYSUSPEND, preventing Suspend during the burn process.
Due to changes in the Power Management Model for Windows Vista and Windows Server 2008, the PBT_APMQUERYSUSPEND event is no longer delivered to applications. Instead the PBT_APMSUSPEND event is delivered, providing two seconds for an application to prepare for the transition.
As a result of these changes, it is recommended that applications call the SetThreadExecutionState function to prevent a system idle time-out which ordinarily results in the transition to Suspend. It is important to remember that calling this function with the appropriate flags set will only prevent system idle, not an in-progress Suspend.


http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
Some OS-specific interfaces:

Mac OS X: _NSGetExecutablePath() (man 3 dyld)
Linux: readlink /proc/self/exe
Solaris: getexecname()
FreeBSD: sysctl CTL_KERN KERN_PROC KERN_PROC_PATHNAME -1
FreeBSD if it has procfs: readlink /proc/curproc/file (FreeBSD doesn't have procfs by default)
NetBSD: readlink /proc/curproc/exe
DragonFly BSD: readlink /proc/curproc/file
Windows: GetModuleFileName() with hModule = NULL

To summarize:

On Unixes with /proc really straight and realiable way is to:

readlink("/proc/self/exe", buf, bufsize) (Linux)

readlink("/proc/curproc/file", buf, bufsize) (FreeBSD)

readlink("/proc/self/path/a.out", buf, bufsize) (Solaris)

On Unixes without /proc (i.e. if above fails):

If argv[0] starts with "/" (absolute path) this is the path.

Otherwise if argv[0] contains "/" (relative path) append it to cwd (assuming it hasn't been changed yet).

Otherwise search directories in $PATH for executable argv[0].

Afterwards it may be reasonable to check whether the executable isn't actually a symlink. If it is resolve it relative to the symlink directory.

This step is not necessary in /proc method (at least for Linux). There the proc symlink points directly to executable.

Note that it is up to the calling process to set argv[0] correctly. It is right most of the times however there are occasions when the calling process cannot be trusted (ex. setuid executable).

On Windows: use GetModuleFileName(NULL, buf, bufsize)

boost 提出EXE当前路径
boost 从文件路径里提出 文件名，及路径

filesystem::path 类的成员
// decomposition 分解
        path  root_name() const;
        path  root_directory() const;
        path  root_path() const;
        path  relative_path() const;
        path  parent_path() const;
        path  filename() const;
        path  stem() const;
        path  extension() const;
		
 // query
        bool empty() const;
        bool has_root_name() const;
        bool has_root_directory() const;
        bool has_root_path() const;
        bool has_relative_path() const;
        bool has_parent_path() const;
        bool has_filename() const;
        bool has_stem() const;
        bool has_extension() const;
        bool is_absolute() const;
        bool is_relative() const;

		
// modifiers
        void  clear();
        path& make_absolute(const path& base);
        path& make_preferred();  // ISO/IEC 9945: no effect. Windows: convert slashes to backslashes
        path& remove_filename();
        path& replace_extension(const path& new_extension = path());
        void  swap(path& rhs);
		
#include <boost/filesystem.hpp>
std::string filename_noext;
filename_noext = boost::filesystem::path("D:\\files\\file.lua").stem().string().
const char* result_as_const_char = filename_noext.c_str();

wchar_t exe_path[MAX_PATH] = {0};
	::GetModuleFileName(GetModuleHandle(NULL), exe_path, MAX_PATH);
	::PathRemoveFileSpecW(exe_path);

IWebBrowser2
http://msdn.microsoft.com/en-us/library/aa752038(v=vs.85).aspx
Windows Internet Explorer's components can easily be reused thanks to its Component Object Model (COM)-based architecture. 
Two commonly used components are shdocvw.dll (the WebBrowser Control) and mshtml.dll (code-named "Trident").

BEGIN_EVENTSINK_MAP(CWebPageDlg, CDialogEx)
	ON_EVENT(CWebPageDlg, IDC_EXPLORER1, 259, CWebPageDlg::DocumentCompleteExplorer1, VTS_DISPATCH VTS_PVARIANT)
END_EVENTSINK_MAP()

Defines an OLE automation function in a dispatch map
DISP_FUNCTION(theClass, pszName, pfnMember, vtRetVal, vtsParams )

BEGIN_DISPATCH_MAP(CFixHtmlView, CHtmlView)
	DISP_FUNCTION(CFixHtmlView, "ParentLogin", ParentLogin, VT_BOOL, VTS_I4 VTS_I4)
	DISP_FUNCTION(CFixHtmlView, "ChildFinish", ChildFinish, VT_I4, VTS_I4 VTS_I4 VTS_BSTR)
	DISP_FUNCTION(CFixHtmlView, "ParentReg",ParentReg,VT_BOOL,VTS_I4 VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CFixHtmlView, "sessionOverTime",sessionOverTime,VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CFixHtmlView, "eyeOver",eyeOver, VT_BOOL, VTS_I4 VTS_I4)
END_DISPATCH_MAP()
<input type="button" onClick="send_result('123')" />
<script text="text/javascript">
function send_result(str){
	window.external.eyeOver(0,0);
}
</script>

Interface definition file 是一个接口文件，它应该由用户利用IDL(interface definition language)语言编辑uuidgen产生的IDL原型文件而成。IDL是一种用来说明操作（过程或函数），操作的参数以及数据类型的语言，它在语法上继承于C语言，但形式上和C语言有很多不同，当然也有一些符合自己特点的适合于分布计算的特殊语法。具体可参看DCE RPC specification中的IDL language specification部分 (idl.jpg)

IDL文件可以定义C和C++风格的结构，并可用它们作为函数的参数。 当IDL文件中有一个library时，MIDL将生成一个类型库
http://www.vckbase.com/index.php/wv/1218
COM 在设计初期，就定了一个目标：要能实现跨语言的调用。既然是跨语言的，那么组件的接口描述就必须在任何语言环境中都要能够认识。怎么办？用 .h 文件描述？------ C语言程序员笑了，真方便！BASIC 程序员哭了:-( 因此，微软使用了一个新的文件格式---IDL文件（接口定义描述语言）。IDL 是一个文本文件，它的语言语法比较简单，很象C。具体 IDL 文件的讲解，见下一回《COM 组件设计与应用（八）之添加新接口》。IDL 经过编译，生成二进制的等价类型库文件 TLB 提供给其它语言来使用。图三示意了 ATL COM 程序编译的过程
idl2-ATL 组件程序编译过程.jpg
说明1：编译后，类型库以 TLB 文件形式单独存在，同时也保存在目标文件的资源中。因此，我们将来在 #import 引入类型库的时候，既可以指定 TLB 文件，也可以指定目标文件；
说明2：我们作为 C/C++ 的程序员，还算是比较幸福的。因为 IDL 编译后，特意为我们提供了 C 语言形式的接口文件。
说明3：IDL 编译后生成代理/存根源程序，有：dlldata.c、xxx_p.c、xxxps.def、xxxps.mak，我们可以用 NMAKE.EXE 再次编译来产生真正的代理/存根DLL目标文件(注1)

idl文件转换成.h文件，你可以使用midl命令生成  idl-midl-h.gif
将idl文件加入到工程项目中，然后右键属性在output中生成文件即可

boost::date_time 的时间 -> 字符串的转换
                 字符串 -> 时间的转换

		CPositionData tmp(x, y, boost::posix_time::ptime::is_not_a_date_time); 这句话是错的，为什么？ 
		CPositionData tmp(x, y, boost::posix_time::not_a_date_time); 这个是正确的

时间点构造
tmp.time = boost::posix_time::microsec_clock::local_time();
ptime d3(not_a_date_time);

时长构造
tmp.duration = tmp.time - tmp.time;  构造时间段  tmp.duration = boost::posix_time::time_duration(0, 0, 0, 0);

using namespace boost::posix_time;
time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds

using namespace boost::posix_time;      
time_duration td = hours(1) + seconds(10); //01:00:01
td = hours(1) + nanoseconds(5); //01:00:00.000000005

Syntax	Description
Example
time_duration(hours,
              minutes,
              seconds,
              fractional_seconds)
Construct a duration from the counts. The fractional_second parameter is a number of units and is therefore affected by the resolution the application is compiled with (see Build-Compiler Information). If the fractional_seconds argument exceeds the limit of the compiled precision, the excess value will be "carried over" into the seconds field. See above for techniques to creating a resolution independent count.
time_duration td(1,2,3,9);
//1 hr 2 min 3 sec 9 nanoseconds
time_duration td2(1,2,3,123456789);
time_duration td3(1,2,3,1000);
// with microsecond resolution (6 digits)
// td2 => "01:04:06.456789"
// td3 => "01:02:03.001000"
// with nanosecond resolution (9 digits)
// td2 => "01:02:03.123456789"
// td3 => "01:02:03.000001000"
time_duration(special_value sv)
Special values constructor. Important note: When a time_duration is a special value, either by construction or other means, the following accessor functions will give unpredictable results:
hours(), minutes(), seconds(), ticks(), 
fractional_seconds(), total_nanoseconds(),
total_microseconds(), total_milliseconds(),
total_seconds()
The remaining accessor functions will work as expected.

std::string to_simple_string(time_duration)
To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.
10:00:01.123456789
std::string to_iso_string(time_duration)
Convert to form HHMMSS,fffffffff.
100001,123456789

time_duration td(1,2,3, 1000);
td.fractional_seconds(); // --> 1000

防止程序重新打开的类

可以确认：如果需要关闭后，重新打开同一个串口，最好的方法是，用新串口对象及新io_service对象.

	if(m_port) m_port.reset(); //在对应的服务重置前，先把旧的串口对象删除了（因为删除析构的时候，需要用到io_service）
	m_io_service.reset(new boost::asio::io_service());
	m_port.reset(new boost::asio::serial_port(*m_io_service));

		//FIX：下面这个顺序是否有问题？  不正确，这样串口仍补占用，未关闭. 先调用m_port->close()再关闭服务就可以了。
		if(m_io_service) m_io_service->stop();
		if(m_io_service_thread) m_io_service_thread->join();
		if(m_port) m_port->close();


m_io_service.reset(new boost::asio::io_service);
new boost::asio::io_service 后面需要添加括号吗？

最近需要x取及DQUSB devices的模式，用到SetupDi****相P的API，@些API都是放在setupapi.he，找了很久，在W路上也有人提到，但都是片面的，也都分散在不同的地方，F在我就⑵湔合放在我自己的Bloge，@酉麓我用也不忘。@一MAPI是Microsoft PlatformSDK提供的，路揭苍VSe

// Open a handle to the serial port.
  ::HANDLE handle = ::CreateFileA(name.c_str(),
      GENERIC_READ | GENERIC_WRITE, 0, 0,
      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
  if (handle == INVALID_HANDLE_VALUE)
  {
    DWORD last_error = ::GetLastError();
    ec = boost::system::error_code(last_error,
        boost::asio::error::get_system_category());
    return ec;
  }
  
  	if(m_port) {
		m_port->stop();
		//m_port.reset();
	}
	m_service.stop();    先停止了SERVICE,再调用串口对象的关闭函数,关闭是无效的。
	if(m_comrev_thread) m_comrev_thread->join();
	
SerialPort 对象重新打开，最好的方法，是创建新的对象。同时其对应的SERVICE也需要，创建新的对象。

std::fstream  open 
语法: 
  void open( const char *filename );
  void open( const char *filename, openmode mode );

函数open()用于文件流。它打开filename 并将其与当前的流相关联。可以选择的模式有： 

模式 含义 
ios::app 添加输出 
ios::ate 当已打开时寻找到EOF 
ios::binary 以二进制模式打开文件 
ios::in 为读取打开文件 
ios::out 为写入打开文件 
ios::trunc 覆盖存在的文件 


ptime -> utc 一个整数
ptime -> string

http://www.howtogeek.com/howto/28653/debunking-myths-is-hiding-your-wireless-ssid-really-more-secure/
隐藏SSID没有意义？
netsh wlan show networks mode=bssid

inSSIDer began as a replacement for NetStumbler, a popular Windows Wi-Fi scanner, which had not been actively developed for several years and reputedly did not work with modern 64-bit operating systems or versions of Windows higher than Windows XP. The project was inspired by Charles Putney on The Code Project

最好的JSON解析器
http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
JsonCpp (http://jsoncpp.sourceforge.net/)
json_spirit::write( root, json_spirit::pretty_print );

I'm using JSON Spirit on a project at the moment, I'm impressed with it so far.
Note that it does rely on Boost (if only for headers).
Handy features:
Has Unicode support.
Uses std::vector to hold Arrays which helps interoperability.
Provides a pretty print function (write_formatted).
Has read and write functions for strings and streams.
Note that Objects are also implemented using vector (not map), which means slower access, but it does mean that the order of elements is maintained.

Boost property_tree does not fully support all type information. 
From the documentation: JSON values are mapped to nodes containing the value. 
However, all type information is lost; numbers, as well as the literals "null", "true" and "false" 
are simply mapped to their string form

Packet injection(注入)
By utilizing raw sockets, NDIS function calls, or direct access to a network adapter kernel mode driver, arbitrary packets can be constructed and injected into a computer network. These arbitrary packets can be constructed from any type of packet protocol (ICMP, TCP, UDP, and others) since there is full control over the packet header while the packet is being assembled

The basic service set (BSS) provides the basic building-block of an 802.11 wireless LAN.
Each BSS or ESS is identified by a service set identifier (SSID) - a 1 to 32 byte string

An extended service set (ESS) is a set of two or more interconnected wireless BSSs that share the same SSID (network name), 
security credentials and integrated (providing translation between 802.3 and 802.11 frames) wired local area networks that appear 
as a single BSS to the logical link control layer at any station associated with one of those BSSs 
which facilitates mobile IP and fast secure roaming applications; 
the BSSs may work on the same channel, or work on different channels to boost aggregate throughput.

boost::system::error_code 的类型判断
void SerialPort::on_receive_(const boost::system::error_code& ec, size_t bytes_transferred)
{
	try {
		//boost::mutex::scoped_lock lock( m_mutex );
		
		if( ec ) {                                          判断这个ERROR是否是，国为串已经关闭
			// 如果出错了，直接读下次的
			m_port.async_read_some( boost::asio::buffer( m_read_buf_raw, SERIAL_PORT_READ_BUF_SIZE), 
				boost::bind( &SerialPort::on_receive_, this, 
					boost::asio::placeholders::error, 
					boost::asio::placeholders::bytes_transferred ) );
			return;
		}


WinaMain 获取传递的参数
MFC也可以像控制台那样获取命令行参数：
利用GetCommandLineW()函数获得命令行参数，
利用CommandLineToArgvW()函数解析命令行参数
LPWSTR *szArglist = NULL;   
int nArgs = 0;   
szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);   
if( NULL != szArglist)   
{   
//szArglist就是保存参数的数组   
//nArgs是数组中参数的个数   
//数组的第一个元素表示进程的path，也就是szArglist[0]，其他的元素依次是输入参数。   
}   
//取得参数后，释放CommandLineToArgvW申请的空间   
LocalFree(szArglist); 

i/o 读写的codecvt local facet
boost/program_options/detail/utf8_codecvt_facet.hpp
		static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
		boost::property_tree::wptree xml;
		boost::property_tree::read_xml( wstring2string( xml_file ), xml, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
		
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
	boost::property_tree::read_xml( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
	boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );

http://msdn.microsoft.com/en-us/library/ff802693.aspx
串口通信开发文档。
Overlapped I/O operation

boost::asio::socket 异步读写时  socket关闭问题？需要同步吗？

Using the attached sample program (a slightly modified version of the daytime3 tutorial). When I connect with a telnet session to the server and close the connection directly I get the following output from the server: Transfer status: Success. Transfer status: Broken pipe. Transfer status: Broken pipe. Transfer status: Broken pipe.

After the first error I close the socket and would expect a boost::asio::error::operation_aborted error instead of the broken pipe.

Reproduced under both Debian Lenny (gcc 4.3.4) and Windows XP (MSVC 2008).
当调用close后，正在写的操作，就completed with an error as soon as the client closed the connection
The behaviour is correct. The write operations are not pending when you call close, it's just that the handlers haven't been called yet. The write operations themselves completed with an error as soon as the client closed the connection.

CloseHandle(impl.handle_) 串口，即使只有一个线程，也会死在句。退不出来。USB2PORT
I agree with both previous posts.

This is a bug in the driver for FTDI chipset under Windows XP.
The native method CloseHandle() never returns, when the port handle is closed.

https://connect.microsoft.com/VisualStudio/feedback/details/202137/serialport-close-hangs-the-application

This is not a normal situation.
Unplugging the USB device usually helps.
This problem is related to the glitches in the FTDI driver, which is responsible for implementing a virtual COM port. On the other hand those "glitches" are related to various malfunctions of the USB devices. (Of course this doesn't justify the FTDI driver).

BTW there're several other known problems with some FTDI drivers:

Sometimes call to CloseHandle just hangs the calling thread.
Sometimes also the application is still "visible" in the task manager, even after it's closed. Task manager can't terminate the application, and the debugger can't be attached to it. Its EXE file is locked (can't be erased).
Usually unplugging the USB device immediately helps in those situations. The FTDI driver, which seems to be "waiting for something" awakes.

一个boost::asio::socket, 在不同的线程，写，不加互斥，是不安全的。
The only way to protect you from hitting this case is to build your program to avoid situations like this.

One way to do that is by writing an application layer send buffer 
which a single thread is responsible for pushing onto the socket. 
That way you could protect the send buffer itself only. 
Keep in mind though that a simple std::vector won't work, 
since adding bytes to the end may end up re-allocating it, 
possibly while there is an outstanding async_write_some() referencing it. 
Instead, it's probably a good idea to use a linked list of buffers, a
nd make use of the scatter/gather feature of asio.

write and async_write are not thread safe in the manner you are using them. 
The canonical way to approach this is to queue your messages, then write them out one at a time.

Tip::tcp::socket  hread Safety
Distinct objects: Safe.
Shared objects: Unsafe.

boost::socket对象在工作线程中同步读写的情况，在另一线程里关闭？没有常规的办法。
Thread-safely closing a boost::asio::ip::tcp::socket being used synchronously
异步读写的情况下，可以先cancel
If your acceptor is in async_accept, you can call ip::tcp::acceptor::cancel() to cancel any async operations on it. 
试验结果，虽然cancel了，还是会接收到数据（m_serial_port.cancel  m_serial_port.close 那个会再引导异步I/O操作？）

Cancel is useful if you want to stop pending operations without closing down the socket.
Note that the Boost documentation recommends using close for greater portability (from doc page):
... For portable cancellation, consider using one of the following alternatives:
Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.
Use the close() function to simultaneously cancel the outstanding operations and close the socket.

Note however the remarks for cancel() also state When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. 
This function does not have the problems described above. 
C  Sam Miller Jun 22 '11 at 15:33 
thank you and Sam Miller for help,i understand a little now,thank you

cancel won't close the socket, so use cancel if you intend to continue using the socket object. In particular, if you have code in asynchronous handler methods that references the socket's member functions, you may not want to close the socket until you are guaranteed that your currently executing asynchronous handlers have completed.

cancel doesn't guarantee anything about currently executing asynchronous handlers, it only guarantees (per the boost documentation) that "This function causes all outstanding asynchronous connect, send and receive operations to finish immediately" in the case of the socket::cancel() call, or "This function forces the completion of any pending asynchronous operations on the host resolver" in the case of the resolver::cancel() call. This "completion" means that boost will call your asynchronous handler method, it has no jurisdiction to inject any cancellation logic into your asynchronous handler (not to mention it doesn't know about the handler's implementation to begin with).

I would suggest adding your own logic into your asynchronous handler method to handle the case where the socket/resolver/etc. is canceled. If you are calling the cancel method, then you likely have the ability to communicate this cancellation to the asynchronous handler method.

basic_serial_port::close (1 of 2 overloads)

Close the serial port.

void close();  根据下面的解释，Close前没有必要调用cancel
This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.

更改编辑框的字体
CWindow::SetFont
Changes the window's current font by sending a WM_SETFONT message to the window.

由StockObject font 创建一个CFont  m_Font.Attach(GetStockObject(DEFAULT_GUI_FONT)); 
stock font size 
CFont *m_pFont = new CFont;
m_pFont->CreateFont(...);
myEdit->SetFont(m_pFont);

GetDlgItem(IDC_EDIT1)->SetFont(&m_editFont);

void makebold(HWND hwnd)
{
	HFONT hFontB,hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	LOGFONT lf;
	GetObject(hFont, sizeof(LOGFONT), &lf);
	lf.lfWeight = FW_BOLD;
	hFontB = CreateFontIndirect(&lf);
	SendMessage(hwnd,WM_SETFONT,(int)hFontB,1);
}

To change the font: WM_SETFONT.
To change the back color: WM_CTLCOLOREDIT.

CComboBox:: 添加在后面
m_serial_port_cbox.AddString(L"COM1");
m_serial_port_cbox.AddString(L"COM2");
m_serial_port_cbox.AddString(L"COM3");
m_serial_port_cbox.AddString(L"COM4");
m_serial_port_cbox.AddString(L"COM5");
m_serial_port_cbox.AddString(L"COM6");
m_serial_port_cbox.AddString(L"COM7");
CComboBox:: 获取当前编辑框的文本
	CString cur_port;
	m_serial_port_cbox.GetWindowText(cur_port);


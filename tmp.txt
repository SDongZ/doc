http://www.fullhan.com/cp_35.asp
FH8735 高性能H.264编码芯片

        FH8735是一款高性能的多通道视音频编码芯片，支持H.264 Main Profile和Baseline Profile。FH8735具有1路1920*1080，2路1280*720或者8路标清的实时编码能力、内置丰富的视频预处理功能和多样的I/O接口，可满足视频监控产品的各种需求，能有效提高产品的集成度并降低系统成本，为视频监控产业的高清化提供强大的编码动力。 
          FH8735的目标应用包括嵌入式DVR、视频采集卡、DVS和百万素网络摄像机
		  
		  富瀚微电子有限公司成立于2004年4月，专注于视频监控芯片及解决方案，满足高速增长的数字视频监控市场对视频编解码和图像信号处理的芯片需求。
   富瀚提供高性能视频编解码SoC和图像信号处理器芯片，以及基于这些芯片的视频监控产品方案。 
    富瀚致力于与国内外设备制造商、解决方案提供商建立紧密合作关系，共同把握市场契机，为客户提供高性价的产品和服务，持续创造价值

http://www.csdn.net/article/2014-01-03/2818015-tiny-hardware-development-boards-of-2013
2013年终盘点：10款最精巧的硬件开发板

// 此源文件在Windows平台上必须保存为Unicode格式（即UTF-16小尾）
// 因为包含的汉字“??”，不能在简体中文版Windows默认的代码页936（即GBK）中表示。
// 该汉字在UTF-16小尾序中用4个字节表示，
// Windows操作系统能正确显示这样的在UTF-16需用4字节表示的字符
// 但是Windows API不能正确处理这样的在UTF-16需用4字节表示的字符，把它判定为2个UCS-2字符
 
#include <windows.h>
int main()
{
	const wchar_t lwc[]=L"??";
 
	MessageBoxW(NULL, lwc, lwc, MB_OK);
 
	int i = wcslen(lwc);
	printf("%d\n", i);
	int j = lstrlenW(lwc);
	printf("%d\n", j);
 
	return 0;
}

UTF8 <-> UNICODE
Class template std::wstring_convert performs conversions between byte string std::string and wide string std::basic_string<Elem>, 
using an individual code conversion facet Codecvt. 
std::wstring_convert assumes ownership of the conversion facet, and cannot use a facet managed by a locale. 
The standard facets suitable for use with std::wstring_convert are std::codecvt_utf8 for UTF-8/UCS2 and UTF-8/UCS4 conversions and std::codecvt_utf8_utf16 for UTF-8/UTF-16 conversions

void test()
{
wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
string s8 = u8"This is a UTF8 string";
wstring s16 = converter.from_bytes(s8);
string s88 = converter.to_bytes(s16);
if (s8!=s88)
cerr <"Insane!\n";
}

string <-> number
to_string

Preventing Logoff or Suspend During a Burn
If proper precautions are not made within an application, it is possible for a user to log off during a burn operation. This leads to the interruption of the burn process, which can result in lost data and possibly render the disc unusable.
To avoid this problem, the application should process the WM_QUERYENDSESSION message which is delivered prior to log off. If the application receives this message while performing a burn operation, return FALSE to cancel the logoff procedure. If the application allows the user to decide whether to continue logging off, a warning should be provided indicating that user will lose data.
Power transitions during the burn process can also create potential problems in the success of a burn activity. Preventing these complications during the burn process requires an application to be aware of when power transitions are about to take place. This is accomplished by by enabling the application to process the WM_POWERBROADCAST message. Applications developed for Windows XP or Windows Server 2003 can return BROADCAST_QUERY_DENY in response to PBT_APMQUERYSUSPEND, preventing Suspend during the burn process.
Due to changes in the Power Management Model for Windows Vista and Windows Server 2008, the PBT_APMQUERYSUSPEND event is no longer delivered to applications. Instead the PBT_APMSUSPEND event is delivered, providing two seconds for an application to prepare for the transition.
As a result of these changes, it is recommended that applications call the SetThreadExecutionState function to prevent a system idle time-out which ordinarily results in the transition to Suspend. It is important to remember that calling this function with the appropriate flags set will only prevent system idle, not an in-progress Suspend.


http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
Some OS-specific interfaces:

Mac OS X: _NSGetExecutablePath() (man 3 dyld)
Linux: readlink /proc/self/exe
Solaris: getexecname()
FreeBSD: sysctl CTL_KERN KERN_PROC KERN_PROC_PATHNAME -1
FreeBSD if it has procfs: readlink /proc/curproc/file (FreeBSD doesn't have procfs by default)
NetBSD: readlink /proc/curproc/exe
DragonFly BSD: readlink /proc/curproc/file
Windows: GetModuleFileName() with hModule = NULL

To summarize:

On Unixes with /proc really straight and realiable way is to:

readlink("/proc/self/exe", buf, bufsize) (Linux)

readlink("/proc/curproc/file", buf, bufsize) (FreeBSD)

readlink("/proc/self/path/a.out", buf, bufsize) (Solaris)

On Unixes without /proc (i.e. if above fails):

If argv[0] starts with "/" (absolute path) this is the path.

Otherwise if argv[0] contains "/" (relative path) append it to cwd (assuming it hasn't been changed yet).

Otherwise search directories in $PATH for executable argv[0].

Afterwards it may be reasonable to check whether the executable isn't actually a symlink. If it is resolve it relative to the symlink directory.

This step is not necessary in /proc method (at least for Linux). There the proc symlink points directly to executable.

Note that it is up to the calling process to set argv[0] correctly. It is right most of the times however there are occasions when the calling process cannot be trusted (ex. setuid executable).

On Windows: use GetModuleFileName(NULL, buf, bufsize)

boost 提出EXE当前路径
boost 从文件路径里提出 文件名，及路径

filesystem::path 类的成员
// decomposition 分解
        path  root_name() const;
        path  root_directory() const;
        path  root_path() const;
        path  relative_path() const;
        path  parent_path() const;
        path  filename() const;
        path  stem() const;
        path  extension() const;
		
 // query
        bool empty() const;
        bool has_root_name() const;
        bool has_root_directory() const;
        bool has_root_path() const;
        bool has_relative_path() const;
        bool has_parent_path() const;
        bool has_filename() const;
        bool has_stem() const;
        bool has_extension() const;
        bool is_absolute() const;
        bool is_relative() const;

		
// modifiers
        void  clear();
        path& make_absolute(const path& base);
        path& make_preferred();  // ISO/IEC 9945: no effect. Windows: convert slashes to backslashes
        path& remove_filename();
        path& replace_extension(const path& new_extension = path());
        void  swap(path& rhs);
		
#include <boost/filesystem.hpp>
std::string filename_noext;
filename_noext = boost::filesystem::path("D:\\files\\file.lua").stem().string().
const char* result_as_const_char = filename_noext.c_str();

wchar_t exe_path[MAX_PATH] = {0};
	::GetModuleFileName(GetModuleHandle(NULL), exe_path, MAX_PATH);
	::PathRemoveFileSpecW(exe_path);

IWebBrowser2
http://msdn.microsoft.com/en-us/library/aa752038(v=vs.85).aspx
Windows Internet Explorer's components can easily be reused thanks to its Component Object Model (COM)-based architecture. 
Two commonly used components are shdocvw.dll (the WebBrowser Control) and mshtml.dll (code-named "Trident").

BEGIN_EVENTSINK_MAP(CWebPageDlg, CDialogEx)
	ON_EVENT(CWebPageDlg, IDC_EXPLORER1, 259, CWebPageDlg::DocumentCompleteExplorer1, VTS_DISPATCH VTS_PVARIANT)
END_EVENTSINK_MAP()

Defines an OLE automation function in a dispatch map
DISP_FUNCTION(theClass, pszName, pfnMember, vtRetVal, vtsParams )

BEGIN_DISPATCH_MAP(CFixHtmlView, CHtmlView)
	DISP_FUNCTION(CFixHtmlView, "ParentLogin", ParentLogin, VT_BOOL, VTS_I4 VTS_I4)
	DISP_FUNCTION(CFixHtmlView, "ChildFinish", ChildFinish, VT_I4, VTS_I4 VTS_I4 VTS_BSTR)
	DISP_FUNCTION(CFixHtmlView, "ParentReg",ParentReg,VT_BOOL,VTS_I4 VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CFixHtmlView, "sessionOverTime",sessionOverTime,VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CFixHtmlView, "eyeOver",eyeOver, VT_BOOL, VTS_I4 VTS_I4)
END_DISPATCH_MAP()
<input type="button" onClick="send_result('123')" />
<script text="text/javascript">
function send_result(str){
	window.external.eyeOver(0,0);
}
</script>

Interface definition file 是一个接口文件，它应该由用户利用IDL(interface definition language)语言编辑uuidgen产生的IDL原型文件而成。IDL是一种用来说明操作（过程或函数），操作的参数以及数据类型的语言，它在语法上继承于C语言，但形式上和C语言有很多不同，当然也有一些符合自己特点的适合于分布计算的特殊语法。具体可参看DCE RPC specification中的IDL language specification部分 (idl.jpg)

IDL文件可以定义C和C++风格的结构，并可用它们作为函数的参数。 当IDL文件中有一个library时，MIDL将生成一个类型库
http://www.vckbase.com/index.php/wv/1218
COM 在设计初期，就定了一个目标：要能实现跨语言的调用。既然是跨语言的，那么组件的接口描述就必须在任何语言环境中都要能够认识。怎么办？用 .h 文件描述？------ C语言程序员笑了，真方便！BASIC 程序员哭了:-( 因此，微软使用了一个新的文件格式---IDL文件（接口定义描述语言）。IDL 是一个文本文件，它的语言语法比较简单，很象C。具体 IDL 文件的讲解，见下一回《COM 组件设计与应用（八）之添加新接口》。IDL 经过编译，生成二进制的等价类型库文件 TLB 提供给其它语言来使用。图三示意了 ATL COM 程序编译的过程
idl2-ATL 组件程序编译过程.jpg
说明1：编译后，类型库以 TLB 文件形式单独存在，同时也保存在目标文件的资源中。因此，我们将来在 #import 引入类型库的时候，既可以指定 TLB 文件，也可以指定目标文件；
说明2：我们作为 C/C++ 的程序员，还算是比较幸福的。因为 IDL 编译后，特意为我们提供了 C 语言形式的接口文件。
说明3：IDL 编译后生成代理/存根源程序，有：dlldata.c、xxx_p.c、xxxps.def、xxxps.mak，我们可以用 NMAKE.EXE 再次编译来产生真正的代理/存根DLL目标文件(注1)

idl文件转换成.h文件，你可以使用midl命令生成  idl-midl-h.gif
将idl文件加入到工程项目中，然后右键属性在output中生成文件即可

boost::date_time 的时间 -> 字符串的转换
                 字符串 -> 时间的转换

		CPositionData tmp(x, y, boost::posix_time::ptime::is_not_a_date_time); 这句话是错的，为什么？ 
		CPositionData tmp(x, y, boost::posix_time::not_a_date_time); 这个是正确的

时间点构造
tmp.time = boost::posix_time::microsec_clock::local_time();
ptime d3(not_a_date_time);

时长构造
tmp.duration = tmp.time - tmp.time;  构造时间段  tmp.duration = boost::posix_time::time_duration(0, 0, 0, 0);

using namespace boost::posix_time;
time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds

using namespace boost::posix_time;      
time_duration td = hours(1) + seconds(10); //01:00:01
td = hours(1) + nanoseconds(5); //01:00:00.000000005

Syntax	Description
Example
time_duration(hours,
              minutes,
              seconds,
              fractional_seconds)
Construct a duration from the counts. The fractional_second parameter is a number of units and is therefore affected by the resolution the application is compiled with (see Build-Compiler Information). If the fractional_seconds argument exceeds the limit of the compiled precision, the excess value will be "carried over" into the seconds field. See above for techniques to creating a resolution independent count.
time_duration td(1,2,3,9);
//1 hr 2 min 3 sec 9 nanoseconds
time_duration td2(1,2,3,123456789);
time_duration td3(1,2,3,1000);
// with microsecond resolution (6 digits)
// td2 => "01:04:06.456789"
// td3 => "01:02:03.001000"
// with nanosecond resolution (9 digits)
// td2 => "01:02:03.123456789"
// td3 => "01:02:03.000001000"
time_duration(special_value sv)
Special values constructor. Important note: When a time_duration is a special value, either by construction or other means, the following accessor functions will give unpredictable results:
hours(), minutes(), seconds(), ticks(), 
fractional_seconds(), total_nanoseconds(),
total_microseconds(), total_milliseconds(),
total_seconds()
The remaining accessor functions will work as expected.

std::string to_simple_string(time_duration)
To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.
10:00:01.123456789
std::string to_iso_string(time_duration)
Convert to form HHMMSS,fffffffff.
100001,123456789

time_duration td(1,2,3, 1000);
td.fractional_seconds(); // --> 1000

防止程序重新打开的类

可以确认：如果需要关闭后，重新打开同一个串口，最好的方法是，用新串口对象及新io_service对象.

	if(m_port) m_port.reset(); //在对应的服务重置前，先把旧的串口对象删除了（因为删除析构的时候，需要用到io_service）
	m_io_service.reset(new boost::asio::io_service());
	m_port.reset(new boost::asio::serial_port(*m_io_service));

		//FIX：下面这个顺序是否有问题？  不正确，这样串口仍补占用，未关闭. 先调用m_port->close()再关闭服务就可以了。
		if(m_io_service) m_io_service->stop();
		if(m_io_service_thread) m_io_service_thread->join();
		if(m_port) m_port->close();


m_io_service.reset(new boost::asio::io_service);
new boost::asio::io_service 后面需要添加括号吗？

最近需要x取及DQUSB devices的模式，用到SetupDi****相P的API，@些API都是放在setupapi.he，找了很久，在W路上也有人提到，但都是片面的，也都分散在不同的地方，F在我就⑵湔合放在我自己的Bloge，@酉麓我用也不忘。@一MAPI是Microsoft PlatformSDK提供的，路揭苍VSe

// Open a handle to the serial port.
  ::HANDLE handle = ::CreateFileA(name.c_str(),
      GENERIC_READ | GENERIC_WRITE, 0, 0,
      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
  if (handle == INVALID_HANDLE_VALUE)
  {
    DWORD last_error = ::GetLastError();
    ec = boost::system::error_code(last_error,
        boost::asio::error::get_system_category());
    return ec;
  }
  
  	if(m_port) {
		m_port->stop();
		//m_port.reset();
	}
	m_service.stop();    先停止了SERVICE,再调用串口对象的关闭函数,关闭是无效的。
	if(m_comrev_thread) m_comrev_thread->join();
	
SerialPort 对象重新打开，最好的方法，是创建新的对象。同时其对应的SERVICE也需要，创建新的对象。

std::fstream  open 
语法: 
  void open( const char *filename );
  void open( const char *filename, openmode mode );

函数open()用于文件流。它打开filename 并将其与当前的流相关联。可以选择的模式有： 

模式 含义 
ios::app 添加输出 
ios::ate 当已打开时寻找到EOF 
ios::binary 以二进制模式打开文件 
ios::in 为读取打开文件 
ios::out 为写入打开文件 
ios::trunc 覆盖存在的文件 


ptime -> utc 一个整数
ptime -> string

http://www.howtogeek.com/howto/28653/debunking-myths-is-hiding-your-wireless-ssid-really-more-secure/
隐藏SSID没有意义？
netsh wlan show networks mode=bssid

inSSIDer began as a replacement for NetStumbler, a popular Windows Wi-Fi scanner, which had not been actively developed for several years and reputedly did not work with modern 64-bit operating systems or versions of Windows higher than Windows XP. The project was inspired by Charles Putney on The Code Project

最好的JSON解析器
http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
JsonCpp (http://jsoncpp.sourceforge.net/)
json_spirit::write( root, json_spirit::pretty_print );

I'm using JSON Spirit on a project at the moment, I'm impressed with it so far.
Note that it does rely on Boost (if only for headers).
Handy features:
Has Unicode support.
Uses std::vector to hold Arrays which helps interoperability.
Provides a pretty print function (write_formatted).
Has read and write functions for strings and streams.
Note that Objects are also implemented using vector (not map), which means slower access, but it does mean that the order of elements is maintained.

Boost property_tree does not fully support all type information. 
From the documentation: JSON values are mapped to nodes containing the value. 
However, all type information is lost; numbers, as well as the literals "null", "true" and "false" 
are simply mapped to their string form

Packet injection(注入)
By utilizing raw sockets, NDIS function calls, or direct access to a network adapter kernel mode driver, arbitrary packets can be constructed and injected into a computer network. These arbitrary packets can be constructed from any type of packet protocol (ICMP, TCP, UDP, and others) since there is full control over the packet header while the packet is being assembled

The basic service set (BSS) provides the basic building-block of an 802.11 wireless LAN.
Each BSS or ESS is identified by a service set identifier (SSID) - a 1 to 32 byte string

An extended service set (ESS) is a set of two or more interconnected wireless BSSs that share the same SSID (network name), 
security credentials and integrated (providing translation between 802.3 and 802.11 frames) wired local area networks that appear 
as a single BSS to the logical link control layer at any station associated with one of those BSSs 
which facilitates mobile IP and fast secure roaming applications; 
the BSSs may work on the same channel, or work on different channels to boost aggregate throughput.

boost::system::error_code 的类型判断
void SerialPort::on_receive_(const boost::system::error_code& ec, size_t bytes_transferred)
{
	try {
		//boost::mutex::scoped_lock lock( m_mutex );
		
		if( ec ) {                                          判断这个ERROR是否是，国为串已经关闭
			// 如果出错了，直接读下次的
			m_port.async_read_some( boost::asio::buffer( m_read_buf_raw, SERIAL_PORT_READ_BUF_SIZE), 
				boost::bind( &SerialPort::on_receive_, this, 
					boost::asio::placeholders::error, 
					boost::asio::placeholders::bytes_transferred ) );
			return;
		}


WinaMain 获取传递的参数
MFC也可以像控制台那样获取命令行参数：
利用GetCommandLineW()函数获得命令行参数，
利用CommandLineToArgvW()函数解析命令行参数
LPWSTR *szArglist = NULL;   
int nArgs = 0;   
szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);   
if( NULL != szArglist)   
{   
//szArglist就是保存参数的数组   
//nArgs是数组中参数的个数   
//数组的第一个元素表示进程的path，也就是szArglist[0]，其他的元素依次是输入参数。   
}   
//取得参数后，释放CommandLineToArgvW申请的空间   
LocalFree(szArglist); 

i/o 读写的codecvt local facet
boost/program_options/detail/utf8_codecvt_facet.hpp
		static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
		boost::property_tree::wptree xml;
		boost::property_tree::read_xml( wstring2string( xml_file ), xml, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
		
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
	boost::property_tree::read_xml( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
	boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );

http://msdn.microsoft.com/en-us/library/ff802693.aspx
串口通信开发文档。
Overlapped I/O operation

boost::asio::socket 异步读写时  socket关闭问题？需要同步吗？

Using the attached sample program (a slightly modified version of the daytime3 tutorial). When I connect with a telnet session to the server and close the connection directly I get the following output from the server: Transfer status: Success. Transfer status: Broken pipe. Transfer status: Broken pipe. Transfer status: Broken pipe.

After the first error I close the socket and would expect a boost::asio::error::operation_aborted error instead of the broken pipe.

Reproduced under both Debian Lenny (gcc 4.3.4) and Windows XP (MSVC 2008).
当调用close后，正在写的操作，就completed with an error as soon as the client closed the connection
The behaviour is correct. The write operations are not pending when you call close, it's just that the handlers haven't been called yet. The write operations themselves completed with an error as soon as the client closed the connection.

CloseHandle(impl.handle_) 串口，即使只有一个线程，也会死在句。退不出来。USB2PORT
I agree with both previous posts.

This is a bug in the driver for FTDI chipset under Windows XP.
The native method CloseHandle() never returns, when the port handle is closed.

https://connect.microsoft.com/VisualStudio/feedback/details/202137/serialport-close-hangs-the-application

This is not a normal situation.
Unplugging the USB device usually helps.
This problem is related to the glitches in the FTDI driver, which is responsible for implementing a virtual COM port. On the other hand those "glitches" are related to various malfunctions of the USB devices. (Of course this doesn't justify the FTDI driver).

BTW there're several other known problems with some FTDI drivers:

Sometimes call to CloseHandle just hangs the calling thread.
Sometimes also the application is still "visible" in the task manager, even after it's closed. Task manager can't terminate the application, and the debugger can't be attached to it. Its EXE file is locked (can't be erased).
Usually unplugging the USB device immediately helps in those situations. The FTDI driver, which seems to be "waiting for something" awakes.

一个boost::asio::socket, 在不同的线程，写，不加互斥，是不安全的。
The only way to protect you from hitting this case is to build your program to avoid situations like this.

One way to do that is by writing an application layer send buffer 
which a single thread is responsible for pushing onto the socket. 
That way you could protect the send buffer itself only. 
Keep in mind though that a simple std::vector won't work, 
since adding bytes to the end may end up re-allocating it, 
possibly while there is an outstanding async_write_some() referencing it. 
Instead, it's probably a good idea to use a linked list of buffers, a
nd make use of the scatter/gather feature of asio.

write and async_write are not thread safe in the manner you are using them. 
The canonical way to approach this is to queue your messages, then write them out one at a time.

Tip::tcp::socket  hread Safety
Distinct objects: Safe.
Shared objects: Unsafe.

boost::socket对象在工作线程中同步读写的情况，在另一线程里关闭？没有常规的办法。
Thread-safely closing a boost::asio::ip::tcp::socket being used synchronously
异步读写的情况下，可以先cancel
If your acceptor is in async_accept, you can call ip::tcp::acceptor::cancel() to cancel any async operations on it. 
试验结果，虽然cancel了，还是会接收到数据（m_serial_port.cancel  m_serial_port.close 那个会再引导异步I/O操作？）

Cancel is useful if you want to stop pending operations without closing down the socket.
Note that the Boost documentation recommends using close for greater portability (from doc page):
... For portable cancellation, consider using one of the following alternatives:
Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.
Use the close() function to simultaneously cancel the outstanding operations and close the socket.

Note however the remarks for cancel() also state When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. 
This function does not have the problems described above. 
C  Sam Miller Jun 22 '11 at 15:33 
thank you and Sam Miller for help,i understand a little now,thank you

cancel won't close the socket, so use cancel if you intend to continue using the socket object. In particular, if you have code in asynchronous handler methods that references the socket's member functions, you may not want to close the socket until you are guaranteed that your currently executing asynchronous handlers have completed.

cancel doesn't guarantee anything about currently executing asynchronous handlers, it only guarantees (per the boost documentation) that "This function causes all outstanding asynchronous connect, send and receive operations to finish immediately" in the case of the socket::cancel() call, or "This function forces the completion of any pending asynchronous operations on the host resolver" in the case of the resolver::cancel() call. This "completion" means that boost will call your asynchronous handler method, it has no jurisdiction to inject any cancellation logic into your asynchronous handler (not to mention it doesn't know about the handler's implementation to begin with).

I would suggest adding your own logic into your asynchronous handler method to handle the case where the socket/resolver/etc. is canceled. If you are calling the cancel method, then you likely have the ability to communicate this cancellation to the asynchronous handler method.

basic_serial_port::close (1 of 2 overloads)

Close the serial port.

void close();  根据下面的解释，Close前没有必要调用cancel
This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.

更改编辑框的字体
CWindow::SetFont
Changes the window's current font by sending a WM_SETFONT message to the window.

由StockObject font 创建一个CFont  m_Font.Attach(GetStockObject(DEFAULT_GUI_FONT)); 
stock font size 
CFont *m_pFont = new CFont;
m_pFont->CreateFont(...);
myEdit->SetFont(m_pFont);

GetDlgItem(IDC_EDIT1)->SetFont(&m_editFont);

void makebold(HWND hwnd)
{
	HFONT hFontB,hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	LOGFONT lf;
	GetObject(hFont, sizeof(LOGFONT), &lf);
	lf.lfWeight = FW_BOLD;
	hFontB = CreateFontIndirect(&lf);
	SendMessage(hwnd,WM_SETFONT,(int)hFontB,1);
}

To change the font: WM_SETFONT.
To change the back color: WM_CTLCOLOREDIT.

CComboBox:: 添加在后面
m_serial_port_cbox.AddString(L"COM1");
m_serial_port_cbox.AddString(L"COM2");
m_serial_port_cbox.AddString(L"COM3");
m_serial_port_cbox.AddString(L"COM4");
m_serial_port_cbox.AddString(L"COM5");
m_serial_port_cbox.AddString(L"COM6");
m_serial_port_cbox.AddString(L"COM7");
CComboBox:: 获取当前编辑框的文本
	CString cur_port;
	m_serial_port_cbox.GetWindowText(cur_port);

 

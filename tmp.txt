boost::date_time 的时间 -> 字符串的转换
                 字符串 -> 时间的转换

		CPositionData tmp(x, y, boost::posix_time::ptime::is_not_a_date_time); 这句话是错的，为什么？ 
		CPositionData tmp(x, y, boost::posix_time::not_a_date_time); 这个是正确的
		
时间点构造
tmp.time = boost::posix_time::microsec_clock::local_time();
ptime d3(not_a_date_time);

时长构造
tmp.duration = tmp.time - tmp.time;  构造时间段  tmp.duration = boost::posix_time::time_duration(0, 0, 0, 0);

using namespace boost::posix_time;
time_duration td(1,2,3,4); //01:02:03.000000004 when resolution is nano seconds
time_duration td(1,2,3,4); //01:02:03.000004 when resolution is micro seconds

using namespace boost::posix_time;      
time_duration td = hours(1) + seconds(10); //01:00:01
td = hours(1) + nanoseconds(5); //01:00:00.000000005

Syntax	Description
Example
time_duration(hours,
              minutes,
              seconds,
              fractional_seconds)
Construct a duration from the counts. The fractional_second parameter is a number of units and is therefore affected by the resolution the application is compiled with (see Build-Compiler Information). If the fractional_seconds argument exceeds the limit of the compiled precision, the excess value will be "carried over" into the seconds field. See above for techniques to creating a resolution independent count.
time_duration td(1,2,3,9);
//1 hr 2 min 3 sec 9 nanoseconds
time_duration td2(1,2,3,123456789);
time_duration td3(1,2,3,1000);
// with microsecond resolution (6 digits)
// td2 => "01:04:06.456789"
// td3 => "01:02:03.001000"
// with nanosecond resolution (9 digits)
// td2 => "01:02:03.123456789"
// td3 => "01:02:03.000001000"
time_duration(special_value sv)
Special values constructor. Important note: When a time_duration is a special value, either by construction or other means, the following accessor functions will give unpredictable results:
hours(), minutes(), seconds(), ticks(), 
fractional_seconds(), total_nanoseconds(),
total_microseconds(), total_milliseconds(),
total_seconds()
The remaining accessor functions will work as expected.

std::string to_simple_string(time_duration)
To HH:MM:SS.fffffffff were fff is fractional seconds that are only included if non-zero.
10:00:01.123456789
std::string to_iso_string(time_duration)
Convert to form HHMMSS,fffffffff.
100001,123456789

time_duration td(1,2,3, 1000);
td.fractional_seconds(); // --> 1000

防止程序重新打开的类

可以确认：如果需要关闭后，重新打开同一个串口，最好的方法是，用新串口对象及新io_service对象.

	if(m_port) m_port.reset(); //在对应的服务重置前，先把旧的串口对象删除了（因为删除析构的时候，需要用到io_service）
	m_io_service.reset(new boost::asio::io_service());
	m_port.reset(new boost::asio::serial_port(*m_io_service));

		//FIX：下面这个顺序是否有问题？  不正确，这样串口仍补占用，未关闭. 先调用m_port->close()再关闭服务就可以了。
		if(m_io_service) m_io_service->stop();
		if(m_io_service_thread) m_io_service_thread->join();
		if(m_port) m_port->close();


m_io_service.reset(new boost::asio::io_service);
new boost::asio::io_service 后面需要添加括号吗？

最近需要x取及DQUSB devices的模式，用到SetupDi****相P的API，@些API都是放在setupapi.he，找了很久，在W路上也有人提到，但都是片面的，也都分散在不同的地方，F在我就⑵湔合放在我自己的Bloge，@酉麓我用也不忘。@一MAPI是Microsoft PlatformSDK提供的，路揭苍VSe

// Open a handle to the serial port.
  ::HANDLE handle = ::CreateFileA(name.c_str(),
      GENERIC_READ | GENERIC_WRITE, 0, 0,
      OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
  if (handle == INVALID_HANDLE_VALUE)
  {
    DWORD last_error = ::GetLastError();
    ec = boost::system::error_code(last_error,
        boost::asio::error::get_system_category());
    return ec;
  }
  
  	if(m_port) {
		m_port->stop();
		//m_port.reset();
	}
	m_service.stop();    先停止了SERVICE,再调用串口对象的关闭函数,关闭是无效的。
	if(m_comrev_thread) m_comrev_thread->join();
	
SerialPort 对象重新打开，最好的方法，是创建新的对象。同时其对应的SERVICE也需要，创建新的对象。

std::fstream  open 
语法: 
  void open( const char *filename );
  void open( const char *filename, openmode mode );

函数open()用于文件流。它打开filename 并将其与当前的流相关联。可以选择的模式有： 

模式 含义 
ios::app 添加输出 
ios::ate 当已打开时寻找到EOF 
ios::binary 以二进制模式打开文件 
ios::in 为读取打开文件 
ios::out 为写入打开文件 
ios::trunc 覆盖存在的文件 


ptime -> utc 一个整数
ptime -> string

http://www.howtogeek.com/howto/28653/debunking-myths-is-hiding-your-wireless-ssid-really-more-secure/
隐藏SSID没有意义？
netsh wlan show networks mode=bssid

inSSIDer began as a replacement for NetStumbler, a popular Windows Wi-Fi scanner, which had not been actively developed for several years and reputedly did not work with modern 64-bit operating systems or versions of Windows higher than Windows XP. The project was inspired by Charles Putney on The Code Project

最好的JSON解析器
http://stackoverflow.com/questions/245973/whats-the-best-c-json-parser
JsonCpp (http://jsoncpp.sourceforge.net/)
json_spirit::write( root, json_spirit::pretty_print );

I'm using JSON Spirit on a project at the moment, I'm impressed with it so far.
Note that it does rely on Boost (if only for headers).
Handy features:
Has Unicode support.
Uses std::vector to hold Arrays which helps interoperability.
Provides a pretty print function (write_formatted).
Has read and write functions for strings and streams.
Note that Objects are also implemented using vector (not map), which means slower access, but it does mean that the order of elements is maintained.

Boost property_tree does not fully support all type information. 
From the documentation: JSON values are mapped to nodes containing the value. 
However, all type information is lost; numbers, as well as the literals "null", "true" and "false" 
are simply mapped to their string form

Packet injection(注入)
By utilizing raw sockets, NDIS function calls, or direct access to a network adapter kernel mode driver, arbitrary packets can be constructed and injected into a computer network. These arbitrary packets can be constructed from any type of packet protocol (ICMP, TCP, UDP, and others) since there is full control over the packet header while the packet is being assembled

The basic service set (BSS) provides the basic building-block of an 802.11 wireless LAN.
Each BSS or ESS is identified by a service set identifier (SSID) - a 1 to 32 byte string

An extended service set (ESS) is a set of two or more interconnected wireless BSSs that share the same SSID (network name), 
security credentials and integrated (providing translation between 802.3 and 802.11 frames) wired local area networks that appear 
as a single BSS to the logical link control layer at any station associated with one of those BSSs 
which facilitates mobile IP and fast secure roaming applications; 
the BSSs may work on the same channel, or work on different channels to boost aggregate throughput.

boost::system::error_code 的类型判断
void SerialPort::on_receive_(const boost::system::error_code& ec, size_t bytes_transferred)
{
	try {
		//boost::mutex::scoped_lock lock( m_mutex );
		
		if( ec ) {                                          判断这个ERROR是否是，国为串已经关闭
			// 如果出错了，直接读下次的
			m_port.async_read_some( boost::asio::buffer( m_read_buf_raw, SERIAL_PORT_READ_BUF_SIZE), 
				boost::bind( &SerialPort::on_receive_, this, 
					boost::asio::placeholders::error, 
					boost::asio::placeholders::bytes_transferred ) );
			return;
		}


WinaMain 获取传递的参数
MFC也可以像控制台那样获取命令行参数：
利用GetCommandLineW()函数获得命令行参数，
利用CommandLineToArgvW()函数解析命令行参数
LPWSTR *szArglist = NULL;   
int nArgs = 0;   
szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);   
if( NULL != szArglist)   
{   
//szArglist就是保存参数的数组   
//nArgs是数组中参数的个数   
//数组的第一个元素表示进程的path，也就是szArglist[0]，其他的元素依次是输入参数。   
}   
//取得参数后，释放CommandLineToArgvW申请的空间   
LocalFree(szArglist); 

i/o 读写的codecvt local facet
boost/program_options/detail/utf8_codecvt_facet.hpp
		static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
		boost::property_tree::wptree xml;
		boost::property_tree::read_xml( wstring2string( xml_file ), xml, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
		
static std::locale utf8Locale( std::locale( "" ), new boost::program_options::detail::utf8_codecvt_facet() );
	boost::property_tree::read_xml( wstring2string( xml_path ), ptree, boost::property_tree::xml_parser::trim_whitespace, utf8Locale );
	boost::property_tree::write_xml( wstring2string( xml_path ), ptree, utf8Locale, settings );

http://msdn.microsoft.com/en-us/library/ff802693.aspx
串口通信开发文档。
Overlapped I/O operation

boost::asio::socket 异步读写时  socket关闭问题？需要同步吗？

Using the attached sample program (a slightly modified version of the daytime3 tutorial). When I connect with a telnet session to the server and close the connection directly I get the following output from the server: Transfer status: Success. Transfer status: Broken pipe. Transfer status: Broken pipe. Transfer status: Broken pipe.

After the first error I close the socket and would expect a boost::asio::error::operation_aborted error instead of the broken pipe.

Reproduced under both Debian Lenny (gcc 4.3.4) and Windows XP (MSVC 2008).
当调用close后，正在写的操作，就completed with an error as soon as the client closed the connection
The behaviour is correct. The write operations are not pending when you call close, it's just that the handlers haven't been called yet. The write operations themselves completed with an error as soon as the client closed the connection.

CloseHandle(impl.handle_) 串口，即使只有一个线程，也会死在句。退不出来。USB2PORT
I agree with both previous posts.

This is a bug in the driver for FTDI chipset under Windows XP.
The native method CloseHandle() never returns, when the port handle is closed.

https://connect.microsoft.com/VisualStudio/feedback/details/202137/serialport-close-hangs-the-application

This is not a normal situation.
Unplugging the USB device usually helps.
This problem is related to the glitches in the FTDI driver, which is responsible for implementing a virtual COM port. On the other hand those "glitches" are related to various malfunctions of the USB devices. (Of course this doesn't justify the FTDI driver).

BTW there're several other known problems with some FTDI drivers:

Sometimes call to CloseHandle just hangs the calling thread.
Sometimes also the application is still "visible" in the task manager, even after it's closed. Task manager can't terminate the application, and the debugger can't be attached to it. Its EXE file is locked (can't be erased).
Usually unplugging the USB device immediately helps in those situations. The FTDI driver, which seems to be "waiting for something" awakes.

一个boost::asio::socket, 在不同的线程，写，不加互斥，是不安全的。
The only way to protect you from hitting this case is to build your program to avoid situations like this.

One way to do that is by writing an application layer send buffer 
which a single thread is responsible for pushing onto the socket. 
That way you could protect the send buffer itself only. 
Keep in mind though that a simple std::vector won't work, 
since adding bytes to the end may end up re-allocating it, 
possibly while there is an outstanding async_write_some() referencing it. 
Instead, it's probably a good idea to use a linked list of buffers, a
nd make use of the scatter/gather feature of asio.

write and async_write are not thread safe in the manner you are using them. 
The canonical way to approach this is to queue your messages, then write them out one at a time.

Tip::tcp::socket  hread Safety
Distinct objects: Safe.
Shared objects: Unsafe.

boost::socket对象在工作线程中同步读写的情况，在另一线程里关闭？没有常规的办法。
Thread-safely closing a boost::asio::ip::tcp::socket being used synchronously
异步读写的情况下，可以先cancel
If your acceptor is in async_accept, you can call ip::tcp::acceptor::cancel() to cancel any async operations on it. 
试验结果，虽然cancel了，还是会接收到数据（m_serial_port.cancel  m_serial_port.close 那个会再引导异步I/O操作？）

Cancel is useful if you want to stop pending operations without closing down the socket.
Note that the Boost documentation recommends using close for greater portability (from doc page):
... For portable cancellation, consider using one of the following alternatives:
Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.
Use the close() function to simultaneously cancel the outstanding operations and close the socket.

Note however the remarks for cancel() also state When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. 
This function does not have the problems described above. 
C  Sam Miller Jun 22 '11 at 15:33 
thank you and Sam Miller for help,i understand a little now,thank you

cancel won't close the socket, so use cancel if you intend to continue using the socket object. In particular, if you have code in asynchronous handler methods that references the socket's member functions, you may not want to close the socket until you are guaranteed that your currently executing asynchronous handlers have completed.

cancel doesn't guarantee anything about currently executing asynchronous handlers, it only guarantees (per the boost documentation) that "This function causes all outstanding asynchronous connect, send and receive operations to finish immediately" in the case of the socket::cancel() call, or "This function forces the completion of any pending asynchronous operations on the host resolver" in the case of the resolver::cancel() call. This "completion" means that boost will call your asynchronous handler method, it has no jurisdiction to inject any cancellation logic into your asynchronous handler (not to mention it doesn't know about the handler's implementation to begin with).

I would suggest adding your own logic into your asynchronous handler method to handle the case where the socket/resolver/etc. is canceled. If you are calling the cancel method, then you likely have the ability to communicate this cancellation to the asynchronous handler method.

basic_serial_port::close (1 of 2 overloads)

Close the serial port.

void close();  根据下面的解释，Close前没有必要调用cancel
This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.

更改编辑框的字体
CWindow::SetFont
Changes the window's current font by sending a WM_SETFONT message to the window.

由StockObject font 创建一个CFont  m_Font.Attach(GetStockObject(DEFAULT_GUI_FONT)); 
stock font size 
CFont *m_pFont = new CFont;
m_pFont->CreateFont(...);
myEdit->SetFont(m_pFont);

GetDlgItem(IDC_EDIT1)->SetFont(&m_editFont);

void makebold(HWND hwnd)
{
	HFONT hFontB,hFont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
	LOGFONT lf;
	GetObject(hFont, sizeof(LOGFONT), &lf);
	lf.lfWeight = FW_BOLD;
	hFontB = CreateFontIndirect(&lf);
	SendMessage(hwnd,WM_SETFONT,(int)hFontB,1);
}

To change the font: WM_SETFONT.
To change the back color: WM_CTLCOLOREDIT.

CComboBox:: 添加在后面
m_serial_port_cbox.AddString(L"COM1");
m_serial_port_cbox.AddString(L"COM2");
m_serial_port_cbox.AddString(L"COM3");
m_serial_port_cbox.AddString(L"COM4");
m_serial_port_cbox.AddString(L"COM5");
m_serial_port_cbox.AddString(L"COM6");
m_serial_port_cbox.AddString(L"COM7");
CComboBox:: 获取当前编辑框的文本
	CString cur_port;
	m_serial_port_cbox.GetWindowText(cur_port);

	办理就诊卡、挂号、预约取号及收费指南
作者:张福春 来自：本网 时间：2012-4-26
文章点击率:4469      栏目点击率：20388
一、办理实名就医卡

 1、 在我院挂号就诊前，需先办理我院实名就医卡。

 2、 办理时需持病人本人的有效身份证件：身份证、护照、军官证等有效证件等，北京市医保病人必须持社保卡办理。

 3、 建卡时间及地点：6:45-17:00

                     6:45-8:00只可在一层大厅15、16号窗口办理

 12:00-13:30只可在13号窗口办理

 其它时间各楼层均可办理

 周末及节假日只可在一层大厅办理。

4、 办卡时请您提供真实有效的信息，尤其是联系方式。

二、挂号、预约取号及收费  挂号时请携带我院实名就诊卡，北京市医保患者请出示社保卡

挂号

     时间：7:00-17:00

      7:00开始挂当日全天号，11:00停止挂上午号，16:30停止挂下午号

      儿科实行24小时门急诊，请先带患儿到一层儿科分诊台初检，持条挂号。

       门诊大厅16号窗口是儿科专用挂号窗口，若其它挂号窗口开放也可挂号。

       节假日及17点后请到地下一层急诊挂号处挂儿科号。

       特需门诊：7:00开始在门诊楼八层挂号处挂号。

地点：门诊楼各层均设有挂号窗口，可挂除生殖中心外科室的号。

          7:00-8:00，12:00-13:00只开放一层大厅挂号窗口（请注意窗口提示）。 

      五官科楼挂号室位于一层大厅，可挂眼科、口腔科、耳鼻喉科及内科系统号

      生殖中心挂号室位于生殖中心，只可挂生殖中心号。

      周六日及节假日挂号只开放一层大厅挂号窗口（请注意窗口提示）

预约取号：

时间：7:00-16:30

地点： 门诊楼 ： 7:00-8:00一层12号窗口，8:00后各楼层挂号窗口均可取号

       五官科楼 ： 一层挂号窗口 

      取号时请携带您预约时提供的身份证（医保病人带医保卡）、医院就医卡、短信验证码

收费：

时间：7:30-18:00

地点： 8:00-12:00，13:30-17:00  各楼层均可收费

       7:30-8:00门诊楼三层6号收费窗口开放，12:00-13:30，17:00-18:00门诊楼一-四层部分收费窗口开放，五官科楼一层部分窗口开放（请注意窗口提示）

       周六日及节假日只开放门诊楼一至四层部分收费窗口（请注意窗口提示）

其他

      医保明细打印、财务结算相关问题咨询在门诊大厅一号窗口

各挂号、收费窗口均可办理就医卡与社保卡的关联业务


为了落实北京市卫生局统一要求，我院将于2011年11月8日（周二）将预约挂号平台更换到全市统一的114预约挂号平台，具体调整如下：

一、预约挂号方式

电话预约挂号：114（北京地区）/010-114（非北京地区）（24小时）

网络预约挂号： www.bjguahao.gov.cn（24小时）

二、预约须知

1、预约实名制：预约时，请提供就诊患者真实姓名、身份证号（身份证、军官证、护照）、您本人手机号等信息；

2、预约范围：①电话、网络及本院医师工作站：电话、网络预约挂号支持24小时服务（注：周六、日及节假日的门诊号不在预约范围内）；②每天上午9:30开始放号，下午3:00停止次日预约挂号；

3、就诊取号：预约成功后，请患者于就诊当日携带有效证件及我院就医卡到医院指定地点取号（核对与预约登记实名信息一致的本人有效证件和预约识别码），就医卡中所填身份证号、姓名、性别必须与预约时提供的患者身份信息一致，否则医院不提供预约的号源。(无就医卡的患者取号前须先到我院门诊发卡中心办理我院就医卡，医保患者须在办卡的同时提供社保卡进行关联)。

4、取号时间：电话、网络预约及现场预约取号时间为星期一～星期五，详细信息根据手机短信提示，过时号源作废。①北医三院院本部：7:00-16:30；②西三旗第二门诊部：8:30 -16:30；③中央党校院区：上午8:00-10:30，下午13:15-15:30；

5、取号窗口地点：

 ①门诊楼一层预约挂号取号处（除眼科、口腔科、耳鼻喉科外的号源）

 ②五官科楼一层挂号处（眼科、口腔科、耳鼻喉科号源）

 ③门诊楼八层特需门诊挂号处（特需门诊号源）

 ④西三旗北医三院第二门诊部挂号处

 ⑤中央党校院区

 ⑥生殖医学中心

    6、就诊顺序：预约挂号患者的就诊顺序在您预约成功时就已确定，请按照成功短信提示的建议时间来院就诊；

    7、预约取消：挂出的预约号如办理退号，至少在就诊前一工作日15:00前通过网站或者114电话凭预约识别码进行预约取消；

    8、预约限制：按照北京市卫生局统一平台预约的要求，同一患者实名（有效证件号）在同一就诊日、同一医院、同一科室只能预约1次；在同一就诊日的预约总量不可超过2次；在七日内的预约总量不可超过3次；

9、爽约处理：①如预约成功后患者未能按时就诊且不办理取消预约号视为爽约；②无故爽约累计达到3次将进入系统爽约名单，此后3个月内将无法享受预约挂号服务。

咨询电话： 82266899（周一至周五上午8：00―下午5：00）。


北京大学第三医院

2011年11月3日


美麻醉tW在1999年提出一套麻醉g前禁食原t，依食物的N^分所需的空腹rg：

正餐或富含油脂的食物：空腹rg至少八小r。

蔚牟忘c：胃排空rg^正餐快，所以空腹rg至少六小r。

乳品：乳u品c胃酸作用後，a生YK的固w，效果等同於蔚牟
      c，空腹rg至少六小r。

母乳：母乳停留在胃鹊rg^牛奶短，空腹rg四小r，可以p少
      幼阂蝻|I而哭[。

清流|：不含s|或添加物、不含固w例如果粒的料，例如：白_
        水、清茶，@些清流|的料，在胃韧Ａ舻rg^短，空腹
        rg大於二小r即可。
		
		
		
S多病患要接受手g之前，一定有印象深刻的事，那就是被告知^Σ豢梢猿|西，有些r候o士小姐就直f：「晚上十二c以後不可以吃|西？包括喝水ㄛ!」。於不常有I肚子的人碚f，@可真是不好受的事。所以大多档娜诵难Y都有大：槭颤N手g麻醉前一定要禁食？禁食rg要多久才颍拷食是不是什N|西都不能吃，B物都得停用幔

手g麻醉前一定要禁食?

病人安全是所有手gc麻醉的最高t， 如何So病人安全是所有to人T始K的任。如果病人吃了|西斫邮苈樽恚 麻醉中有可能因槲钢惺澄I出回流入口腔，甚至M入肺部， 引起“吸入性肺炎”，其死亡率根y可以高_百分之三十。榱朔乐谷绱乐惆l症的l生，麻醉之前的禁食於手g病患的安全碚f，在是非常重要的。半身麻醉的病人也S以椋我只有下半身麻醉，也需要禁食幔科所有手g麻醉都是要有f全的洌手gM行中也有NN不A期的因素，使得原淼陌肷砺樽肀仨改槿身麻醉。所以，m然是半身麻醉的病人，榱税踩的PS，也是要先遵守禁食的定。

患者需要禁食多久的rg呢？

美麻醉tW在1999年提出一套麻醉g前禁食原t，依食物的N^分所需的空腹rg：

正餐或富含油脂的食物：空腹rg至少八小r。

蔚牟忘c：胃排空rg^正餐快，所以空腹rg至少六小r。

乳品：乳u品c胃酸作用後，a生YK的固w，效果等同於蔚牟
      c，空腹rg至少六小r。

母乳：母乳停留在胃鹊rg^牛奶短，空腹rg四小r，可以p少
      幼阂蝻|I而哭[。

清流|：不含s|或添加物、不含固w例如果粒的料，例如：白_
        水、清茶，@些清流|的料，在胃韧Ａ舻rg^短，空腹
        rg大於二小r即可。

鹘y的定是氖中g日的凌晨十二c起，停止M食一切的固w或流w食物。但是禁食太久，一些老人、小孩很可能因|Iy耐及口乾舌燥而@得焦躁不安，甚至l生低血糖的情形。而且有r候手g_始rg很y_定，太Lrg的禁食在y以忍受，所以有些t院改成以上比^人性且合乎安全的方法。

新生骸⑷q以下小涸诰嚯x麻醉小r之前，t可喝一些清澈的液w如白_水或不含果粒或果渣的果汁或糖水，@涌p少旱目摁[。

但是榱税踩起，以上原tK不m用孕D、胃食道逆流、吞彩д{、c蠕赢常、或A施行c道手g的患者，@些患者是以鹘y午夜禁食^楸ｋU。

禁食是不是B物都得停用?

一般f恚在禁食期g包括口服物大都停止服用。但是心血管的物如抗高血核，是配少量白_水吞服以防止手g期g血捍蠓度的化。

o急例外r

有些o急手go法等病人空腹的rg，@r候的禁食就不在以上的定。病人得冒一cLU，但麻醉t仍然M全力椴∪祟A防胃热菸锬媪骷啊拔入性肺炎”l生。

g前禁食是麻醉前十分重要且攸P生命安全的大事，必由您配合_绦屑罢\告V麻醉t，才能避免一些可以避免的危U。在您或您的家人手g前，麻醉科同仁都先作g前L，e凡有P麻醉的及禁食的定，您都可以清楚，而本院麻醉科同仁也芬獗疽病qH的B度，槟f明白。

※t保健热H⒖贾用，o法取代H的t行椋如有任何疑洽相P科e之t，或有疾病立即就t。



北医三院就医攻略，2010年3月版，希望你不要用到
来源： 王夏复的日志
1.首先要有就医卡，没就医卡不能挂号，不能就医，不能开药，不能拍片，只能四处逛和顾客(病人们)侃大山。目前就医卡可在北医三院急诊楼门口西侧简易小亭内及北医三院眼科大楼一层大厅中办理。办理就医卡要带身份证或其他有效证件，并需要五元钱，办好的就医卡上贴了个条，条上有条形码和你的名字。

2.就医卡开通电话预约功能(电话预约卡)

所谓的电话预约卡其实就是指就医卡开通了电话预约功能，在办卡的地方就可以开通，开通此功能不花钱。为什么要开通这个功能呢？因为能电话预约成功是极其幸福的，而凌晨去排号是极其痛苦的。

3.向就医卡内存钱

就医卡不存钱是无法进行电话预约的，存钱的地方在北医三院眼科大楼一层大厅。对喽，如果你在急诊楼门口办卡，还得到眼科大楼去存钱。一般存50即可，除非你要挂特需号(见下面的解释)。存钱之后向工作人员要一本电话预约指南，上面说得很详细，并有每位专家出诊的时间、数字代码、专家专长等(这个也可以上网查一查)，没有这个指南基本无法进行电话预约。

4.特需号、专家号、普通号

普通号不用说了，5元钱就可以挂。专家号分7元、9元、14元三种，14元是主任医师、教授。特需号是什么意思呢？就是这个时候大夫本来无需出诊，但为了方便患者就医，另开辟一个时间段，挺好的吧，不过特需号一般为100、200、300元，对了，是人民币。

5.具体挂号

一般一个大夫出诊的时间是以半天为单位的，半天时间大约看20个号左右，这20个号有6个左右是供电话预约的，有11个左右是供门诊挂号处卖的，有3个左右供医生在就诊期间亲自为病人预约的(比如一个星期之后复检)。电话预约就不说了，预约指南上说得很详细，挂未来三天的，当天15：00之后不能挂第二天的。如果没预约上，还一定要看病，那就得去排队了，主要说说排队的情况，当天晚上22点之后，可以去三院门口找保安登记，准备排第二天的号，但并不是登记就可以开心地走了，等到第二天早上7点开始售号的时候再来就行，而是要一直在那儿等(汗啊...)，因为那儿的保安会每一个小时左右点一次名，如果你不在，那得，重新开始排吧。第二天凌晨三点左右时，大约会有50个人，大家可以估算去的时间。强烈推荐两人同去！三院门诊对面有永和大王、KFC等，两人可以换着去吃个东西，上个wc之类。第二天6点之前，都是在外面站着等(可以拿个小马扎)，6点时保安会把队伍放入大厅中，这时队伍会分为数个小队(因为有好多个挂号窗口，一楼7个，二楼几个不清楚)，一直等到7点，正式开始排号。如果你排在第一个，别美，极有可能极有可能会有膀大腰圆的号贩子非常自觉地站在你的前面，你放心，你不惹他，他会很客气的，另外，保安绝对是站在你的对立面的。这样，就会导致你最想要号很可能就没有了...我就经历过4点排号没排到的杯具...各位看官一定要早去。

6.挂不上怎么办？

拖着疲惫的身躯，你出了门诊部，没挂上...怎么办...下次这个大夫就诊可能就是一周之后了...三种途径，看你是什么样的人了，第一，找号贩子，出300元钱，一定能拿到想拿的号。第二，挂一个该科室的普通号，然后上去找诊室外面的分号员，和她好好地说，你可以想方设法，最常用的是：“大夫...我就找专家开个药

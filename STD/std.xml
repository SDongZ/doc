<?xml version='1.0' encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="zh-CN"
  xmlns:xlink='http://www.w3.org/1999/xlink'>
  <articleinfo>
    <title>STD学习</title>
    <author>
      <firstname>Xiang</firstname>
      <surname>Wang</surname>
    </author>
  </articleinfo>
  <section><title>std::string用法</title>
	<sect1><title>append()</title><para>在字符串的末尾添加文本 (可添加字符（可指定重复添加字符个数），字符串)</para></sect1>
	<sect1><title>std::string::reserve()</title><para>保留一定容量以容纳字符串（设置capacity值）</para></sect1>
	<sect1><title>std::string::substr( size_type index, size_type num = npos );</title><para></para></sect1>
	<sect1><title>std::string::data()</title><para>返回内容的字符数组形式 </para></sect1>
	<sect1><title>std::string::size_type copy( char *str, size_type num, size_type index );</title><para>拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数</para></sect1>
	<sect1><title>std::string::at()</title><para>按给定索引值返回字符</para></sect1>
	<sect1><title>astd::string::empty()</title><para>如果字符串为空，返回真</para></sect1>
	<sect1><title>std::string::length()</title><para>返回字符串的长度 </para></sect1>
	<sect1><title>std::string::size()</title><para>返回字符串中字符的数量 </para></sect1>
	<sect1><title>erase( iterator pos );</title><para>返回指向下一个字符的迭代器 </para></sect1>
	<sect1><title>erase( iterator start, iterator end );</title><para>返回指向下一个字符的迭代器</para></sect1>
	<sect1><title>std::string::erase( size_type index = 0, size_type num = npos );</title><para>如果不加参数，将会把字符串全部删除如果只指定index, 删除index及其后的所有字符</para></sect1>
	<sect1><title>assign()</title><programlisting><![CDATA[
string str1, str2 = "War and Peace";
str1.assign( str2, 4, 3 );  为字符串赋新值 
cout << str1 << endl;
	]]></programlisting></sect1>
	<sect1><title>swap()函数把str和本字符串交换</title><programlisting><![CDATA[
    string first( "This comes first" );
    string second( "And this is second" );
    first.swap( second );
    cout << first << endl;
    cout << second << endl;

显示：

    And this is second
    This comes first
	]]></programlisting></sect1>
	</section>
  <section><title>std::list用法</title>
	<sect1><title>back() / front()</title><para>返回最后/第一个元素</para></sect1>
	<sect1><title>pop_back() / pop_front()</title></sect1>
	<sect1><title>push_back() / push_front()</title></sect1>
  </section>
</article>
